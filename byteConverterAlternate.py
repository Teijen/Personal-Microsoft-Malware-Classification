import os
import re
import sys
from pathlib import Path
from binaryninja import *
from binaryninja import lineardisassembly
from binaryninja.function import DisassemblySettings
from binaryninja.enums import DisassemblyOption, LinearDisassemblyLineType, InstructionTextTokenType

import multiprocessing
from multiprocessing import Pool, Value, Lock
import tempfile
from functools import partial

import time
from datetime import datetime

def process_file(smp_dir, id):
    global counter
    global errorCounter
    global errorIDs
    global lock
    global binLock

    #print("Processing file: " + id)
# Read the .bytes file and convert it to a byte string
    with smp_dir.joinpath(id + ".bytes").open() as file:
        data = file.read()
        items = data.split()
        byte_list = [bytes.fromhex(item) for item in items if len(item) == 2 and item != "??"]
        byte_string = b"".join(byte_list)

    #print("File convert write: " + id)
    with tempfile.NamedTemporaryFile(delete=False) as temp:
    # Write the byte string to a file
        temp.write(byte_string)
        

    print(temp.name)

    with binLock:
        print("File with active lock: " + id)
        #binaryninja.set_worker_thread_count(os.cpu_count()-6)
        # Set log level to 'error' to mute warnings
        #binaryninja.disable_default_log()
        # 
        binaryninja.Settings().set_integer("analysis.limits.maxFunctionSize", 8192) #double limit
        #binaryninja.log.set_log_level(binaryninja.log.LogLevel.DebugLog)
        # Open the file with the appropriate BinaryViewType
        with binaryninja.load(temp.name) as bv:
            # # Print the type and architecture of the BinaryView
            # print(bv.view_type, bv.arch.name)
            # # Set the architecture and platform for the binary view
            # bv.arch = Architecture['x86_64']
            # bv.platform = Platform['windows-x86_64']
            print("Binary View load: " + id)
            # # Perform analysis on the binary view
            # bv.update_analysis_and_wait()

            # Read the .asm file and add the sections as segments to the binary view
            # with smp_dir.joinpath(id + ".asm").open() as file:
            #     asm_data = file.read()
            #     # Adjust the regular expression to match the section name and start address
            #     matches = list(re.finditer(r"(\.[\w]+):([0-9A-Fa-f]+)", asm_data))
            #     sections = {}
            #     for match in matches:
            #         # Get the section name and start address from the current match
            #         section_name = match.group(1)
            #         address = int(match.group(2), 16)
            #         # If this is the first instance of the section, set the start address
            #         if section_name not in sections:
            #             sections[section_name] = {"start": address}
            #         # Otherwise, update the end address
            #         else:
            #             sections[section_name]["end"] = address

            #     for section_name, addresses in sections.items():
            #         start = addresses["start"]
            #         end = addresses.get("end", start)  # If there's no end address, use the start address
            #         # Skip zero-length segments
            #         if start == end:
            #             continue
            #         # Set the permissions based on the section name
            #         if section_name == ".text":
            #             flags = SegmentFlag.SegmentReadable | SegmentFlag.SegmentExecutable
            #         elif section_name in [".data", ".bss"]:
            #             flags = SegmentFlag.SegmentReadable | SegmentFlag.SegmentWritable
            #         else:
            #             flags = SegmentFlag.SegmentReadable
            #         bv.add_auto_section(section_name, start, end - start, flags)
            #         # Skip rebasing for non-relocatable files
            #         if section_name == ".text":
            #             bv.rebase(start,True)

            bv.update_analysis_and_wait()
            print("Binary View analysis: " + id)
            # counterofTime = 0
            # while bv.analysis_info.analysis_time < 300000:
            #     time.sleep(1)  # Wait for 1 second before checking again
            #     counterofTime += 1
            #     print(counterofTime)
            #     print(bv.analysis_info.analysis_time)
            # Iterate over all sections in the BinaryView
            # for section in bv.sections.values():
            #     # Print the section name and start and end addresses
            #     print(f'Section {section.name} from {hex(section.start)} to {hex(section.end)}')


            # # Parse the .asm file to find the imported functions
            # matches = re.findall(r"extrn\s+(.*?):dword", asm_data)
            # for name in matches:
            #     # We don't have the address for the imported functions, so we just add them as undefined symbols
            #     bv.define_auto_symbol(Symbol(SymbolType.ImportedFunctionSymbol, 0, name))

            # # Parse the .asm file to find the system calls
            # matches = re.findall(r"call\s+(.*?)$", asm_data, re.MULTILINE)
            # for name in matches:
            #     # We don't have the address for the system calls, so we just add them as undefined symbols
            #     bv.define_auto_symbol(Symbol(SymbolType.DataSymbol, 0, name))
            # # Perform analysis on the binary view
            # bv.update_analysis_and_wait()
            # print(bv.start)

            # Perform analysis
            #bv.update_analysis_and_wait()
            outputPath = smp_dir.joinpath(id + ".llil")
            try:
                with open(outputPath, 'w') as f:
                    settings = DisassemblySettings()
                    settings.set_option(DisassemblyOption.ShowVariableTypesWhenAssigned)
                    settings.set_option(DisassemblyOption.GroupLinearDisassemblyFunctions)
                    settings.set_option(DisassemblyOption.WaitForIL)

                    for func in bv.functions:
                        obj = lineardisassembly.LinearViewObject.single_function_llil(func, settings)
                        cursor = obj.cursor
                        while True:
                            try:    
                                for line in cursor.lines:
                                    try:
                                        if line.type in [
                                            LinearDisassemblyLineType.FunctionHeaderStartLineType,
                                            LinearDisassemblyLineType.FunctionHeaderEndLineType,
                                            LinearDisassemblyLineType.AnalysisWarningLineType,
                                        ]:
                                            continue
                                        for i in line.contents.tokens:
                                            if i.type == InstructionTextTokenType.TagToken:
                                                continue
                                            #sys.stdout.write(str(i))
                                            f.write(str(i))
                                            
                                            

                                            
                                        #print("")
                                        f.write("\n")
                                        #print(multiprocessing.current_process())
                                        #print(time.time())
                                    except:
                                        continue


                                if not cursor.next():
                                    break
                            except:
                                break
                with lock:
                    counter.value += 1
                    print(counter.value)

            except:

                print(multiprocessing.current_process())
                print(time.time())
                with lock:
                    errorCounter.value += 1
                    errorIDs.append(id)
                    print(errorCounter.value)
                if f is not None:
                    os.remove(f.name)


            os.remove(temp.name)
#print(outputLines)
# Export the linear view of Binary Ninja in low level intermediate language representation
# # Write the LLIL to a file






#datetime stuff because I messed up
today = datetime(2024, 3, 6)
# Set the specific time you want (for example, 1 PM)
specific_time = today.replace(hour=13, minute=0, second=0, microsecond=0)
# Convert the specific time to a timestamp
specific_timestamp = specific_time.timestamp()

specific_time = today.replace(hour=14, minute=0, second=0, microsecond=0)
specific_timestamp_later = specific_time.timestamp()



# Path to the samples
smp_dir = '/home/logan/Dev/MicrosoftMalware/train'#os.getcwd() + "/data/samples"
#id = '0AnoOZDNbPXIr2MRBSCh'
smp_dir = Path(smp_dir)
counter = Value('i', 0)
errorCounter = Value('i', 0)
lock = Lock()
binLock = Lock()
errorIDs = []
now = time.time()

idList = []

timeList = []
# # Iterate over all files in the samples directory
for file in smp_dir.iterdir():
    # # Get the file name and extension
    name, ext = file.name.split(".")
    # # Skip files that don't have the .bytes extension
    if ext != "bytes":
        continue
    # # Get the file name and extension
    id = name
    # Get the modification time of the .llil file
    modification_time = os.stat(smp_dir.joinpath(id + ".llil")).st_mtime

    if smp_dir.joinpath(id + ".llil").exists() == False:
        idList.append(id)
    elif os.stat(smp_dir.joinpath(id + ".llil")).st_size == 0 and (specific_timestamp_later >= modification_time >= specific_timestamp):    
        idList.append(id)
    else:
        counter.value += 1
        #print(counter.value)
        continue
        
print(counter.value)
print(len(idList))
idList.remove('bUNesvZQmcIxfVl68GhF')#killed   
idList.remove('38IdJg2Se7po9rGZaNAw')#killed
idList.remove('8OpSLagR15Mvq7Zo9HzA')#seg fault
idList.remove('JfW6FM47u1otlOYUdwbH')#seg fault
idList.remove('83dL7Ovsfp9yCQTMehHD')#killed
idList.remove('kbZrNaLliTWFB3SM5K9e')#killed
#idList.remove('78AHqX2vjeyWO49RSoVl') #this one might be premature



# Create a pool of workers
# with Pool(4) as p:
#     p.map(partial(process_file, smp_dir), idList)

for each in idList:
    print(each)
    process_file(smp_dir, each)




print(errorIDs)


