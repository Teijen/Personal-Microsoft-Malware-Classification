import os
import re
import sys
from pathlib import Path
from binaryninja import *
from binaryninja import lineardisassembly
from binaryninja.function import DisassemblySettings
from binaryninja.enums import DisassemblyOption, LinearDisassemblyLineType, InstructionTextTokenType

import multiprocessing
from multiprocessing import Pool, Value, Lock
import tempfile
from functools import partial

import time
from datetime import datetime


# import resource
# import signal

# class MemoryLimitException(Exception):
#     """
#     Custom exception indicating memory limitation has been reached.
#     """
#     pass

# def handle_memory_limit(signum, frame):
#     raise MemoryLimitException("Memory limit reached during analysis")

# memory_limit_gb = 48
# memory_limit_bytes = memory_limit_gb * 1024 * 1024 * 1024

# # Set soft memory limit (adjust based on your system)
# resource.setrlimit(resource.RLIMIT_AS, (memory_limit_bytes, resource.RLIM_INFINITY))  #48GB soft limit

# signal.signal(signal.SIGSEGV, handle_memory_limit)






def process_file(smp_dir, id):
    global counter
    global errorCounter
    global errorIDs
    global lock
    global binLock

    #print("Processing file: " + id)
# Read the .bytes file and convert it to a byte string
    with smp_dir.joinpath(id + ".bytes").open() as file:
        data = file.read()
        items = data.split()
        byte_list = [bytes.fromhex(item) for item in items if len(item) == 2 and item != "??"]
        byte_string = b"".join(byte_list)

    #print("File convert write: " + id)
    with tempfile.NamedTemporaryFile(delete=False) as temp:
    # Write the byte string to a file
        temp.write(byte_string)
        

    print(temp.name)

    with binLock:
        print("File with active lock: " + id)
        #binaryninja.set_worker_thread_count(os.cpu_count()-6)
        # Set log level to 'error' to mute warnings
        #binaryninja.disable_default_log()
        # n  

        #print(binaryninja.Settings().keys())
        print(f"Memory limit set to: {binaryninja.Settings().get_integer('analysis.limits.cacheSize')} bytes")

        memory_limit_gb = 48
        memory_limit_bytes = memory_limit_gb * 1024 * 1024 * 1024

        
        binaryninja.Settings().set_integer("analysis.limits.maxVirtualMemoryUsage", memory_limit_bytes)
        print(f"Memory limit set to: {binaryninja.Settings().get_integer('analysis.limits.maxVirtualMemoryUsage')} bytes")


        binaryninja.Settings().set_integer("analysis.limits.maxFunctionSize", 2048) #half limit
        #binaryninja.Settings().set_integer("analysis.limits.maxFunctionSize", 8192) #double limit
        print(f"Memory limit set to: {binaryninja.Settings().get_integer('analysis.limits.maxFunctionSize')} bytes")
        binaryninja.Settings().set_integer("analysis.limits.maxFunctionUpdateCount", 3) #triple limit
        print(f"Memory limit set to: {binaryninja.Settings().get_integer('analysis.limits.maxFunctionUpdateCount')} bytes")
        #try a empty
        binaryninja.Settings().set_bool('analysis.linearSweep.permissive', True)
        #binaryninja.log.set_log_level(binaryninja.log.LogLevel.DebugLog)
        # Open the file with the appropriate BinaryViewType
        try:
            bv = binaryninja.load(temp.name)
            # # Print the type and architecture of the BinaryView
            #print(bv.view_type, bv.arch.name)
            # # Set the architecture and platform for the binary view
            # if bv.arch is None:
            #     # Set the BinaryViewType and architecture manually
            #     #print("Raw")
            #     bv = binaryninja.BinaryViewType['Raw'].open(temp.name)
            #     bv.arch = Architecture['x86_64']  # or 'x86_64' if your files are 64-bit
            #     #Raw_bv.platform = Platform['windows-x86_64']
            if bv.arch is None:
                print("Raw")
                bv = binaryninja.load(temp.name, options={'loader.architecture': 'x86_64'})    
            # bv.platform = Platform['windows-x86_64']
            print("Binary View load: " + id)
            # # Perform analysis on the binary view
            bv.update_analysis_and_wait()
            print("number of functions: " + str(len(bv.functions)))
            if len(bv.functions) == 0:
                print("no functions")
                bv = binaryninja.load(temp.name, options={'loader.architecture': 'x86'})

            bv.update_analysis_and_wait()
            print("number of functions: " + str(len(bv.functions)))
            if len(bv.functions) == 0:
                print("no functions")
                bv = binaryninja.load(temp.name, options={'loader.architecture': 'x86_16'})

            bv.update_analysis_and_wait()

        except:
            print("Error loading binary view")
            with lock:
                errorCounter.value += 1
                errorIDs.append(id)
                print(errorCounter.value)
            return
        # Read the .asm file and add the sections as segments to the binary view
        # with smp_dir.joinpath(id + ".asm").open() as file:
        #     asm_data = file.read()
        #     # Adjust the regular expression to match the section name and start address
        #     matches = list(re.finditer(r"(\.[\w]+):([0-9A-Fa-f]+)", asm_data))
        #     sections = {}
        #     for match in matches:
        #         # Get the section name and start address from the current match
        #         section_name = match.group(1)
        #         address = int(match.group(2), 16)
        #         # If this is the first instance of the section, set the start address
        #         if section_name not in sections:
        #             sections[section_name] = {"start": address}
        #         # Otherwise, update the end address
        #         else:
        #             sections[section_name]["end"] = address

        #     for section_name, addresses in sections.items():
        #         start = addresses["start"]
        #         end = addresses.get("end", start)  # If there's no end address, use the start address
        #         # Skip zero-length segments
        #         if start == end:
        #             continue
        #         # Set the permissions based on the section name
        #         if section_name == ".text":
        #             flags = SegmentFlag.SegmentReadable | SegmentFlag.SegmentExecutable
        #         elif section_name in [".data", ".bss"]:
        #             flags = SegmentFlag.SegmentReadable | SegmentFlag.SegmentWritable
        #         else:
        #             flags = SegmentFlag.SegmentReadable
        #         bv.add_auto_section(section_name, start, end - start, flags)
        #         # Skip rebasing for non-relocatable files
        #         if section_name == ".text":
        #             bv.rebase(start,True)
        
        #bv.update_analysis_and_wait()
        print("Binary View analysis: " + id)
        # counterofTime = 0
        # while bv.analysis_info.analysis_time < 300000:
        #     time.sleep(1)  # Wait for 1 second before checking again
        #     counterofTime += 1
        #     print(counterofTime)
        #     print(bv.analysis_info.analysis_time)
        # Iterate over all sections in the BinaryView
        # for section in bv.sections.values():
        #     # Print the section name and start and end addresses
        #     print(f'Section {section.name} from {hex(section.start)} to {hex(section.end)}')


        # # Parse the .asm file to find the imported functions
        # matches = re.findall(r"extrn\s+(.*?):dword", asm_data)
        # for name in matches:
        #     # We don't have the address for the imported functions, so we just add them as undefined symbols
        #     bv.define_auto_symbol(Symbol(SymbolType.ImportedFunctionSymbol, 0, name))

        # # Parse the .asm file to find the system calls
        # matches = re.findall(r"call\s+(.*?)$", asm_data, re.MULTILINE)
        # for name in matches:
        #     # We don't have the address for the system calls, so we just add them as undefined symbols
        #     bv.define_auto_symbol(Symbol(SymbolType.DataSymbol, 0, name))
        # # Perform analysis on the binary view
        # bv.update_analysis_and_wait()
        # print(bv.start)

        # Perform analysis
        #bv.update_analysis_and_wait()
        outputPath = smp_dir.joinpath(id + ".llil")
        try:
            with open(outputPath, 'w') as f:
                settings = DisassemblySettings()
                settings.set_option(DisassemblyOption.ShowVariableTypesWhenAssigned)
                settings.set_option(DisassemblyOption.GroupLinearDisassemblyFunctions)
                settings.set_option(DisassemblyOption.WaitForIL)
                
                for func in bv.functions:
                    obj = lineardisassembly.LinearViewObject.single_function_llil(func, settings)
                    cursor = obj.cursor
                    while True:
                        try:    
                            for line in cursor.lines:
                                try:
                                    if line.type in [
                                        LinearDisassemblyLineType.FunctionHeaderStartLineType,
                                        LinearDisassemblyLineType.FunctionHeaderEndLineType,
                                        LinearDisassemblyLineType.AnalysisWarningLineType,
                                    ]:
                                        continue
                                    for i in line.contents.tokens:
                                        if i.type == InstructionTextTokenType.TagToken:
                                            continue
                                        #sys.stdout.write(str(i))
                                        f.write(str(i))
                                        
                                        

                                        
                                    #print("")
                                    f.write("\n")
                                    #print(multiprocessing.current_process())
                                    #print(time.time())
                                except:
                                    continue


                            if not cursor.next():
                                break
                        except:
                            break
            with lock:
                counter.value += 1
                print(counter.value)

        except:

            print(multiprocessing.current_process())
            print(time.time())
            with lock:
                errorCounter.value += 1
                errorIDs.append(id)
                print(errorCounter.value)
            if f is not None:
                os.remove(f.name)


        os.remove(temp.name)
#print(outputLines)
# Export the linear view of Binary Ninja in low level intermediate language representation
# # Write the LLIL to a file






#datetime stuff because I messed up
today = datetime(2024, 3, 6)
# Set the specific time you want (for example, 1 PM)
specific_time = today.replace(hour=13, minute=0, second=0, microsecond=0)
# Convert the specific time to a timestamp
specific_timestamp = specific_time.timestamp()

specific_time = today.replace(hour=14, minute=0, second=0, microsecond=0)
specific_timestamp_later = specific_time.timestamp()



# Path to the samples
smp_dir = '/home/logan/Dev/MicrosoftMalware/train'#os.getcwd() + "/data/samples"
#id = '0AnoOZDNbPXIr2MRBSCh'
smp_dir = Path(smp_dir)
counter = Value('i', 0)
errorCounter = Value('i', 0)
lock = Lock()
binLock = Lock()
errorIDs = []
now = time.time()

idList = []

timeList = []
# # Iterate over all files in the samples directory
for file in smp_dir.iterdir():
    # # Get the file name and extension
    name, ext = file.name.split(".")
    # # Skip files that don't have the .bytes extension
    if ext != "bytes":
        continue
    # # Get the file name and extension
    id = name
    # Get the modification time of the .llil file
    modification_time = os.stat(smp_dir.joinpath(id + ".llil")).st_mtime

    if smp_dir.joinpath(id + ".llil").exists() == False:
        idList.append(id)
    elif os.stat(smp_dir.joinpath(id + ".llil")).st_size == 0 and (specific_timestamp_later >= modification_time >= specific_timestamp):    
        idList.append(id)
    else:
        counter.value += 1
        #print(counter.value)
        continue
        
print(counter.value)
print(len(idList)) 
#idList.remove('38IdJg2Se7po9rGZaNAw')#killed
##idList.remove('8OpSLagR15Mvq7Zo9HzA')#seg fault
#idList.remove('JfW6FM47u1otlOYUdwbH')#seg fault
#idList.remove('83dL7Ovsfp9yCQTMehHD')#killed
#idList.remove('kbZrNaLliTWFB3SM5K9e')#killed
#idList.remove('figPlLtepGyVmDwXExc6')#killed  
#idList.remove('iA6lTGX7Lsy4FNHuDb5k')#killed
#idList.remove('fpeCgovE4zqPdDLmhxNA')#killed
#idList.remove('78AHqX2vjeyWO49RSoVl') #this one might be premature

#this was done and returned an empy converter
#added permissive sweep to see if results change


# Create a pool of workers
# with Pool(4) as p:
#     p.map(partial(process_file, smp_dir), idList)
for each in idList:
    print(each)
    process_file(smp_dir, each)



print(len(idList))
print(errorIDs)


