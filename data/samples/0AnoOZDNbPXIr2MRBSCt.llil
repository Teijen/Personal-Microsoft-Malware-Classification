int32_t sub_0()
jump([0x100080f8].d)

int32_t sub_6()
jump([0x100080f4].d)

int32_t sub_18()
push(ebp)
ebp = esp {__saved_ebp}
esp = esp - 0x10
eax = [0x10009000].d
[ebp - 8 {var_c}].d = 0
[ebp - 4 {var_8}].d = 0
push(ebx)
push(edi)
edi = 0xbb40e64e
cond:0 = eax == edi
ebx = 0xffff0000
if (cond:0) then 12 @ 0x48 else 31 @ 0x3d

push(esi)
eax = ebp - 8 {var_c}
push(eax)
call([0x1000806c].d), esp += 4
esi = [ebp - 4 {var_8}].d
esi = esi ^ [ebp - 8 {var_c}].d
call([0x10008070].d)
esi = esi ^ eax
call([0x10008018].d)
esi = esi ^ eax
call([0x10008028].d)
esi = esi ^ eax
eax = ebp - 0x10 {var_14}
push(eax)
call([0x10008074].d), esp += 4
eax = [ebp - 0xc {var_10}].d
eax = eax ^ [ebp - 0x10 {var_14}].d
esi = esi ^ eax
if (esi != edi) then 32 @ 0x90 else 33 @ 0x87

if ((ebx & eax) == 0) then 12 @ 0x48 else 35 @ 0x3f

if ((ebx & esi) != 0) then 38 @ 0x99 else 43 @ 0x92

esi = 0xbb40e64f
goto 38 @ 0x99

eax = not.d(eax)
[0x10009004].d = eax
goto 47 @ 0xa8

[0x10009000].d = esi
esi = not.d(esi)
[0x10009004].d = esi
esi = pop
goto 47 @ 0xa8

eax = esi
eax = eax << 0x10
esi = esi | eax
goto 38 @ 0x99

edi = pop
ebx = pop
esp = ebp
ebp = pop
<return> jump(pop)

int32_t sub_ac()
push(esi)
push(0x80)
call([0x1000809c].d)
esi = eax
push(esi)
call([0x10008098].d)
cond:0 = esi != 0
ecx = pop
ecx = pop
[0x1000e45c].d = eax
[0x1000e458].d = eax
if (cond:0) then 12 @ 0xd6 else 22 @ 0xd1

[esi].d = 0
call(sub_4b6)
push(0x100014da)
call(sub_4a4)
[esp {var_8}].d = 0x100013f3
call(sub_4a4)
ecx = pop
eax = 0
esi = pop
<return> jump(pop)

eax = 0
eax = eax + 1
esi = pop
<return> jump(pop)

int32_t __stdcall sub_f9(int32_t arg1, int32_t arg2, int32_t arg3)
eax = [esp + 8 {arg1}].d
push(ebp)
ebp = 0
if (eax != ebp) then 4 @ 0x112 else 12 @ 0x10a

cond:0 = eax != 1
ecx = [0x100080b4].d
ecx = [ecx].d
push(ebx)
push(esi)
push(edi)
[0x1000e44c].d = ecx
if (cond:0) then 13 @ 0x202 else 14 @ 0x12c

if ([0x10009be0].d s<= ebp) then 20 @ 0x146 else 22 @ &data_10c

if (eax != ebp) then 24 @ 0x2b2 else 27 @ 0x208

eax = [fsbase + 0x18].d
esi = [eax + 4].d
ebx = [0x10008008].d
[esp + 0x18 {arg1}].d = ebp
edi = 0x1000e454
goto 30 @ 0x15c

eax = 0
goto 35 @ 0x2b8

[0x10009be0].d = [0x10009be0].d - 1
goto 4 @ 0x112

eax = 0
eax = eax + 1
goto 39 @ 0x2b5

esi = [0x10008008].d
edi = 0x1000e454
goto 43 @ 0x220

push(ebp)
push(esi)
push(edi)
call(ebx), esp += 0xc
if (eax != ebp) then 48 @ 0x14f else 49 @ 0x165

ebp = pop
temp0.d = pop
esp = esp + 0xc
<return> jump(temp0.d)

edi = pop
esi = pop
ebx = pop
goto 35 @ 0x2b8

push(ebp)
push(zx.d(1))
push(edi)
call(esi), esp += 0xc
if (eax != 0) then 50 @ &data_214+1 else 53 @ 0x22a

if (eax == esi) then 55 @ 0x167 else 57 @ 0x151

goto 60 @ 0x16f

push(0x3e8)
call([0x10008064].d), esp += 4
goto 43 @ 0x220

eax = [0x1000e450].d
if (eax == 2) then 65 @ 0x23e else 72 @ 0x234

[esp + 0x18 {arg1}].d = 1
goto 60 @ 0x16f

push(0x3e8)
call([0x10008064].d), esp += 4
goto 30 @ 0x15c

eax = [0x1000e450].d
cond:1 = eax == 0
push(zx.d(2))
esi = pop
if (cond:1) then 76 @ 0x184 else 84 @ 0x17b

push([0x1000e45c].d)
ebx = [0x100080a4].d
call(ebx)
ebp = eax
cond:2 = ebp == 0
ecx = pop
if (cond:2) then 87 @ 0x29f else 92 @ 0x253

push(zx.d(0x1f))
call(sub_648), esp += 4
ecx = pop
goto 24 @ 0x2b2

push(0x10008118)
push(0x10008110)
[0x1000e450].d = 1
call(sub_642)
cond:3 = eax == 0
ecx = pop
ecx = pop
if (cond:3) then 97 @ 0x1aa else 103 @ 0x1a3

push(zx.d(0x1f))
call(sub_648), esp += 4
goto 105 @ 0x1c0

push(zx.d(0))
push(edi)
[0x1000e450].d = 0
call([0x10008068].d), esp += 8
goto 24 @ 0x2b2

push([0x1000e458].d)
call(ebx)
ecx = pop
esi = eax
goto 108 @ 0x280

push(0x1000810c)
push(0x10008108)
call(sub_63c), esp += 4
ecx = pop
[0x1000e450].d = esi
goto 105 @ 0x1c0

eax = 0
goto 39 @ 0x2b5

cond:4 = [esp + 0x1c {arg2}].d != ebp
ecx = pop
if (cond:4) then 110 @ 0x1d5 else 111 @ &data_1c4+3

esi = esi - 4
if (esi u>= ebp) then 115 @ 0x263 else 116 @ 0x287

if ([0x1000e460].d == ebp) then 123 @ 0x1f5 else 125 @ 0x1d7

push(ebp)
push(edi)
call([0x10008068].d), esp += 8
goto 110 @ 0x1d5

if ([esi].d == 0) then 108 @ 0x280 else 130 @ 0x265

push(ebp)
call([0x100080d8].d)
ecx = pop
call([0x100080a0].d)
[0x1000e458].d = eax
[0x1000e45c].d = eax
goto 87 @ 0x29f

[0x10009be0].d = [0x10009be0].d + 1
goto 24 @ 0x2b2

push(0x1000e460)
call(sub_580)
cond:5 = eax == 0
ecx = pop
if (cond:5) then 123 @ 0x1f5 else 134 @ 0x1e6

eax = [esi].d
[esp + 0x18 {arg1}].d = eax
call([0x100080a0].d)
if ([esp + 0x18 {arg1}].d == eax) then 108 @ 0x280 else 139 @ 0x277

push([esp + 0x1c {arg3}].d)
push(esi)
push([esp + 0x1c {arg1}].d)
call([0x1000e460].d), esp += 0xc
goto 123 @ 0x1f5

push([esp + 0x18 {arg1}].d)
call(ebx)
ecx = pop
call(eax)
goto 108 @ 0x280

int32_t sub_2bc()
push(zx.d(0x10))
push(0x10008528)
call(sub_674), esp += 8
edi = ecx
esi = edx
ebx = [ebp + 8].d
eax = 0
eax = eax + 1
[ebp - 0x1c].d = eax
ecx = 0
[ebp - 4].d = ecx
[0x10009008].d = esi
[ebp - 4].d = eax
if (esi != ecx) then 14 @ 0x2f9 else 15 @ 0x2ed

if (esi == eax) then 16 @ 0x300 else 18 @ 0x2fe

if ([0x10009be0].d != ecx) then 14 @ 0x2f9 else 19 @ 0x2ef

eax = [0x1000813c].d
if (eax == ecx) then 21 @ 0x315 else 22 @ 0x309

if (esi != 2) then 28 @ 0x32e else 16 @ 0x300

[ebp - 0x1c].d = ecx
goto 34 @ 0x3ae

if ([ebp - 0x1c].d == 0) then 34 @ 0x3ae else 40 @ 0x31b

push(edi)
push(esi)
push(ebx)
call(eax), esp += 0xc
[ebp - 0x1c].d = eax
goto 21 @ 0x315

push(edi)
push(esi)
push(ebx)
call(sub_654), esp += 0xc
[ebp - 0x1c].d = eax
if (esi != 1) then 46 @ 0x364 else 47 @ 0x340  {"u WPS"}

[ebp - 4].d = 0
[ebp - 4].d = -2
call(sub_3c7)
eax = [ebp - 0x1c].d
call(sub_6b9)
<return> jump(pop)

push(edi)
push(esi)
push(ebx)
call(sub_f9), esp += 0xc
[ebp - 0x1c].d = eax
if (eax == 0) then 34 @ 0x3ae else 28 @ 0x32e

if (esi == 0) then 48 @ 0x36b else 53 @ 0x369

if (eax != 0) then 46 @ 0x364 else 54 @ 0x342

push(edi)
push(esi)
push(ebx)
call(sub_f9), esp += 0xc
if (eax != 0) then 64 @ 0x37e else 65 @ 0x377

if (esi != 3) then 34 @ 0x3ae else 48 @ 0x36b

push(edi)
push(eax)
push(ebx)
call(sub_654), esp += 0xc
push(edi)
push(zx.d(0))
push(ebx)
call(sub_f9), esp += 0xc
eax = [0x1000813c].d
if (eax == 0) then 46 @ 0x364 else 67 @ 0x35c

if ([ebp - 0x1c].d == 0) then 34 @ 0x3ae else 72 @ 0x380

[ebp - 0x1c].d = [ebp - 0x1c].d & eax
goto 64 @ 0x37e

push(edi)
push(zx.d(0))
push(ebx)
call(eax), esp += 0xc
goto 46 @ 0x364

eax = [0x1000813c].d
if (eax == 0) then 34 @ 0x3ae else 74 @ 0x389

push(edi)
push(esi)
push(ebx)
call(eax), esp += 0xc
[ebp - 0x1c].d = eax
goto 34 @ 0x3ae

int32_t sub_393(void* arg1 @ ebp)
eax = [ebp - 0x14].d
ecx = [eax].d
ecx = [ecx].d
[ebp - 0x20].d = ecx
push(eax)
push(ecx)
call(sub_64e)
ecx = pop
ecx = pop
<return> jump(pop)

int32_t sub_3a7(void* arg1 @ ebp)
esp = [ebp - 0x18].d
[ebp - 0x1c].d = 0
[ebp - 4].d = 0
[ebp - 4].d = -2
call(sub_3c7)
eax = [ebp - 0x1c].d
call(sub_6b9)
<return> jump(pop)

int32_t sub_3c7()
[0x10009008].d = -1
<return> jump(pop)

int32_t __stdcall sub_3d2(int32_t arg1, int32_t arg2, int32_t arg3)
if ([esp + 8 {arg2}].d != 1) then 1 @ 0x3de else 9 @ 0x3d9

push([esp + 4 {arg1}].d)
ecx = [esp + 0x10 {arg3}].d
edx = [esp + 0xc {arg2}].d
call(sub_2bc)
ecx = pop
temp0.d = pop
esp = esp + 0xc
<return> jump(temp0.d)

call(sub_18)
goto 1 @ 0x3de

int32_t sub_3f3()
push(0x10009be4)
call(sub_6f0)
ecx = pop
<return> jump(pop)

int32_t sub_3ff()
push(zx.d(0x14))
push(0x10008550)
call(sub_674), esp += 8
push([0x1000e45c].d)
esi = [0x100080a4].d
call(esi)
ecx = pop
[ebp - 0x1c].d = eax
if (eax != -1) then 9 @ 0x42e else 43 @ 0x422

push(zx.d(8))
call(sub_702)
ecx = pop
[ebp - 4].d = 0
push([0x1000e45c].d)
call(esi)
[ebp - 0x1c].d = eax
push([0x1000e458].d)
call(esi)
ecx = pop
ecx = pop
[ebp - 0x20].d = eax
eax = ebp - 0x20
push(eax)
eax = ebp - 0x1c
push(eax)
push([ebp + 8].d)
esi = [0x10008098].d
call(esi)
ecx = pop
push(eax)
call(sub_6fc)
[ebp - 0x24].d = eax
push([ebp - 0x1c].d)
call(esi)
[0x1000e45c].d = eax
push([ebp - 0x20].d)
call(esi)
esp = esp + 0x14
[0x1000e458].d = eax
[ebp - 4].d = -2
call(sub_49b)
eax = [ebp - 0x24].d
goto 47 @ 0x495

push([ebp + 8].d)
call([0x100080cc].d)
ecx = pop
goto 47 @ 0x495

call(sub_6b9)
<return> jump(pop)

int32_t sub_49b()
push(zx.d(8))
call(sub_6f6)
ecx = pop
<return> jump(pop)

int32_t sub_4a4(int32_t arg1)
push([esp + 4 {arg1}].d)
call(sub_3ff)
temp0.d = eax
eax = neg.d(eax)
flag:c = temp0.d != 0
eax = sbb.d(eax, eax, flag:c)
eax = neg.d(eax)
ecx = pop
eax = eax - 1
<return> jump(pop)

void sub_4b6()
push(esi)
push(edi)
eax = 0x1000851c
edi = 0x1000851c
cond:0 = eax u>= edi
esi = eax
if (cond:0) then 7 @ 0x4d7 else 10 @ 0x4c8

edi = pop
esi = pop
<return> jump(pop)

eax = [esi].d
if (eax == 0) then 12 @ 0x4d0 else 14 @ 0x4ce

esi = esi + 4
if (esi u< edi) then 10 @ 0x4c8 else 7 @ 0x4d7

call(eax)
goto 12 @ 0x4d0

void sub_4da()
push(esi)
push(edi)
eax = 0x10008524
edi = 0x10008524
cond:0 = eax u>= edi
esi = eax
if (cond:0) then 7 @ 0x4fb else 10 @ 0x4ec

edi = pop
esi = pop
<return> jump(pop)

eax = [esi].d
if (eax == 0) then 12 @ 0x4f4 else 14 @ 0x4f2

esi = esi + 4
if (esi u< edi) then 10 @ 0x4ec else 7 @ 0x4fb

call(eax)
goto 12 @ 0x4f4

int32_t sub_500(int16_t* arg1)
ecx = [esp + 4 {arg1}].d
if ([ecx].w == 0x5a4d) then 2 @ 0x50e else 5 @ 0x50b

eax = [ecx + 0x3c].d
eax = eax + ecx
if ([eax].d != 0x4550) then 5 @ 0x50b else 7 @ 0x51b

eax = 0
<return> jump(pop)

ecx = 0
cl = [eax + 0x18].w == 0x10b
eax = ecx
<return> jump(pop)

void* sub_530(void* arg1, int32_t arg2)
eax = [esp + 4 {arg1}].d
ecx = [eax + 0x3c].d
ecx = ecx + eax
eax = zx.d([ecx + 0x14].w)
push(ebx)
push(esi)
esi = zx.d([ecx + 6].w)
edx = 0
cond:0 = esi u<= 0
push(edi)
eax = eax + ecx + 0x18
if (cond:0) then 12 @ 0x56c else 14 @ 0x54e

eax = 0
goto 16 @ 0x56e

edi = [esp + 0x14 {arg2}].d
goto 20 @ 0x552

edi = pop
esi = pop
ebx = pop
<return> jump(pop)

ecx = [eax + 0xc].d
if (edi u< ecx) then 22 @ 0x562 else 25 @ 0x559

edx = edx + 1
eax = eax + 0x28
if (edx u< esi) then 20 @ 0x552 else 12 @ 0x56c

ebx = [eax + 8].d
ebx = ebx + ecx
if (edi u< ebx) then 16 @ 0x56e else 22 @ 0x562

int32_t sub_580(int32_t arg1)
push(ebp)
ebp = esp {__saved_ebp}
push(zx.d(-2))
push(0x10008570)
push(0x100016cd)
eax = [fsbase].d
push(eax)
esp = esp - 8
push(ebx)
push(esi)
push(edi)
eax = [0x10009000].d
[ebp - 8 {var_c_1}].d = [ebp - 8 {var_c}].d ^ eax
eax = eax ^ ebp
push(eax)
eax = ebp - 0x10 {var_14}
[fsbase].d = eax {var_14}
[ebp - 0x18 {var_1c}].d = esp {var_2c}
[ebp - 4 {var_8_1}].d = 0
push(0x10000000)
call(sub_500)
esp = esp + 4
if (eax == 0) then 23 @ 0x620 else 34 @ 0x5cb

[ebp - 4 {var_8_3}].d = -2
eax = 0
ecx = [ebp - 0x10 {var_14}].d
[fsbase].d = ecx
ecx = pop
edi = pop
esi = pop
ebx = pop
esp = ebp
ebp = pop
<return> jump(pop)

eax = [ebp + 8 {arg1}].d
eax = eax - 0x10000000
push(eax)
push(0x10000000)
call(sub_530)
esp = esp + 8
if (eax == 0) then 23 @ 0x620 else 41 @ 0x5e5

eax = [eax + 0x24].d
eax = eax u>> 0x1f
eax = not.d(eax)
eax = eax & 1
[ebp - 4 {var_8_2}].d = -2
ecx = [ebp - 0x10 {var_14}].d
[fsbase].d = ecx
ecx = pop
edi = pop
esi = pop
ebx = pop
esp = ebp
ebp = pop
<return> jump(pop)

int32_t sub_609(void* arg1 @ ebp)
eax = [ebp - 0x14].d
ecx = [eax].d
eax = [ecx].d
edx = 0
dl = eax == -0x3ffffffb
eax = edx
<return> jump(pop)

int32_t sub_63c()
jump([0x100080a8].d)

int32_t sub_642()
jump([0x100080ac].d)

int32_t sub_648()
jump([0x100080b0].d)

int32_t sub_64e()
jump([0x100080b8].d)

int32_t __stdcall sub_654(int32_t arg1, int32_t arg2)
if ([esp + 8 {arg2}].d != 1) then 1 @ 0x66e else 6 @ 0x662

eax = 0
eax = eax + 1
temp0.d = pop
esp = esp + 0xc
<return> jump(temp0.d)

if ([0x1000813c].d != 0) then 1 @ 0x66e else 7 @ 0x664

push([esp + 4 {arg1}].d)
call([0x10008004].d), esp += 4
goto 1 @ 0x66e

void* sub_674(int32_t arg1 @ esi, int32_t arg2 @ edi, void* arg3)
push(0x100016cd)
push([fsbase].d)
eax = [esp + 0x10 {arg_8}].d
[esp + 0x10 {arg_8}].d = ebp
ebp = esp + 0x10 {arg_8}
esp = esp - eax
push(ebx)
push(esi)
push(edi)
eax = [0x10009000].d
[ebp - 4 {arg3}].d = [ebp - 4 {arg3}].d ^ eax
eax = eax ^ ebp
push(eax)
[ebp - 0x18 {var_10}].d = esp
push([ebp - 8 {__return_addr}].d)
eax = [ebp - 4 {arg3}].d
[ebp - 4 {arg3}].d = -2
[ebp - 8 {__return_addr}].d = eax
eax = ebp - 0x10 {var_8}
[fsbase].d = eax {var_8}
<return> jump(pop)

int32_t sub_6b9(int32_t* arg1 @ ebp, int32_t arg2, int32_t arg3, int32_t arg4)
ecx = [ebp - 0x10].d
[fsbase].d = ecx
ecx = pop
edi = pop
edi = pop
esi = pop
ebx = pop
esp = ebp
ebp = pop
push(ecx)
<return> jump(pop)

int32_t sub_6cd(int32_t arg1, int32_t arg2, int32_t arg3, int32_t arg4)
push([esp + 0x10 {arg4}].d)
push([esp + 0x10 {arg3}].d)
push([esp + 0x10 {arg2}].d)
push([esp + 0x10 {arg1}].d)
push(0x10001708)
push(0x10009000)
call(sub_718)
esp = esp + 0x18
<return> jump(pop)

int32_t sub_6f0()
jump([0x100080bc].d)

int32_t sub_6f6()
jump([0x100080c0].d)

int32_t sub_6fc()
jump([0x100080c4].d)

int32_t sub_702()
jump([0x100080c8].d)

int32_t sub_718()
jump([0x100080d0].d)

int32_t sub_822()
jump([0x100080d4].d)

int32_t __convention("regparm") sub_880(int32_t arg1, int32_t* arg2, int32_t arg3, int32_t* arg4)
eax = ecx
eax = neg.d(eax)
[edx].d = eax
eax = [esp + 4 {arg4}].d
eax = [eax].d
if (eax == 0) then 6 @ 0x895 else 8 @ 0x890

eax = 0
goto 10 @ 0x897

eax = [eax + 0xc].d
goto 10 @ 0x897

push(eax)
push(ecx)
push(0x100083fc)
edx = edx + 0xc
push(zx.d(0x41))
push(edx)
call([0x10008090].d)
esp = esp + 0x14
eax = 1
<return> jump(pop)

void __convention("regparm") sub_8c0(char* arg1)
if ([eax].b != -0x17) then 1 @ 0x8cf else 2 @ 0x8c5

if ([eax].b != -1) then 5 @ 0x8dc else 6 @ 0x8d5

ecx = [eax + 1].d
eax = ecx + eax + 5
goto 1 @ 0x8cf

<return> jump(pop)

if ([eax + 1].b != 0x25) then 5 @ 0x8dc else 7 @ 0x8d7

edx = [eax + 2].d
eax = [edx].d
goto 5 @ 0x8dc

int32_t __convention("fastcall") sub_8e0(int32_t arg1)
esp = esp - 0x1c
eax = 0
[esp {s}].d = eax
[esp + 4].d = eax
[esp + 8 {var_14}].d = eax
[esp + 0xc {var_10}].d = eax
[esp + 0x10 {var_c}].d = eax
[esp + 0x14 {var_8}].d = eax
[esp + 0x18 {var_4}].d = eax
push(zx.d(0x1c))
eax = esp + 4 {s}
push(eax)
push(ecx)
call([0x10008014].d), esp += 0xc
temp0.d = eax
eax = neg.d(eax)
flag:c = temp0.d != 0
eax = sbb.d(eax, eax, flag:c)
eax = eax & [esp + 4 {var_18}].d
esp = esp + 0x1c
<return> jump(pop)

int32_t sub_920(int32_t arg1 @ esi, int32_t* arg2 @ edi)
eax = [edi].d
cond:0 = eax s< 0
push(ebx)
ebx = [0x10008090].d
if (cond:0) then 5 @ 0x940 else 14 @ 0x92d

ecx = edi + 0xc
push(ecx)
push(eax)
push(0x100083c0)
push(&data_1000)
push(esi)
call(ebx)
esp = esp + 0x14
goto 21 @ 0x955

push(eax)
push(0x10008398)
push(&data_1000)
push(esi)
call(ebx)
esp = esp + 0x10
goto 21 @ 0x955

push(zx.d(0))
push(esi)
call([0x1000808c].d)
edx = [edi + 4].d
cl = [edx].b
esp = esp + 8
if (cl == 0) then 28 @ 0x983 else 43 @ 0x96a

edx = [edi + 8].d
ecx = eax
push(edx)
ecx = ecx - esi
ecx = ecx s>> 1
ecx = ecx u>> 1
edx = &data_1000
push(0x100083f0)
edx = edx - ecx
push(edx)
push(eax)
call(ebx)
esp = esp + 0x10
ebx = pop
<return> jump(pop)

ebx = ebx
goto 45 @ 0x970

cx = sx.w(cl)
edx = edx + 1
[eax].w = cx
cl = [edx].b
eax = eax + 2
if (cl != 0) then 45 @ 0x970 else 28 @ 0x983

int32_t __convention("regparm") sub_9b0(int32_t* arg1, int32_t arg2)
push(esi)
push(edi)
esi = eax
call([0x1000803c].d)
ecx = [esp + 0xc {arg2}].d
push(zx.d(0))
push(zx.d(0x40))
eax = neg.d(eax)
edx = esi + 0xc
push(edx)
push(zx.d(0))
[esi].d = eax
eax = neg.d(eax)
push(eax)
push(zx.d(0))
push(0x1200)
[esi + 4].d = 0x10008430
[esi + 8].d = ecx
call([0x10008058].d), esp += 0x1c
[esi + 0x8c].w = 0
ecx = 0x24
edi = ebx
if (flag:d) then 23 else 25

edi, esi, ecx = __memcpy_u32(edi - (ecx << 2), esi - (ecx << 2), ecx << 2)
goto 27 @ 0x9f8

edi, esi, ecx = __memcpy_u32(edi, esi, ecx << 2)
goto 27 @ 0x9f8

edi = pop
eax = ebx
esi = pop
<return> jump(pop)

int32_t sub_a00(int32_t arg1) __noreturn
esp = esp - 0xb8
push(ebx)
push(ebp)
ebp = [esp + 0xc4 {arg1}].d
push(esi)
push(edi)
ebx = 0
push(0x8c)
esi = eax
eax = esp + 0x40 {var_8c}
push(ebx)
push(eax)
edi = ecx
[esp + 0x44 {var_90}].d = ebx
call(sub_6938)
noreturn
{ Does not return }

int32_t sub_a2b(int32_t arg1 @ ebp, void* arg2 @ esi, int16_t* arg3 @ edi, void* arg4, int32_t* arg5, int32_t arg6)
esp = esp + 0xc
if ([esp + 0xd4 {arg6}].d == ebx) then 2 @ 0xa4d else 7 @ 0xa37

edx = [esi + 0x11c].d
ecx = [esi + 0x110].d
[esp + 0x18 {i}].d = edx
[esp + 0x14 {arg_20}].d = ecx
goto 12 @ 0xa61

ecx = [esi + 0x110].d
eax = [esi + 0x11c].d
[esp + 0x18 {i}].d = ecx
[esp + 0x14 {arg_20}].d = eax
goto 12 @ 0xa61

esi = 0
if ([edi].w != 0x5a4d) then 14 @ 0xa71 else 16 @ 0xa6a

eax = edi
goto 19 @ 0xa79

eax = [edi + 0x3c].d
eax = eax + edi
goto 19 @ 0xa79

if ([eax].d == 0x4550) then 20 @ 0xa90 else 22 @ 0xa7b

eax = [eax + 0x80].d
if (eax == ebx) then 26 @ 0xa9f else 27 @ 0xa9a

push(zx.d(0xd))
call([0x10008040].d)
[esp + 0x40 {arg_48}].d = 0x112
goto 29 @ 0xb13

if (esi != ebx) then 31 @ 0xaab else 34 @ 0xaa1

esi = eax + edi
goto 26 @ 0xa9f

[esp + 0x38].d = ebx
goto 36 @ 0xb17

cond:0 = [esi + 0xc].d == ebx
eax = esi + 0xc
if (cond:0) then 38 @ 0xae4 else 39 @ 0xab3

[esp + 0x40 {arg_4c}].d = 0x112
goto 29 @ 0xb13

[esp + 0x3c].d = 0x10008430
goto 42 @ 0xb1f

if ([esi + 0xc].d != ebx) then 46 @ 0xaf0 else 49 @ 0xae6

ebx = [0x10008044].d
esp = esp
goto 51 @ 0xac0

edi = ebp
ecx = 0x24
esi = esp + 0x38
if (flag:d) then 58 else 60

esi = [esi + 0x10].d
esi = esi + edi
if ([esi].d == ebx) then 62 @ 0xb0b else 64 @ 0xaf9

[esp + 0x40 {arg_4c}].d = 0x11b
goto 29 @ 0xb13

eax = [eax].d
edx = [esp + 0xd0 {arg5}].d
eax = eax + edi
push(edx)
push(eax)
call(ebx), esp += 8
if (eax == 0) then 67 @ 0xadf else 69 @ 0xad3

edi, esi, ecx = __memcpy_u32(edi - (ecx << 2), esi - (ecx << 2), ecx << 2)
goto 73 @ 0xb2c

edi, esi, ecx = __memcpy_u32(edi, esi, ecx << 2)
goto 73 @ 0xb2c

[esp + 0x40 {arg_4c}].d = 0x146
goto 29 @ 0xb13

eax = [esp + 0x18 {i}].d
ecx = ecx
goto 80 @ 0xb02

ebx = 0
goto 38 @ 0xae4

esi = esi + 0x14
cond:1 = [esi + 0xc].d != 0
eax = esi + 0xc
if (cond:1) then 51 @ 0xac0 else 67 @ 0xadf

edi = pop
esi = pop
eax = ebp
ebp = pop
ebx = pop
esp = esp + 0xb8
<return> jump(pop)

if ([esi].d == eax) then 81 @ 0xb39 else 95 @ 0xb04

eax = 0
[esp + 0x20 {arg_2c}].d = eax
[esp + 0x24 {arg_30}].d = eax
[esp + 0x28 {arg4}].d = eax
[esp + 0x2c {arg_38}].d = eax
[esp + 0x30 {arg_3c}].d = eax
[esp + 0x34 {arg_40}].d = eax
push(zx.d(0x1c))
eax = esp + 0x20 {s}
push(eax)
push(esi)
[esp + 0x28 {s}].d = ebx
call([0x10008014].d), esp += 0xc
if (eax != 0) then 97 @ 0xbaa else 100 @ 0xb69

esi = esi + 4
if ([esi].d != ebx) then 80 @ 0xb02 else 62 @ 0xb0b

cond:2 = ([esp + 0x30 {arg_3c}].b & 0x40) != 0
edi = [0x10008050].d
if (cond:2) then 103 @ 0xbe9 else 121 @ 0xbb7

call([0x1000803c].d)
[esp + 0x40 {arg_4c}].d = 0x136
goto 130 @ 0xb77

ecx = [esp + 0x28 {arg4}].d
edx = [esp + 0x1c {s}].d
eax = [esp + 0x14 {arg_20}].d
push(ecx)
push(edx)
[esi].d = eax
call([0x10008054].d), esp += 8
push(eax)
call([0x10008038].d), esp += 4
ecx = [esp + 0x28 {arg4}].d
edx = [esp + 0x1c {s}].d
eax = esp + 0x30 {arg_3c}
push(eax)
push(zx.d(0x20))
push(ecx)
push(edx)
call(edi), esp += 0x10
if (eax != 0) then 135 @ 0xc30 else 138 @ 0xc1d

eax = [esp + 0x28 {arg4}].d
ecx = [esp + 0x1c {s}].d
edx = esp + 0x30 {arg_3c}
push(edx)
push(0x80)
push(eax)
push(ecx)
call(edi), esp += 0x10
if (eax != 0) then 103 @ 0xbe9 else 141 @ 0xbd1

push(ebx)
push(zx.d(0x40))
ecx = esp + 0x4c {arg_50}
push(ecx)
goto 148 @ 0xb7f

[esp + 0x38 {arg_44}].d = 1
[esp + 0x40 {arg_4c}].d = 0x143
goto 36 @ 0xb17

call([0x1000803c].d)
[esp + 0x40 {arg_4c}].d = 0x142
goto 130 @ 0xb77

call([0x1000803c].d)
push(ebx)
push(zx.d(0x40))
edx = esp + 0x4c {arg_50}
[esp + 0x48 {arg_4c}].d = 0x13d
push(edx)
goto 148 @ 0xb7f

eax = neg.d(eax)
push(ebx)
[esp + 0x48 {arg_44}].d = eax
eax = neg.d(eax)
push(eax)
push(ebx)
push(0x1200)
[esp + 0x58 {arg_48}].d = 0x10008430
call([0x10008058].d), esp += 0x10
[esp + 0xc4 {arg_c4}].w = bx
goto 42 @ 0xb1f

int32_t sub_c50(int32_t arg1) __noreturn
esp = esp - 0x14c
push(ebx)
push(ebp)
ebp = [esp + 0x160 {arg1}].d
push(esi)
push(edi)
edi = 0
push(0x8c)
eax = esp + 0x40 {var_120}
push(edi)
push(eax)
[esp + 0x44 {var_124}].d = edi
call(sub_6938)
noreturn
{ Does not return }

int32_t sub_c77(void* arg1 @ ebp, void* arg2 @ edi, int32_t arg3, void* arg4)
esp = esp + 0xc
cond:0 = [ebp].d == edi
[esp + 0x14 {arg_20}].d = edi
if (cond:0) then 4 @ 0xee2 else 8 @ 0xc87

eax = [esp + 0x14 {arg_20}].d
[esp + 0x38 {arg_44}].d = eax
[esp + 0x40 {arg_4c}].d = 0x18b
goto 9 @ 0xef2

goto 11 @ 0xc90

[esp + 0x3c {arg_48}].d = 0x10008430
goto 13 @ 0xefa

ebx = [ebp + 0x114].d
if (ebx == edi) then 18 @ 0xdf6 else 19 @ 0xc9e

esi = esp + 0x38
eax = [esp + 0x160].d
ecx = 0x24
edi = eax
if (flag:d) then 22 else 24

if ([ebp + 4].d != edi) then 26 @ 0xe8f else 36 @ 0xe02

cond:1 = [ebx].d == edi
[esp + 0x10 {arg_1c}].d = edi
if (cond:1) then 37 @ 0xece else 40 @ 0xcaa

edi, esi, ecx = __memcpy_u32(edi - (ecx << 2), esi - (ecx << 2), ecx << 2)
goto 42 @ 0xf0e

edi, esi, ecx = __memcpy_u32(edi, esi, ecx << 2)
goto 42 @ 0xf0e

edx = [esp + 0x16c {arg4}].d
push(edx)
eax = ebp + 8
push(eax)
ecx = esp + 0xd0 {arg_d4}
push(ecx)
ecx = [esp + 0x170 {arg3}].d
eax = ebp
call(sub_a00)
noreturn
{ Does not return }

if ([ebp + 0x110].d == edi) then 48 @ 0xe0c else 50 @ 0xe0a

[esp + 0x14 {arg_20}].d = [esp + 0x14 {arg_20}].d + 1
ebp = ebp + 0x120
if ([ebp].d != edi) then 11 @ 0xc90 else 4 @ 0xee2

ebx = ebx
goto 51 @ 0xcb0

edi = pop
esi = pop
ebp = pop
ebx = pop
esp = esp + 0x14c
<return> jump(pop)

call([0x100080ec].d)
goto 54 @ 0xe12

if ([ebp + 0x11c].d != edi) then 54 @ 0xe12 else 48 @ 0xe0c

cond:3 = [ebx + 4].d != edi
esi = ebx + 4
if (cond:3) then 56 @ 0xcce else 58 @ 0xcb8

ecx = [ebp + 0x110].d
if ([ecx].b != -0x17) then 64 @ 0xe27 else 65 @ 0xe1d

eax = [esi].d
if (eax != -1) then 68 @ 0xd16 else 77 @ 0xcd5

ecx = [ebx].d
push(esi)
push(ecx)
push(zx.d(2))
call([0x1000804c].d), esp += 0xc
if (eax != 0) then 56 @ 0xcce else 94 @ 0xcc8

if ([ecx].b != -1) then 96 @ 0xe34 else 124 @ 0xe2d

edx = [ecx + 1].d
ecx = ecx + edx + 5
goto 64 @ 0xe27

ecx = [ebp].d
esi = [0x10008048].d
push(ecx)
push(eax)
[ebp + 4].d = eax
call(esi), esp += 8
cond:2 = eax == edi
[ebp + 0x110].d = eax
if (cond:2) then 125 @ 0xf19 else 128 @ 0xd34

call([0x1000803c].d)
push(edi)
push(zx.d(0x40))
eax = neg.d(eax)
edx = esp + 0x4c {arg_50}
push(edx)
push(edi)
[esp + 0x48 {arg_44}].d = eax
eax = neg.d(eax)
push(eax)
push(edi)
push(0x1200)
[esp + 0x58 {arg_48}].d = 0x10008430
[esp + 0x5c {arg_4c}].d = 0x160
call([0x10008058].d), esp += 0x1c
[esp + 0xc4 {arg_d0}].w = di
goto 130 @ 0xdde

[esi].d = -1
goto 56 @ 0xcce

eax = 0
push(zx.d(0x1c))
edx = esp + 0x20 {arg_28}
push(edx)
push(ecx)
[ebp + 0x110].d = ecx
[esp + 0x28 {arg_28}].d = edi
[esp + 0x2c {s}].d = eax
[esp + 0x30 {arg_30}].d = eax
[esp + 0x34 {arg_34}].d = eax
[esp + 0x38 {arg_38}].d = eax
[esp + 0x3c {arg_3c}].d = eax
[esp + 0x40 {arg_40}].d = eax
call([0x10008014].d), esp += 0xc
temp0.d = eax
eax = neg.d(eax)
flag:c = temp0.d != 0
eax = sbb.d(eax, eax, flag:c)
eax = eax & [esp + 0x20 {s}].d
push(0x105)
ecx = ebp + 8
push(ecx)
push(eax)
[ebp + 4].d = eax
call([0x10008054].d), esp += 0xc
push(eax)
call(sub_0), esp += 4
if (eax == 0) then 133 @ 0xf84 else 26 @ 0xe8f

if ([ecx + 1].b != 0x25) then 96 @ 0xe34 else 136 @ 0xe2f

[esp + 0x38 {arg_44}].d = edi
[esp + 0x40 {arg_4c}].d = 0x165
goto 9 @ 0xef2

eax = [ebx + 8].d
if (eax != edi) then 139 @ 0xd4b else 146 @ 0xd41

[esp + 0x10 {arg_1c}].d = [esp + 0x10 {arg_1c}].d + 1
ebx = ebx + 0xc
if ([ebx].d != edi) then 51 @ 0xcb0 else 147 @ 0xdee

call([0x1000803c].d)
[esp + 0x40 {arg_4c}].d = 0x185
goto 148 @ 0xf35

eax = [ecx + 2].d
ecx = [eax].d
goto 96 @ 0xe34

edx = esp + 0x18 {arg_24}
push(edx)
push(eax)
push(zx.d(2))
[esp + 0x24 {arg_24}].d = edi
call([0x1000804c].d), esp += 0xc
if (eax == 0) then 153 @ 0xf27 else 156 @ 0xd65

if ([ebp + 0x11c].d != edi) then 164 @ 0xd81 else 174 @ 0xd43

goto 37 @ 0xece

push(edi)
push(zx.d(0x40))
edx = esp + 0x4c {arg_50}
push(edx)
goto 176 @ 0xf3d

call([0x1000803c].d)
[esp + 0x40 {arg_4c}].d = 0x16f
goto 148 @ 0xf35

eax = [ebp + 0x118].d
ecx = [esp + 0x18 {arg_24}].d
push(eax)
push(ecx)
call(esi), esp += 8
cond:4 = eax == edi
[ebp + 0x11c].d = eax
if (cond:4) then 187 @ 0xf65 else 164 @ 0xd81

edx = [esp + 0x16c {arg4}].d
eax = [ebx].d
push(edx)
push(eax)
ecx = esp + 0xd0 {arg_d4}
push(ecx)
ecx = [esp + 0x170 {arg3}].d
eax = ebp
call(sub_a00)
noreturn
{ Does not return }

call([0x100080ec].d)
goto 164 @ 0xd81

eax = neg.d(eax)
push(edi)
[esp + 0x48 {arg_44}].d = eax
eax = neg.d(eax)
push(eax)
push(edi)
push(0x1200)
[esp + 0x58 {arg_48}].d = 0x10008430
call([0x10008058].d), esp += 0x10
[esp + 0xc4 {arg_c4}].w = di
goto 13 @ 0xefa

call([0x1000803c].d)
push(edi)
push(zx.d(0x40))
ecx = esp + 0x4c {arg_50}
[esp + 0x48 {arg_4c}].d = 0x171
push(ecx)
goto 176 @ 0xf3d

int32_t sub_fa0() __noreturn
push(ebp)
ebp = esp {var_4}
push(zx.d(-1))
push(0x100085a0)
push(0x10007932)
eax = [fsbase].d
push(eax)
[fsbase].d = esp {var_14}
esp = esp - 8
eax = 0x4168
call(sub_6980)
push(ebx)
push(esi)
push(edi)
[ebp - 0x18 {var_1c}].d = esp {var_28}
edi = 0
[ebp - 0x38 {var_3c}].d = edi
[ebp - 0xec {var_f0}].d = edi
push(0x8c)
push(edi)
eax = ebp - 0xe8 {var_ec}
push(eax)
call(sub_6938)
noreturn
{ Does not return }

int32_t sub_fed(int32_t* arg1 @ ebp, int32_t arg2 @ edi)
esp = esp + 0xc
[ebp - 4].d = edi
[ebp - 0x34].d = edi
[ebp - 0x44].d = edi
if ([0x1000a3ec].d != edi) then 5 @ 0x1010 else 14 @ 0x1001

ecx = ebp - 0x44
push(ecx)
push(0x4000)
edx = ebp - 0x417c
push(edx)
call([0x10008054].d)
push(eax)
call(sub_6)
if (eax != 0) then 18 @ 0x1053 else 19 @ 0x1030

ecx = 0x10001fa0
call(sub_8e0)
[0x1000a3ec].d = eax
goto 5 @ 0x1010

if ([ebp + 0x10].d == edi) then 26 @ 0x10f4 else 28 @ 0x1059

push(0x1aa)
eax = ebp - 0xec
ebx = ebp - 0x17c
call(sub_9b0)
esp = esp + 4
esi = eax
goto 30 @ 0x1be4

ebx = ebp - 0x417c
goto 34 @ 0x10fa

eax = [ebp - 0x44].d
if ([0x1000a3f0].d != eax) then 26 @ 0x10f4 else 40 @ 0x1068

eax = [ebp + 8].d
ecx = 0x24
edi = eax
if (flag:d) then 43 else 45

[ebp - 0x34].d = ebx
esi = [ebp - 0x44].d
ecx = esi
ecx = ecx u>> 2
edx = ebp + (ecx << 2) - 0x417c
if (ebx u>= edx) then 47 @ 0x1b62 else 53 @ 0x1114

ecx = ebp - 0x417c
edx = 0x1000a400
goto 57 @ 0x1076

edi, esi, ecx = __memcpy_u32(edi - (ecx << 2), esi - (ecx << 2), ecx << 2)
goto 58 @ 0x1bf0

edi, esi, ecx = __memcpy_u32(edi, esi, ecx << 2)
goto 58 @ 0x1bf0

push(esi)
ecx = ebp - 0x417c
push(ecx)
push(0x1000a400)
call(sub_693e)
noreturn
{ Does not return }

edi = 0
[ebp - 0x3c].d = edi
[ebp - 0x3c].d = edi
if ([0x1000a39c].d == edi) then 67 @ 0x14c4 else 68 @ 0x1128

if (eax u< 4) then 74 @ 0x108b else 75 @ 0x1078

[ebp - 4].d = -1
ecx = [ebp - 0x10].d
[fsbase].d = ecx
edi = pop
esi = pop
ebx = pop
esp = ebp
ebp = pop
<return> jump(pop)

if (edi == 0) then 77 @ 0x14de else 85 @ 0x14ca

esi = ebx
ecx = 0xfeedbeef
eax = 0x9e3779b9
edx = eax
edi = 4
goto 86 @ 0x113b

if (eax == edi) then 92 @ 0x10ea else 94 @ 0x108d

esi = [edx].d
if (esi != [ecx].d) then 94 @ 0x108d else 99 @ 0x107e

push(0x12c)
push(zx.d(1))
push(zx.d(0))
call(sub_6160)
esp = esp + 0xc
esi = eax
[ebp - 0x3c].d = esi
if (esi != 0) then 103 @ 0x153b else 110 @ 0x14f8

if ([ebp + 0x10].d == 0) then 119 @ 0x1b10 else 121 @ 0x14d0

[ebp - 0x48].d = edi
[ebp - 0x24].d = edx
[ebp - 0x30].d = eax
[ebp - 0x2c].d = ecx
[ebp - 0x58].d = esi
if (edi u< 0xc) then 125 @ 0x127a else 129 @ 0x1153

eax = 0
goto 238 @ 0x10ee

ebx = zx.d([ecx].b)
esi = zx.d([edx].b)
temp0.d = esi
esi = esi - ebx
if (temp0.d != ebx) then 239 @ 0x10dc else 241 @ 0x1097

eax = eax - 4
ecx = ecx + 4
edx = edx + 4
goto 57 @ 0x1076

eax = [ebx].d
[esi].d = eax
[esi + 0x114].d = 0
[esi + 0x120].d = esi
[esi + 0x124].d = 4
edi = [0x1000a39c].d
if (edi != 0) then 245 @ 0x160c else 266 @ 0x1567

edx = edx | 0xffffffff
[ebp - 0xec].d = edx
[ebp - 0xe8].d = 0x10008430
[ebp - 0xe4].d = 0x1c0
ecx = 0x24
esi = ebp - 0xec
eax = [ebp + 8].d
edi = eax
if (flag:d) then 276 else 278

eax = [ebx].d
if (eax == [0x1000a3ec].d) then 280 @ 0x1b5a else 282 @ 0x1b1a

edx = [ebp - 0x38].d
[ebp - 0x38].d = edx
ebx = ebx + 4
goto 34 @ 0x10fa

ecx = ecx + 4
[ebp - 0x2c].d = ecx
edi = edi - 1
if (edi u> 0xa) then 295 @ 0x1310 else 376 @ 0x128c

edi = sx.d([esi + 3].b)
edi = edi << 8
ebx = sx.d([esi + 2].b)
edi = edi + ebx
edi = edi << 8
ebx = sx.d([esi + 1].b)
edi = edi + ebx
edi = edi << 8
ebx = sx.d([esi].b)
ebx = ebx + edx
edx = ebx + edi
[ebp - 0x24].d = edx
edi = sx.d([esi + 7].b)
edi = edi << 8
ebx = sx.d([esi + 6].b)
edi = edi + ebx
edi = edi << 8
ebx = sx.d([esi + 5].b)
edi = edi + ebx
edi = edi << 8
ebx = sx.d([esi + 4].b)
ebx = ebx + eax
eax = ebx + edi
[ebp - 0x30].d = eax
edi = sx.d([esi + 0xb].b)
edi = edi << 8
ebx = sx.d([esi + 0xa].b)
edi = edi + ebx
edi = edi << 8
ebx = sx.d([esi + 9].b)
edi = edi + ebx
edi = edi << 8
ebx = sx.d([esi + 8].b)
ebx = ebx + ecx
ecx = ebx + edi
[ebp - 0x2c].d = ecx
edx = edx - eax
[ebp - 0x24].d = edx
edx = edx - ecx
[ebp - 0x24].d = edx
edi = ecx
edi = edi u>> 0xd
edx = edx ^ edi
[ebp - 0x24].d = edx
eax = eax - ecx
[ebp - 0x30].d = eax
eax = eax - edx
[ebp - 0x30].d = eax
edi = edx
edi = edi << 8
eax = eax ^ edi
[ebp - 0x30].d = eax
ecx = ecx - edx
[ebp - 0x2c].d = ecx
ecx = ecx - eax
[ebp - 0x2c].d = ecx
edi = eax
edi = edi u>> 0xd
ecx = ecx ^ edi
[ebp - 0x2c].d = ecx
edx = edx - eax
[ebp - 0x24].d = edx
edx = edx - ecx
[ebp - 0x24].d = edx
edi = ecx
edi = edi u>> 0xc
edx = edx ^ edi
[ebp - 0x24].d = edx
eax = eax - ecx
[ebp - 0x30].d = eax
eax = eax - edx
[ebp - 0x30].d = eax
edi = edx
edi = edi << 0x10
eax = eax ^ edi
[ebp - 0x30].d = eax
ecx = ecx - edx
[ebp - 0x2c].d = ecx
ecx = ecx - eax
[ebp - 0x2c].d = ecx
edi = eax
edi = edi u>> 5
ecx = ecx ^ edi
[ebp - 0x2c].d = ecx
edx = edx - eax
[ebp - 0x24].d = edx
edx = edx - ecx
[ebp - 0x24].d = edx
edi = ecx
edi = edi u>> 3
edx = edx ^ edi
eax = eax - ecx
[ebp - 0x30].d = eax
eax = eax - edx
[ebp - 0x30].d = eax
edi = edx
edi = edi << 0xa
eax = eax ^ edi
ecx = ecx - edx
[ebp - 0x2c].d = ecx
ecx = ecx - eax
[ebp - 0x2c].d = ecx
edi = eax
edi = edi u>> 0xf
ecx = ecx ^ edi
esi = esi + 0xc
edi = [ebp - 0x48].d
edi = edi - 0xc
goto 86 @ 0x113b

if (eax == edi) then 377 @ 0x1b7d else 26 @ 0x10f4

eax = 1
if (esi s> edi) then 238 @ 0x10ee else 387 @ 0x10e5

eax = eax - 1
ecx = ecx + 1
edx = edx + 1
if (eax == edi) then 92 @ 0x10ea else 389 @ 0x10a4

edi = edi + 0x10c
ecx = [edi].d
edx = [ecx + 0x10].d
[edx + 8].d = esi
eax = [edi].d
ecx = [eax + 0x10].d
ecx = ecx - [eax + 0x14].d
[esi + 0x110].d = ecx
edx = esi + 0x10c
eax = [edi].d
[eax + 0x10].d = edx
eax = [edi].d
[eax + 0xc].d = [eax + 0xc].d + 1
ecx = [edi].d
[esi + 0x10c].d = ecx
edx = esi
[esi + 0x128].d = -0x1124111
eax = 0x9e3779b9
ecx = eax
edi = 4
goto 394 @ 0x1659

[0x1000a39c].d = esi
[esi + 0x110].d = edi
push(zx.d(0x2c))
push(edi)
call(sub_62e0)
esp = esp + 8
ebx = [0x1000a39c].d
edi = ebx + 0x10c
[edi].d = eax
if (eax != 0) then 399 @ 0x1598 else 404 @ 0x1590

edi, esi, ecx = __memcpy_u32(edi - (ecx << 2), esi - (ecx << 2), ecx << 2)
goto 407 @ 0x1527

edi, esi, ecx = __memcpy_u32(edi, esi, ecx << 2)
goto 407 @ 0x1527

ebx = ebx + 4
goto 34 @ 0x10fa

ecx = [ebp + 0x18].d
push(ecx)
edx = [ebp + 0x14].d
push(edx)
ecx = [ebp + 0x10].d
push(ecx)
edx = [ebp + 0xc].d
push(edx)
push(eax)
eax = ebp - 0x17c
push(eax)
call(sub_c50)
noreturn
{ Does not return }

edx = edx - eax
[ebp - 0x24].d = edx
edx = edx - ecx
[ebp - 0x24].d = edx
esi = ecx
esi = esi u>> 0xd
edx = edx ^ esi
[ebp - 0x24].d = edx
eax = eax - ecx
[ebp - 0x30].d = eax
eax = eax - edx
[ebp - 0x30].d = eax
esi = edx
esi = esi << 8
eax = eax ^ esi
[ebp - 0x30].d = eax
ecx = ecx - edx
[ebp - 0x2c].d = ecx
ecx = ecx - eax
[ebp - 0x2c].d = ecx
esi = eax
esi = esi u>> 0xd
ecx = ecx ^ esi
[ebp - 0x2c].d = ecx
edx = edx - eax
[ebp - 0x24].d = edx
edx = edx - ecx
[ebp - 0x24].d = edx
esi = ecx
esi = esi u>> 0xc
edx = edx ^ esi
[ebp - 0x24].d = edx
eax = eax - ecx
[ebp - 0x30].d = eax
eax = eax - edx
[ebp - 0x30].d = eax
esi = edx
esi = esi << 0x10
eax = eax ^ esi
[ebp - 0x30].d = eax
ecx = ecx - edx
[ebp - 0x2c].d = ecx
ecx = ecx - eax
[ebp - 0x2c].d = ecx
esi = eax
esi = esi u>> 5
ecx = ecx ^ esi
[ebp - 0x2c].d = ecx
edx = edx - eax
[ebp - 0x24].d = edx
edx = edx - ecx
[ebp - 0x24].d = edx
esi = ecx
esi = esi u>> 3
edx = edx ^ esi
[ebp - 0x24].d = edx
eax = eax - ecx
[ebp - 0x30].d = eax
eax = eax - edx
[ebp - 0x30].d = eax
esi = edx
esi = esi << 0xa
eax = eax ^ esi
[ebp - 0x30].d = eax
ecx = ecx - edx
[ebp - 0x2c].d = ecx
ecx = ecx - eax
[ebp - 0x2c].d = ecx
eax = eax u>> 0xf
ecx = ecx ^ eax
[ebp - 0x2c].d = ecx
esi = [0x1000a39c].d
edx = [esi + 0x10c].d
eax = [edx + 4].d
eax = eax - 1
eax = eax & ecx
eax = eax + (eax << 1)
eax = eax + eax
eax = eax + eax
ecx = [edx].d
if ([eax + ecx].d == 0) then 416 @ 0x13f1 else 418 @ 0x13e5

jump([(edi << 2) + 0x10002c08].d)

[ebp - 4].d = -1
edx = [ebp - 0x38].d
[ebp - 0xec].d = edx
[ebp - 0xe8].d = 0x10008430
[ebp - 0xe4].d = 0x1df
ecx = 0x24
esi = ebp - 0xec
eax = [ebp + 8].d
edi = eax
if (flag:d) then 423 else 425

eax = eax | 0xffffffff
goto 238 @ 0x10ee

ebx = zx.d([ecx].b)
esi = zx.d([edx].b)
temp1.d = esi
esi = esi - ebx
if (temp1.d != ebx) then 239 @ 0x10dc else 427 @ 0x10ae

[ebp - 0x4c].d = edi
[ebp - 0x28].d = ecx
[ebp - 0x20].d = eax
[ebp - 0x5c].d = edx
if (edi u< 0xc) then 431 @ 0x17c1 else 435 @ 0x166e

push(zx.d(0x2c))
push(zx.d(0))
push(eax)
call(sub_6938)
noreturn
{ Does not return }

push(zx.d(-1))
call([0x10008094].d), esp += 4
goto 399 @ 0x1598

[ebp - 4].d = edx
ecx = [ebp - 0x10].d
[fsbase].d = ecx
edi = pop
esi = pop
ebx = pop
esp = ebp
ebp = pop
<return> jump(pop)

eax = 0
goto 545 @ 0x13f3

ecx = edx
edx = [ecx].d
eax = [eax + edx].d
eax = eax - [ecx + 0x14].d
goto 545 @ 0x13f3

edi, esi, ecx = __memcpy_u32(edi - (ecx << 2), esi - (ecx << 2), ecx << 2)
goto 548 @ 0x1bb3

edi, esi, ecx = __memcpy_u32(edi, esi, ecx << 2)
goto 548 @ 0x1bb3

eax = eax - 1
ecx = ecx + 1
edx = edx + 1
if (eax == edi) then 92 @ 0x10ea else 556 @ 0x10bb

[esi + 0x128].d = [esi + 0x128].d + 4
ebx = [esi + 0x128].d
edi = edi - 1
if (edi u> 0xa) then 561 @ 0x1863 else 651 @ 0x17da

edi = sx.d([edx + 3].b)
edi = edi << 8
ebx = sx.d([edx + 2].b)
edi = edi + ebx
edi = edi << 8
ebx = sx.d([edx + 1].b)
edi = edi + ebx
edi = edi << 8
ebx = sx.d([edx].b)
ebx = ebx + ecx
ecx = ebx + edi
[ebp - 0x28].d = ecx
edi = sx.d([edx + 7].b)
edi = edi << 8
ebx = sx.d([edx + 6].b)
edi = edi + ebx
edi = edi << 8
ebx = sx.d([edx + 5].b)
edi = edi + ebx
edi = edi << 8
ebx = sx.d([edx + 4].b)
ebx = ebx + eax
eax = ebx + edi
[ebp - 0x20].d = eax
edi = sx.d([edx + 0xb].b)
edi = edi << 8
ebx = sx.d([edx + 0xa].b)
edi = edi + ebx
edi = edi << 8
ebx = sx.d([edx + 9].b)
edi = edi + ebx
edi = edi << 8
ebx = sx.d([edx + 8].b)
edi = edi + ebx
[esi + 0x128].d = [esi + 0x128].d + edi
edi = [esi + 0x128].d
ecx = ecx - eax
[ebp - 0x28].d = ecx
ecx = ecx - edi
[ebp - 0x28].d = ecx
ebx = edi
ebx = ebx u>> 0xd
ecx = ecx ^ ebx
[ebp - 0x28].d = ecx
eax = eax - edi
[ebp - 0x20].d = eax
eax = eax - ecx
[ebp - 0x20].d = eax
ebx = ecx
ebx = ebx << 8
eax = eax ^ ebx
[ebp - 0x20].d = eax
edi = edi - ecx
[esi + 0x128].d = edi
edi = edi - eax
[esi + 0x128].d = edi
ebx = eax
ebx = ebx u>> 0xd
ebx = ebx ^ edi
[esi + 0x128].d = ebx
ecx = ecx - eax
[ebp - 0x28].d = ecx
ecx = ecx - ebx
[ebp - 0x28].d = ecx
edi = ebx
edi = edi u>> 0xc
ecx = ecx ^ edi
[ebp - 0x28].d = ecx
eax = eax - ebx
[ebp - 0x20].d = eax
eax = eax - ecx
[ebp - 0x20].d = eax
edi = ecx
edi = edi << 0x10
eax = eax ^ edi
[ebp - 0x20].d = eax
[esi + 0x128].d = [esi + 0x128].d - ecx
edi = [esi + 0x128].d
edi = edi - eax
[esi + 0x128].d = edi
ebx = eax
ebx = ebx u>> 5
ebx = ebx ^ edi
[esi + 0x128].d = ebx
ecx = ecx - eax
[ebp - 0x28].d = ecx
ecx = ecx - ebx
[ebp - 0x28].d = ecx
edi = ebx
edi = edi u>> 3
ecx = ecx ^ edi
eax = eax - ebx
[ebp - 0x20].d = eax
eax = eax - ecx
[ebp - 0x20].d = eax
edi = ecx
edi = edi << 0xa
eax = eax ^ edi
[esi + 0x128].d = [esi + 0x128].d - ecx
edi = [esi + 0x128].d
edi = edi - eax
[esi + 0x128].d = edi
ebx = eax
ebx = ebx u>> 0xf
ebx = ebx ^ edi
[esi + 0x128].d = ebx
edx = edx + 0xc
edi = [ebp - 0x4c].d
edi = edi - 0xc
goto 394 @ 0x1659

edi = eax
[ebp - 0x3c].d = edi
if (edi == 0) then 652 @ 0x14bf else 654 @ 0x1407

ecx = [ebp - 0x10].d
[fsbase].d = ecx
edi = pop
esi = pop
ebx = pop
esp = ebp
ebp = pop
<return> jump(pop)

ebx = zx.d([ecx].b)
esi = zx.d([edx].b)
temp2.d = esi
esi = esi - ebx
if (temp2.d != ebx) then 239 @ 0x10dc else 655 @ 0x10c5

ecx = ecx - eax
[ebp - 0x28].d = ecx
ecx = ecx - [esi + 0x128].d
[ebp - 0x28].d = ecx
edx = [esi + 0x128].d
edx = edx u>> 0xd
ecx = ecx ^ edx
[ebp - 0x28].d = ecx
eax = eax - [esi + 0x128].d
[ebp - 0x20].d = eax
eax = eax - ecx
[ebp - 0x20].d = eax
edx = ecx
edx = edx << 8
eax = eax ^ edx
[ebp - 0x20].d = eax
[esi + 0x128].d = [esi + 0x128].d - ecx
edx = [esi + 0x128].d
edx = edx - eax
[esi + 0x128].d = edx
edi = eax
edi = edi u>> 0xd
edi = edi ^ edx
[esi + 0x128].d = edi
ecx = ecx - eax
[ebp - 0x28].d = ecx
ecx = ecx - edi
[ebp - 0x28].d = ecx
edx = edi
edx = edx u>> 0xc
ecx = ecx ^ edx
[ebp - 0x28].d = ecx
eax = eax - edi
[ebp - 0x20].d = eax
eax = eax - ecx
[ebp - 0x20].d = eax
edx = ecx
edx = edx << 0x10
eax = eax ^ edx
[ebp - 0x20].d = eax
[esi + 0x128].d = [esi + 0x128].d - ecx
edx = [esi + 0x128].d
edx = edx - eax
[esi + 0x128].d = edx
edi = eax
edi = edi u>> 5
edi = edi ^ edx
[esi + 0x128].d = edi
ecx = ecx - eax
[ebp - 0x28].d = ecx
ecx = ecx - edi
[ebp - 0x28].d = ecx
edx = edi
edx = edx u>> 3
ecx = ecx ^ edx
[ebp - 0x28].d = ecx
eax = eax - edi
[ebp - 0x20].d = eax
eax = eax - ecx
[ebp - 0x20].d = eax
edx = ecx
edx = edx << 0xa
eax = eax ^ edx
[ebp - 0x20].d = eax
[esi + 0x128].d = [esi + 0x128].d - ecx
ecx = [esi + 0x128].d
ecx = ecx - eax
[esi + 0x128].d = ecx
eax = eax u>> 0xf
eax = eax ^ ecx
[esi + 0x128].d = eax
edi = [0x1000a39c].d
edx = [edi + 0x10c].d
ecx = [edx + 4].d
ecx = ecx - 1
ecx = ecx & eax
eax = ecx + (ecx << 1)
eax = eax + eax
eax = eax + eax
ecx = [edx].d
ecx = ecx + eax + 4
[ecx].d = [ecx].d + 1
edx = [edi + 0x10c].d
ecx = [edx].d
edx = [eax + ecx].d
[esi + 0x11c].d = edx
[esi + 0x118].d = 0
ecx = [edi + 0x10c].d
edx = [ecx].d
if ([eax + edx].d == 0) then 659 @ 0x19a9 else 671 @ 0x1995

jump([(edi << 2) + 0x10002c34].d)

ebx = [ebp - 0x34].d
goto 67 @ 0x14c4

if ([edi + 0x124].d != 4) then 677 @ 0x14a3 else 679 @ 0x140d

eax = eax - 1
ecx = ecx + 1
edx = edx + 1
if (eax == edi) then 92 @ 0x10ea else 683 @ 0x10d2

esi = esi + 0x10c
ecx = [edi + 0x10c].d
edx = [ecx].d
[eax + edx].d = esi
ecx = [edi + 0x10c].d
edx = [ecx].d
ecx = edx + eax
eax = [ecx + 8].d
eax = eax + 1
eax = eax + (eax << 2)
eax = eax + eax
if ([ecx + 4].d u< eax) then 688 @ 0x1b0d else 690 @ 0x19d9

ecx = esi + 0x10c
edx = [edi + 0x10c].d
edx = [edx].d
edx = [edx + eax].d
[edx + 0xc].d = ecx
goto 659 @ 0x19a9

eax = [edi + 0x11c].d
if (eax == 0) then 416 @ 0x13f1 else 692 @ 0x14b1  {"@_^["}

eax = 4
ecx = [ebp - 0x34].d
edx = [edi + 0x120].d
goto 695 @ 0x1423

eax = zx.d([ecx].b)
esi = zx.d([edx].b)
temp3.d = esi
esi = esi - eax
if (temp3.d == eax) then 92 @ 0x10ea else 239 @ 0x10dc

ebx = [ebp - 0x34].d
goto 119 @ 0x1b10

eax = [esi].d
if ([eax + 0x24].d == 1) then 688 @ 0x1b0d else 696 @ 0x19e5

ecx = [esi + 0x10c].d
eax = eax - [ecx + 0x14].d
goto 545 @ 0x13f3

if (eax u< 4) then 708 @ 0x1438 else 709 @ 0x1425

eax = [eax + 4].d
ecx = eax + (eax << 1)
ecx = ecx + ecx
ecx = ecx + ecx
ecx = ecx + ecx
push(ecx)
push(zx.d(0))
call(sub_62e0)
esp = esp + 8
ebx = eax
[ebp - 0x50].d = ebx
if (ebx != 0) then 711 @ 0x1a0d else 722 @ 0x1a05

if (eax == 0) then 725 @ 0x1497 else 727 @ 0x143a

esi = [edx].d
if (esi != [ecx].d) then 727 @ 0x143a else 732 @ 0x142b

edx = [esi].d
eax = [edx + 4].d
eax = eax + (eax << 1)
eax = eax + eax
eax = eax + eax
eax = eax + eax
push(eax)
push(zx.d(0))
push(ebx)
call(sub_6938)
noreturn
{ Does not return }

push(zx.d(-1))
call([0x10008094].d), esp += 4
goto 711 @ 0x1a0d

eax = 0
goto 736 @ 0x149b

esi = zx.d([edx].b)
ebx = zx.d([ecx].b)
temp4.d = esi
esi = esi - ebx
if (temp4.d != ebx) then 737 @ 0x1489 else 739 @ 0x1444

eax = eax - 4
ecx = ecx + 4
edx = edx + 4
goto 695 @ 0x1423

if (eax == 0) then 652 @ 0x14bf else 743 @ 0x149d

eax = 1
if (esi s> 0) then 736 @ 0x149b else 745 @ 0x1492

eax = eax - 1
ecx = ecx + 1
edx = edx + 1
if (eax == 0) then 725 @ 0x1497 else 747 @ 0x1451

esi = [0x1000a39c].d
goto 677 @ 0x14a3

eax = eax | 0xffffffff
goto 736 @ 0x149b

esi = zx.d([edx].b)
ebx = zx.d([ecx].b)
temp5.d = esi
esi = esi - ebx
if (temp5.d != ebx) then 737 @ 0x1489 else 752 @ 0x145b

eax = eax - 1
ecx = ecx + 1
edx = edx + 1
if (eax == 0) then 725 @ 0x1497 else 756 @ 0x1468

esi = zx.d([edx].b)
ebx = zx.d([ecx].b)
temp6.d = esi
esi = esi - ebx
if (temp6.d != ebx) then 737 @ 0x1489 else 761 @ 0x1472

eax = eax - 1
ecx = ecx + 1
edx = edx + 1
if (eax == 0) then 725 @ 0x1497 else 765 @ 0x147f

esi = zx.d([edx].b)
eax = zx.d([ecx].b)
temp7.d = esi
esi = esi - eax
if (temp7.d == eax) then 725 @ 0x1497 else 737 @ 0x1489

int32_t sub_15a2(int32_t* arg1 @ edi) __noreturn
esp = esp + 0xc
ecx = [edi].d
[ecx + 0x10].d = edi
edx = [edi].d
[edx + 4].d = 0x20
eax = [edi].d
[eax + 8].d = 5
ecx = [edi].d
[ecx + 0x14].d = 0x10c
edi = ebx + 0x10c
push(0x180)
push(zx.d(0))
call(sub_62e0)
esp = esp + 8
edx = [edi {&data_10c}].d
[edx {0x9be00dff}].d = eax
eax = [edi {&data_10c}].d
if ([eax {0x9be00dff}].d != 0) then 18 @ 0x15ed else 25 @ 0x15e5

push(0x180)
push(zx.d(0))
ecx = eax
edx = [ecx].d
push(edx)
call(sub_6938)
noreturn
{ Does not return }

push(zx.d(-1))
call([0x10008094].d), esp += 4
goto 18 @ 0x15ed

int32_t sub_1a24(int32_t* arg1 @ ebp, int32_t* arg2 @ esi, int32_t arg3, int32_t arg4, int32_t arg5)
esp = esp + 0xc
eax = [esi].d
edx = [eax + 0xc].d
ecx = [eax + 8].d
ecx = ecx + 1
edi = edx
edi = edi u>> cl
ecx = [eax + 4].d
ecx = ecx + ecx - 1
ecx = ecx & edx
temp3.d = ecx
ecx = neg.d(ecx)
flag:c = temp3.d != 0
ecx = sbb.d(ecx, ecx, flag:c)
ecx = neg.d(ecx)
edi = edi + ecx
[eax + 0x18].d = edi
edx = [esi].d
eax = 0
[edx + 0x1c].d = eax
[ebp - 0x40].d = eax
goto 22 @ 0x1a54

eax = [esi].d
ecx = [ebp - 0x40].d
if (ecx u>= [eax + 4].d) then 25 @ 0x1ac6 else 43 @ 0x1a5e

ecx = [eax + 4].d
ecx = ecx + ecx
[eax + 4].d = ecx
eax = [esi].d
edi = 1
[eax + 8].d = [eax + 8].d + edi
edx = [esi].d
eax = [edx].d
push(eax)
push(zx.d(0))
call(sub_60a0)
esp = esp + 8
ecx = [esi].d
[ecx].d = ebx
eax = [esi].d
edx = [eax + 0xc].d
edx = edx u>> 1
if ([eax + 0x1c].d u<= edx) then 47 @ 0x1afe else 49 @ 0x1af7

edx = ecx + (ecx << 1)
eax = [eax].d
edi = [eax + (edx << 2)].d
goto 52 @ 0x1a68

ecx = 0
goto 53 @ 0x1b00

ecx = [eax + 0x20].d
ecx = ecx + edi
goto 53 @ 0x1b00

if (edi == 0) then 56 @ 0x1ac0 else 58 @ 0x1a6a

[eax + 0x20].d = ecx
esi = [esi].d
if ([esi + 0x20].d u<= edi) then 70 @ 0x1b0d else 72 @ 0x1b0a

[ebp - 0x40].d = [ebp - 0x40].d + 1
goto 22 @ 0x1a54

ecx = [edi + 0x10].d
[ebp - 0x54].d = ecx
edx = [esi].d
eax = [edx + 4].d
eax = eax + eax - 1
eax = eax & [edi + 0x1c].d
eax = eax + (eax << 1)
ecx = ebx + (eax << 2)
[ecx + 4].d = [ecx + 4].d + 1
edx = [ecx + 4].d
eax = [esi].d
if (edx u<= [eax + 0x18].d) then 74 @ 0x1aa4 else 79 @ 0x1a90

ebx = [ebp - 0x34].d
goto 91 @ 0x1b10

[esi + 0x24].d = edi
goto 70 @ 0x1b0d

[edi + 0xc].d = 0
edx = [ecx].d
[edi + 0x10].d = edx
eax = [ecx].d
if (eax == 0) then 93 @ 0x1ab9 else 96 @ 0x1ab6

[eax + 0x1c].d = [eax + 0x1c].d + 1
ebx = [esi].d
eax = [ecx + 4].d
edx = 0
temp2.d = [ebx + 0x18].d
temp0.d = divu.dp.d(edx:eax, temp2.d)
temp1.d = modu.dp.d(edx:eax, temp2.d)
eax = temp0.d
edx = temp1.d
[ecx + 8].d = eax
ebx = [ebp - 0x50].d
goto 74 @ 0x1aa4

eax = [ebx].d
if (eax == [0x1000a3ec].d) then 98 @ 0x1b5a else 100 @ 0x1b1a

[ecx].d = edi
edi = [ebp - 0x54].d
goto 52 @ 0x1a68

[eax + 0xc].d = edi
goto 93 @ 0x1ab9

ebx = ebx + 4
goto 113 @ 0x10fa

ecx = [ebp + 0x18].d
push(ecx)
edx = [ebp + 0x14].d
push(edx)
ecx = [ebp + 0x10].d
push(ecx)
edx = [ebp + 0xc].d
push(edx)
push(eax)
eax = ebp - 0x17c
push(eax)
call(sub_c50)
noreturn
{ Does not return }

[ebp - 0x34].d = ebx
esi = [ebp - 0x44].d
ecx = esi
ecx = ecx u>> 2
edx = ebp + (ecx << 2) - 0x417c
if (ebx u>= edx) then 119 @ 0x1b62 else 125 @ 0x1114

push(esi)
ecx = ebp - 0x417c
push(ecx)
push(0x1000a400)
call(sub_693e)
noreturn
{ Does not return }

edi = 0
[ebp - 0x3c].d = edi
[ebp - 0x3c].d = edi
if ([0x1000a39c].d == edi) then 129 @ 0x14c4 else 130 @ 0x1128

if (edi == 0) then 136 @ 0x14de else 144 @ 0x14ca

esi = ebx
ecx = 0xfeedbeef
eax = 0x9e3779b9
edx = eax
edi = 4
goto 145 @ 0x113b

push(0x12c)
push(zx.d(1))
push(zx.d(0))
call(sub_6160)
esp = esp + 0xc
esi = eax
[ebp - 0x3c].d = esi
if (esi != 0) then 151 @ 0x153b else 158 @ 0x14f8

if ([ebp + 0x10].d == 0) then 91 @ 0x1b10 else 167 @ 0x14d0

[ebp - 0x48].d = edi
[ebp - 0x24].d = edx
[ebp - 0x30].d = eax
[ebp - 0x2c].d = ecx
[ebp - 0x58].d = esi
if (edi u< 0xc) then 171 @ 0x127a else 175 @ 0x1153

eax = [ebx].d
[esi].d = eax
[esi + 0x114].d = 0
[esi + 0x120].d = esi
[esi + 0x124].d = 4
edi = [0x1000a39c].d
if (edi != 0) then 284 @ 0x160c else 305 @ 0x1567

edx = edx | 0xffffffff
[ebp - 0xec].d = edx
[ebp - 0xe8].d = 0x10008430
[ebp - 0xe4].d = 0x1c0
ecx = 0x24
esi = ebp - 0xec
eax = [ebp + 8].d
edi = eax
if (flag:d) then 315 else 317

edx = [ebp - 0x38].d
[ebp - 0x38].d = edx
ebx = ebx + 4
goto 113 @ 0x10fa

ecx = ecx + 4
[ebp - 0x2c].d = ecx
edi = edi - 1
if (edi u> 0xa) then 319 @ 0x1310 else 400 @ 0x128c

edi = sx.d([esi + 3].b)
edi = edi << 8
ebx = sx.d([esi + 2].b)
edi = edi + ebx
edi = edi << 8
ebx = sx.d([esi + 1].b)
edi = edi + ebx
edi = edi << 8
ebx = sx.d([esi].b)
ebx = ebx + edx
edx = ebx + edi
[ebp - 0x24].d = edx
edi = sx.d([esi + 7].b)
edi = edi << 8
ebx = sx.d([esi + 6].b)
edi = edi + ebx
edi = edi << 8
ebx = sx.d([esi + 5].b)
edi = edi + ebx
edi = edi << 8
ebx = sx.d([esi + 4].b)
ebx = ebx + eax
eax = ebx + edi
[ebp - 0x30].d = eax
edi = sx.d([esi + 0xb].b)
edi = edi << 8
ebx = sx.d([esi + 0xa].b)
edi = edi + ebx
edi = edi << 8
ebx = sx.d([esi + 9].b)
edi = edi + ebx
edi = edi << 8
ebx = sx.d([esi + 8].b)
ebx = ebx + ecx
ecx = ebx + edi
[ebp - 0x2c].d = ecx
edx = edx - eax
[ebp - 0x24].d = edx
edx = edx - ecx
[ebp - 0x24].d = edx
edi = ecx
edi = edi u>> 0xd
edx = edx ^ edi
[ebp - 0x24].d = edx
eax = eax - ecx
[ebp - 0x30].d = eax
eax = eax - edx
[ebp - 0x30].d = eax
edi = edx
edi = edi << 8
eax = eax ^ edi
[ebp - 0x30].d = eax
ecx = ecx - edx
[ebp - 0x2c].d = ecx
ecx = ecx - eax
[ebp - 0x2c].d = ecx
edi = eax
edi = edi u>> 0xd
ecx = ecx ^ edi
[ebp - 0x2c].d = ecx
edx = edx - eax
[ebp - 0x24].d = edx
edx = edx - ecx
[ebp - 0x24].d = edx
edi = ecx
edi = edi u>> 0xc
edx = edx ^ edi
[ebp - 0x24].d = edx
eax = eax - ecx
[ebp - 0x30].d = eax
eax = eax - edx
[ebp - 0x30].d = eax
edi = edx
edi = edi << 0x10
eax = eax ^ edi
[ebp - 0x30].d = eax
ecx = ecx - edx
[ebp - 0x2c].d = ecx
ecx = ecx - eax
[ebp - 0x2c].d = ecx
edi = eax
edi = edi u>> 5
ecx = ecx ^ edi
[ebp - 0x2c].d = ecx
edx = edx - eax
[ebp - 0x24].d = edx
edx = edx - ecx
[ebp - 0x24].d = edx
edi = ecx
edi = edi u>> 3
edx = edx ^ edi
eax = eax - ecx
[ebp - 0x30].d = eax
eax = eax - edx
[ebp - 0x30].d = eax
edi = edx
edi = edi << 0xa
eax = eax ^ edi
ecx = ecx - edx
[ebp - 0x2c].d = ecx
ecx = ecx - eax
[ebp - 0x2c].d = ecx
edi = eax
edi = edi u>> 0xf
ecx = ecx ^ edi
esi = esi + 0xc
edi = [ebp - 0x48].d
edi = edi - 0xc
goto 145 @ 0x113b

edi = edi + 0x10c
ecx = [edi].d
edx = [ecx + 0x10].d
[edx + 8].d = esi
eax = [edi].d
ecx = [eax + 0x10].d
ecx = ecx - [eax + 0x14].d
[esi + 0x110].d = ecx
edx = esi + 0x10c
eax = [edi].d
[eax + 0x10].d = edx
eax = [edi].d
[eax + 0xc].d = [eax + 0xc].d + 1
ecx = [edi].d
[esi + 0x10c].d = ecx
edx = esi
[esi + 0x128].d = -0x1124111
eax = 0x9e3779b9
ecx = eax
edi = 4
goto 401 @ 0x1659

[0x1000a39c].d = esi
[esi + 0x110].d = edi
push(zx.d(0x2c))
push(edi)
call(sub_62e0)
esp = esp + 8
ebx = [0x1000a39c].d
edi = ebx + 0x10c
[edi].d = eax
if (eax != 0) then 406 @ 0x1598 else 411 @ 0x1590

edi, esi, ecx = __memcpy_u32(edi - (ecx << 2), esi - (ecx << 2), ecx << 2)
goto 414 @ 0x1527

edi, esi, ecx = __memcpy_u32(edi, esi, ecx << 2)
goto 414 @ 0x1527

edx = edx - eax
[ebp - 0x24].d = edx
edx = edx - ecx
[ebp - 0x24].d = edx
esi = ecx
esi = esi u>> 0xd
edx = edx ^ esi
[ebp - 0x24].d = edx
eax = eax - ecx
[ebp - 0x30].d = eax
eax = eax - edx
[ebp - 0x30].d = eax
esi = edx
esi = esi << 8
eax = eax ^ esi
[ebp - 0x30].d = eax
ecx = ecx - edx
[ebp - 0x2c].d = ecx
ecx = ecx - eax
[ebp - 0x2c].d = ecx
esi = eax
esi = esi u>> 0xd
ecx = ecx ^ esi
[ebp - 0x2c].d = ecx
edx = edx - eax
[ebp - 0x24].d = edx
edx = edx - ecx
[ebp - 0x24].d = edx
esi = ecx
esi = esi u>> 0xc
edx = edx ^ esi
[ebp - 0x24].d = edx
eax = eax - ecx
[ebp - 0x30].d = eax
eax = eax - edx
[ebp - 0x30].d = eax
esi = edx
esi = esi << 0x10
eax = eax ^ esi
[ebp - 0x30].d = eax
ecx = ecx - edx
[ebp - 0x2c].d = ecx
ecx = ecx - eax
[ebp - 0x2c].d = ecx
esi = eax
esi = esi u>> 5
ecx = ecx ^ esi
[ebp - 0x2c].d = ecx
edx = edx - eax
[ebp - 0x24].d = edx
edx = edx - ecx
[ebp - 0x24].d = edx
esi = ecx
esi = esi u>> 3
edx = edx ^ esi
[ebp - 0x24].d = edx
eax = eax - ecx
[ebp - 0x30].d = eax
eax = eax - edx
[ebp - 0x30].d = eax
esi = edx
esi = esi << 0xa
eax = eax ^ esi
[ebp - 0x30].d = eax
ecx = ecx - edx
[ebp - 0x2c].d = ecx
ecx = ecx - eax
[ebp - 0x2c].d = ecx
eax = eax u>> 0xf
ecx = ecx ^ eax
[ebp - 0x2c].d = ecx
esi = [0x1000a39c].d
edx = [esi + 0x10c].d
eax = [edx + 4].d
eax = eax - 1
eax = eax & ecx
eax = eax + (eax << 1)
eax = eax + eax
eax = eax + eax
ecx = [edx].d
if ([eax + ecx].d == 0) then 423 @ 0x13f1 else 425 @ 0x13e5

jump([(edi << 2) + 0x10002c08].d)

[ebp - 0x4c].d = edi
[ebp - 0x28].d = ecx
[ebp - 0x20].d = eax
[ebp - 0x5c].d = edx
if (edi u< 0xc) then 430 @ 0x17c1 else 434 @ 0x166e

push(zx.d(0x2c))
push(zx.d(0))
push(eax)
call(sub_6938)
noreturn
{ Does not return }

push(zx.d(-1))
call([0x10008094].d), esp += 4
goto 406 @ 0x1598

[ebp - 4].d = edx
ecx = [ebp - 0x10].d
[fsbase].d = ecx
edi = pop
esi = pop
ebx = pop
esp = ebp
ebp = pop
<return> jump(pop)

eax = 0
goto 544 @ 0x13f3

ecx = edx
edx = [ecx].d
eax = [eax + edx].d
eax = eax - [ecx + 0x14].d
goto 544 @ 0x13f3

[esi + 0x128].d = [esi + 0x128].d + 4
ebx = [esi + 0x128].d
edi = edi - 1
if (edi u> 0xa) then 547 @ 0x1863 else 637 @ 0x17da

edi = sx.d([edx + 3].b)
edi = edi << 8
ebx = sx.d([edx + 2].b)
edi = edi + ebx
edi = edi << 8
ebx = sx.d([edx + 1].b)
edi = edi + ebx
edi = edi << 8
ebx = sx.d([edx].b)
ebx = ebx + ecx
ecx = ebx + edi
[ebp - 0x28].d = ecx
edi = sx.d([edx + 7].b)
edi = edi << 8
ebx = sx.d([edx + 6].b)
edi = edi + ebx
edi = edi << 8
ebx = sx.d([edx + 5].b)
edi = edi + ebx
edi = edi << 8
ebx = sx.d([edx + 4].b)
ebx = ebx + eax
eax = ebx + edi
[ebp - 0x20].d = eax
edi = sx.d([edx + 0xb].b)
edi = edi << 8
ebx = sx.d([edx + 0xa].b)
edi = edi + ebx
edi = edi << 8
ebx = sx.d([edx + 9].b)
edi = edi + ebx
edi = edi << 8
ebx = sx.d([edx + 8].b)
edi = edi + ebx
[esi + 0x128].d = [esi + 0x128].d + edi
edi = [esi + 0x128].d
ecx = ecx - eax
[ebp - 0x28].d = ecx
ecx = ecx - edi
[ebp - 0x28].d = ecx
ebx = edi
ebx = ebx u>> 0xd
ecx = ecx ^ ebx
[ebp - 0x28].d = ecx
eax = eax - edi
[ebp - 0x20].d = eax
eax = eax - ecx
[ebp - 0x20].d = eax
ebx = ecx
ebx = ebx << 8
eax = eax ^ ebx
[ebp - 0x20].d = eax
edi = edi - ecx
[esi + 0x128].d = edi
edi = edi - eax
[esi + 0x128].d = edi
ebx = eax
ebx = ebx u>> 0xd
ebx = ebx ^ edi
[esi + 0x128].d = ebx
ecx = ecx - eax
[ebp - 0x28].d = ecx
ecx = ecx - ebx
[ebp - 0x28].d = ecx
edi = ebx
edi = edi u>> 0xc
ecx = ecx ^ edi
[ebp - 0x28].d = ecx
eax = eax - ebx
[ebp - 0x20].d = eax
eax = eax - ecx
[ebp - 0x20].d = eax
edi = ecx
edi = edi << 0x10
eax = eax ^ edi
[ebp - 0x20].d = eax
[esi + 0x128].d = [esi + 0x128].d - ecx
edi = [esi + 0x128].d
edi = edi - eax
[esi + 0x128].d = edi
ebx = eax
ebx = ebx u>> 5
ebx = ebx ^ edi
[esi + 0x128].d = ebx
ecx = ecx - eax
[ebp - 0x28].d = ecx
ecx = ecx - ebx
[ebp - 0x28].d = ecx
edi = ebx
edi = edi u>> 3
ecx = ecx ^ edi
eax = eax - ebx
[ebp - 0x20].d = eax
eax = eax - ecx
[ebp - 0x20].d = eax
edi = ecx
edi = edi << 0xa
eax = eax ^ edi
[esi + 0x128].d = [esi + 0x128].d - ecx
edi = [esi + 0x128].d
edi = edi - eax
[esi + 0x128].d = edi
ebx = eax
ebx = ebx u>> 0xf
ebx = ebx ^ edi
[esi + 0x128].d = ebx
edx = edx + 0xc
edi = [ebp - 0x4c].d
edi = edi - 0xc
goto 401 @ 0x1659

edi = eax
[ebp - 0x3c].d = edi
if (edi == 0) then 638 @ 0x14bf else 640 @ 0x1407

ecx = ecx - eax
[ebp - 0x28].d = ecx
ecx = ecx - [esi + 0x128].d
[ebp - 0x28].d = ecx
edx = [esi + 0x128].d
edx = edx u>> 0xd
ecx = ecx ^ edx
[ebp - 0x28].d = ecx
eax = eax - [esi + 0x128].d
[ebp - 0x20].d = eax
eax = eax - ecx
[ebp - 0x20].d = eax
edx = ecx
edx = edx << 8
eax = eax ^ edx
[ebp - 0x20].d = eax
[esi + 0x128].d = [esi + 0x128].d - ecx
edx = [esi + 0x128].d
edx = edx - eax
[esi + 0x128].d = edx
edi = eax
edi = edi u>> 0xd
edi = edi ^ edx
[esi + 0x128].d = edi
ecx = ecx - eax
[ebp - 0x28].d = ecx
ecx = ecx - edi
[ebp - 0x28].d = ecx
edx = edi
edx = edx u>> 0xc
ecx = ecx ^ edx
[ebp - 0x28].d = ecx
eax = eax - edi
[ebp - 0x20].d = eax
eax = eax - ecx
[ebp - 0x20].d = eax
edx = ecx
edx = edx << 0x10
eax = eax ^ edx
[ebp - 0x20].d = eax
[esi + 0x128].d = [esi + 0x128].d - ecx
edx = [esi + 0x128].d
edx = edx - eax
[esi + 0x128].d = edx
edi = eax
edi = edi u>> 5
edi = edi ^ edx
[esi + 0x128].d = edi
ecx = ecx - eax
[ebp - 0x28].d = ecx
ecx = ecx - edi
[ebp - 0x28].d = ecx
edx = edi
edx = edx u>> 3
ecx = ecx ^ edx
[ebp - 0x28].d = ecx
eax = eax - edi
[ebp - 0x20].d = eax
eax = eax - ecx
[ebp - 0x20].d = eax
edx = ecx
edx = edx << 0xa
eax = eax ^ edx
[ebp - 0x20].d = eax
[esi + 0x128].d = [esi + 0x128].d - ecx
ecx = [esi + 0x128].d
ecx = ecx - eax
[esi + 0x128].d = ecx
eax = eax u>> 0xf
eax = eax ^ ecx
[esi + 0x128].d = eax
edi = [0x1000a39c].d
edx = [edi + 0x10c].d
ecx = [edx + 4].d
ecx = ecx - 1
ecx = ecx & eax
eax = ecx + (ecx << 1)
eax = eax + eax
eax = eax + eax
ecx = [edx].d
ecx = ecx + eax + 4
[ecx].d = [ecx].d + 1
edx = [edi + 0x10c].d
ecx = [edx].d
edx = [eax + ecx].d
[esi + 0x11c].d = edx
[esi + 0x118].d = 0
ecx = [edi + 0x10c].d
edx = [ecx].d
if ([eax + edx].d == 0) then 641 @ 0x19a9 else 653 @ 0x1995

jump([(edi << 2) + 0x10002c34].d)

ebx = [ebp - 0x34].d
goto 129 @ 0x14c4

if ([edi + 0x124].d != 4) then 659 @ 0x14a3 else 661 @ 0x140d

esi = esi + 0x10c
ecx = [edi + 0x10c].d
edx = [ecx].d
[eax + edx].d = esi
ecx = [edi + 0x10c].d
edx = [ecx].d
ecx = edx + eax
eax = [ecx + 8].d
eax = eax + 1
eax = eax + (eax << 2)
eax = eax + eax
if ([ecx + 4].d u< eax) then 70 @ 0x1b0d else 665 @ 0x19d9

ecx = esi + 0x10c
edx = [edi + 0x10c].d
edx = [edx].d
edx = [edx + eax].d
[edx + 0xc].d = ecx
goto 641 @ 0x19a9

eax = [edi + 0x11c].d
if (eax == 0) then 423 @ 0x13f1 else 667 @ 0x14b1

eax = 4
ecx = [ebp - 0x34].d
edx = [edi + 0x120].d
goto 670 @ 0x1423

eax = [esi].d
if ([eax + 0x24].d == 1) then 70 @ 0x1b0d else 671 @ 0x19e5

ecx = [esi + 0x10c].d
eax = eax - [ecx + 0x14].d
goto 544 @ 0x13f3

if (eax u< 4) then 683 @ 0x1438 else 684 @ 0x1425

eax = [eax + 4].d
ecx = eax + (eax << 1)
ecx = ecx + ecx
ecx = ecx + ecx
ecx = ecx + ecx
push(ecx)
push(zx.d(0))
call(sub_62e0)
esp = esp + 8
ebx = eax
[ebp - 0x50].d = ebx
if (ebx != 0) then 686 @ 0x1a0d else 697 @ 0x1a05

if (eax == 0) then 700 @ 0x1497 else 702 @ 0x143a

esi = [edx].d
if (esi != [ecx].d) then 702 @ 0x143a else 707 @ 0x142b

edx = [esi].d
eax = [edx + 4].d
eax = eax + (eax << 1)
eax = eax + eax
eax = eax + eax
eax = eax + eax
push(eax)
push(zx.d(0))
push(ebx)
call(sub_6938)
noreturn
{ Does not return }

push(zx.d(-1))
call([0x10008094].d), esp += 4
goto 686 @ 0x1a0d

eax = 0
goto 711 @ 0x149b

esi = zx.d([edx].b)
ebx = zx.d([ecx].b)
temp4.d = esi
esi = esi - ebx
if (temp4.d != ebx) then 712 @ 0x1489 else 714 @ 0x1444

eax = eax - 4
ecx = ecx + 4
edx = edx + 4
goto 670 @ 0x1423

if (eax == 0) then 638 @ 0x14bf else 718 @ 0x149d

eax = 1
if (esi s> 0) then 711 @ 0x149b else 720 @ 0x1492

eax = eax - 1
ecx = ecx + 1
edx = edx + 1
if (eax == 0) then 700 @ 0x1497 else 722 @ 0x1451

esi = [0x1000a39c].d
goto 659 @ 0x14a3

eax = eax | 0xffffffff
goto 711 @ 0x149b

esi = zx.d([edx].b)
ebx = zx.d([ecx].b)
temp5.d = esi
esi = esi - ebx
if (temp5.d != ebx) then 712 @ 0x1489 else 727 @ 0x145b

eax = eax - 1
ecx = ecx + 1
edx = edx + 1
if (eax == 0) then 700 @ 0x1497 else 731 @ 0x1468

esi = zx.d([edx].b)
ebx = zx.d([ecx].b)
temp6.d = esi
esi = esi - ebx
if (temp6.d != ebx) then 712 @ 0x1489 else 736 @ 0x1472

eax = eax - 1
ecx = ecx + 1
edx = edx + 1
if (eax == 0) then 700 @ 0x1497 else 740 @ 0x147f

esi = zx.d([edx].b)
eax = zx.d([ecx].b)
temp7.d = esi
esi = esi - eax
if (temp7.d == eax) then 700 @ 0x1497 else 712 @ 0x1489

int32_t sub_1b74(int32_t* arg1 @ ebp, int32_t arg2 @ esi, int32_t arg3, int32_t arg4, int32_t arg5)
esp = esp + 0xc
[0x1000a3f0].d = esi
[ebp - 4].d = -1
edx = [ebp - 0x38].d
[ebp - 0xec].d = edx
[ebp - 0xe8].d = 0x10008430
[ebp - 0xe4].d = 0x1df
ecx = 0x24
esi = ebp - 0xec
eax = [ebp + 8].d
edi = eax
if (flag:d) then 12 else 14

edi, esi, ecx = __memcpy_u32(edi - (ecx << 2), esi - (ecx << 2), ecx << 2)
goto 16 @ 0x1bb3

edi, esi, ecx = __memcpy_u32(edi, esi, ecx << 2)
goto 16 @ 0x1bb3

ecx = [ebp - 0x10].d
[fsbase].d = ecx
edi = pop
esi = pop
ebx = pop
esp = ebp
ebp = pop
<return> jump(pop)

int32_t sub_1bc4(void* arg1 @ ebp)
eax = [ebp - 0x14].d
ecx = [eax].d
ecx = [ecx].d
push(eax)
edx = ebp - 0xec
call(sub_880)
esp = esp + 4
<return> jump(pop)

int32_t sub_1bdb(int32_t* arg1 @ ebp)
esp = [ebp - 0x18].d
esi = ebp - 0xec
eax = [ebp + 8].d
ecx = 0x24
edi = eax
if (flag:d) then 6 else 8

edi, esi, ecx = __memcpy_u32(edi - (ecx << 2), esi - (ecx << 2), ecx << 2)
goto 10 @ 0x1bf0

edi, esi, ecx = __memcpy_u32(edi, esi, ecx << 2)
goto 10 @ 0x1bf0

[ebp - 4].d = -1
ecx = [ebp - 0x10].d
[fsbase].d = ecx
edi = pop
esi = pop
ebx = pop
esp = ebp
ebp = pop
<return> jump(pop)

int32_t __convention("regparm") sub_1c59(char* arg1, int32_t arg2, int32_t arg3, char* arg4 @ esi, char* arg5 @ edi)
al, eflags = __daa(al, eflags)
temp0.b = [eax].b
[eax].b = [eax].b + dl
cond:0 = temp0.b == neg.b(dl)
cond:1 = temp0.b == neg.b(dl)
ecx = ecx - 1
if (cond:0 || ecx != 0) then 7 @ 0x1c85 else 8 @ 0x1c5e

if (cond:1) then 19 @ 0x1c9a else 24 @ 0x1c87

[eax].b = [eax].b + dl
push(ebx)
push(esi)
push(eax)
esi = edx
push(esi)
push(ecx)
call(sub_3d2), esp += 0xc
cond:2 = esi != 3
ebx = eax
if (cond:2) then 30 @ 0x1cb2 else 33 @ 0x1c73

push(edi)
push(zx.d(0))
call(sub_60a0)
esp = esp + 8
goto 37 @ 0x1ca5

push(eax)
call(sub_5c50)
eax = [esi + 4].d
esi = esi + 4
esp = esp + 4
if (eax != 0) then 24 @ 0x1c87 else 19 @ 0x1c9a

esi = pop
ebx = pop
<return> jump(pop)

push(edi)
call(sub_6740)
edi = eax
if (edi == 0) then 37 @ 0x1ca5 else 43 @ 0x1c7f

push(zx.d(0))
call(sub_5c50)
esp = esp + 4
eax = ebx
edi = pop
goto 30 @ 0x1cb2

eax = [edi].d
cond:1 = eax == 0
esi = edi
goto 7 @ 0x1c85

int32_t sub_1cc0() __noreturn
push(ebp)
ebp = esp {var_4}
esp = esp & 0xfffffff8
eax = 0x2120
call(sub_6980)
push(esi)
push(edi)
push(0x8c)
eax = esp + 0x10 {var_4}
push(zx.d(0))
push(eax)
[esp + 0x14 {var_8}].d = 0
call(sub_6938)
noreturn
{ Does not return }

int32_t sub_1ceb() __noreturn
esp = esp + 0xc
push(zx.d(0))
push(zx.d(0))
push(zx.d(0))
ecx = esp + 0xa4 {arg_a4}
push(0x10009098)
push(ecx)
call(sub_fa0)
noreturn
{ Does not return }

int32_t sub_1d60() __noreturn
push(ebp)
ebp = esp {var_4}
esp = esp & 0xfffffff8
eax = 0x2120
call(sub_6980)
push(esi)
push(edi)
push(0x8c)
eax = esp + 0x10 {var_4}
push(zx.d(0))
push(eax)
[esp + 0x14 {var_8}].d = 0
call(sub_6938)
noreturn
{ Does not return }

int32_t sub_1d8b() __noreturn
esp = esp + 0xc
push(0x1000a3f4)
push(0x1000a3f8)
push(zx.d(1))
ecx = esp + 0xa4 {arg_a4}
push(0x10009098)
push(ecx)
call(sub_fa0)
noreturn
{ Does not return }

int32_t sub_1e20(int32_t* arg1, int32_t* arg2)
eax = [esp + 4 {arg1}].d
if (eax == 0) then 2 @ 0x1e30 else 4 @ 0x1e28

eax = [esp + 8 {arg2}].d
if (eax == 0) then 7 @ 0x1e40 else 9 @ 0x1e38

ecx = [0x10009f24].d
[eax].d = ecx
goto 2 @ 0x1e30

eax = 0x10009f38
<return> jump(pop)

edx = [0x10009f1c].d
[eax].d = edx
goto 7 @ 0x1e40

int32_t __convention("regparm") sub_1e50(int32_t arg1)
push(ecx)
eax = eax u>> 4
eax, eflags = _bit_scan_reverse(eax)
[esp {var_4}].d = eax
ecx = pop
<return> jump(pop)

void* __convention("regparm") sub_1e60(int32_t arg1, void* arg2)
push(ebp)
ebp = esp {__saved_ebp}
push(zx.d(-1))
push(0x10008590)
push(0x10007932)
eax = [fsbase].d
push(eax)
[fsbase].d = esp {var_14}
esp = esp - 8
push(ebx)
push(esi)
push(edi)
[ebp - 0x18 {var_1c}].d = esp {__saved_edi}
if (edx == 0) then 14 @ 0x1f34 else 23 @ 0x1e8e

eax = 0
ecx = [ebp - 0x10 {var_14}].d
[fsbase].d = ecx
edi = pop
esi = pop
ebx = pop
esp = ebp
ebp = pop
<return> jump(pop)

[ebp - 4 {var_8_1}].d = 0
eax = [0x10009f18].d
edi = eax
if ((dl & 7) != 0) then 27 @ 0x1f2d else 29 @ 0x1ea7

[ebp - 4 {var_8_3}].d = -1
goto 14 @ 0x1f34

if (edx u< eax) then 27 @ 0x1f2d else 30 @ 0x1ead

ecx = [edx - 4].d
esi = ecx
esi = esi & 3
cond:0 = esi == 0
eax = 0
al = cond:0
if (eax != 0) then 37 @ 0x1ec9 else 38 @ 0x1ec4

if ((cl & 4) != 0) then 27 @ 0x1f2d else 39 @ 0x1ecb

if (esi == 1) then 27 @ 0x1f2d else 37 @ 0x1ec9

esi = ecx
esi = esi & 0xfffffff8
if (esi u> [0x10009f34].d) then 27 @ 0x1f2d else 42 @ 0x1eda

if (eax != 0) then 43 @ 0x1eed else 47 @ 0x1edc

ecx = ecx & 0xfffffff8
eax = [0x10009f1c].d
eax = eax ^ [ecx + edx - 8].d
if ((al & 7) != 0) then 27 @ 0x1f2d else 51 @ 0x1eff

eax = ecx
eax = eax & 0xfffffff8
eax = [eax + edx - 4].d
if ((al & 1) == 0) then 27 @ 0x1f2d else 52 @ 0x1eeb

if (eax u< edi) then 27 @ 0x1f2d else 53 @ 0x1f01

if ((al & 4) != 0) then 27 @ 0x1f2d else 43 @ 0x1eed

ecx = [0x10009f1c].d
if ([eax + 0x24].d != ecx) then 27 @ 0x1f2d else 55 @ 0x1f0c

[ebp - 4 {var_8_2}].d = -1
ecx = [ebp - 0x10 {var_14}].d
[fsbase].d = ecx
edi = pop
esi = pop
ebx = pop
esp = ebp
ebp = pop
<return> jump(pop)

int32_t sub_1f24() __pure
eax = 1
<return> jump(pop)

int32_t __convention("regparm") sub_1f50(void* arg1)
ecx = [0x10009f1c].d
push(esi)
esi = 0
if ([eax + 0x24].d != ecx) then 4 @ 0x1f66 else 8 @ 0x1f5e

call([0x100080ec].d)
eax = esi
esi = pop
<return> jump(pop)

eax = [eax + 0x1b0].d
esi = pop
<return> jump(pop)

void* sub_1f70(void* arg1)
esp = esp - 8
eax = [ebx + 4 {&data_4}].d
ecx = eax
ecx = neg.d(ecx)
ecx = ecx & eax
edx, eflags = _bit_scan_forward(ecx)
eax = edx
ecx = [ebx + (eax << 2) + 0x130].d
push(ebp)
ebp = [ecx + 4].d
[esp + 4 {var_8}].d = edx
edx = [esp + 0x10 {arg1}].d
ebp = ebp & 0xfffffff8
push(edi)
ebp = ebp - edx
goto 16 @ 0x1f9a

edi = ecx
esp = esp
goto 19 @ 0x1fa0

eax = [ecx + 0x10].d
if (eax == 0) then 21 @ 0x1fab else 23 @ 0x1fa7

ecx = [ecx + 0x14].d
goto 25 @ 0x1fb0

ecx = eax
goto 25 @ 0x1fb0

if (ecx == 0) then 26 @ 0x1fc2 else 28 @ 0x1fb2

ecx = [ebx + 0x10 {&data_10}].d
if (edi u< ecx) then 32 @ 0x2190 else 38 @ 0x1fcd

eax = [ecx + 4].d
eax = eax & 0xfffffff8
eax = eax - edx
if (eax u>= ebp) then 19 @ 0x1fa0 else 42 @ 0x1fbe

call([0x100080ec].d)
edi = pop
eax = 0
ebp = pop
esp = esp + 8
<return> jump(pop)

eax = edi + edx
cond:0 = edi u>= eax
[esp + 0xc {var_4_1}].d = eax
if (cond:0) then 32 @ 0x2190 else 44 @ 0x1fdc

ebp = eax
goto 16 @ 0x1f9a

eax = [edi + 0x18].d
push(esi)
esi = [edi + 0xc].d
cond:1 = esi == edi
[esp + 0xc {var_8_1}].d = eax
if (cond:1) then 50 @ 0x1ffa else 54 @ 0x1feb

esi = [edi + 0x14].d
cond:2 = esi != 0
ecx = edi + 0x14
if (cond:2) then 56 @ 0x2010 else 59 @ 0x2004

eax = [edi + 8].d
if (eax u< ecx) then 63 @ 0x2035 else 66 @ 0x1ff2

cond:3 = [esi + 0x14].d != 0
eax = esi + 0x14
if (cond:3) then 69 @ 0x2022 else 72 @ 0x2019

esi = [edi + 0x10].d
cond:4 = esi == 0
ecx = edi + 0x10
if (cond:4) then 75 @ 0x2044 else 76 @ 0x200e

call([0x100080ec].d)
edx = [esp + 0x18 {arg1}].d
goto 75 @ 0x2044

[eax + 0xc].d = esi
[esi + 8].d = eax
goto 75 @ 0x2044

esi = [eax].d
ecx = eax
goto 56 @ 0x2010

cond:5 = [esi + 0x10].d == 0
eax = esi + 0x10
if (cond:5) then 78 @ 0x202b else 69 @ 0x2022

if ([esp + 0xc {var_8_1}].d == 0) then 79 @ 0x20eb else 80 @ 0x204a

edi = edi
goto 56 @ 0x2010

if (ecx u< [ebx + 0x10 {&data_10}].d) then 63 @ 0x2035 else 84 @ 0x202d

if (ebp u>= 0x10) then 86 @ 0x2113 else 98 @ 0x20ed

ecx = [edi + 0x1c].d
cond:6 = edi != [ebx + (ecx << 2) + 0x130].d
eax = ebx + (ecx << 2) + 0x130
if (cond:6) then 113 @ 0x2074 else 115 @ 0x205d

[ecx].d = 0
goto 75 @ 0x2044

ecx = [0x10009f1c].d
eax = [esp + 0x10 {var_4_1}].d
edx = edx | 3
[edi + 4].d = edx
ecx = ecx ^ ebx
edx = ebp
[eax].d = ecx
edx = edx | 1
[eax + 4].d = edx
[eax + ebp].d = ebp
eax = [ebx + 8 {&data_8}].d
if (eax == 0) then 118 @ 0x217c else 127 @ 0x2139

ecx = edx + ebp
ebp = ebp + edi
eax = edx + ebp
edx = [0x10009f1c].d
ecx = ecx | 3
[edi + 4].d = ecx
[eax + 4].d = [eax + 4].d | 1
edx = edx ^ ebx
esi = pop
[eax].d = edx
eax = edi + 8
edi = pop
ebp = pop
esp = esp + 8
<return> jump(pop)

eax = [esp + 0xc {var_8_1}].d
if (eax u< [ebx + 0x10 {&data_10}].d) then 136 @ 0x208c else 140 @ 0x2080

cond:7 = esi != 0
[eax].d = esi
if (cond:7) then 141 @ 0x20a0 else 143 @ 0x2063

edx = [esp + 0x10 {var_4_1}].d
esi = pop
eax = edi + 8
edi = pop
[ebx + 8 {&data_8}].d = ebp
[ebx + 0x14 {&data_14}].d = edx
ebp = pop
esp = esp + 8
<return> jump(pop)

ecx = [ebx + 0x14 {&data_14}].d
eax = eax u>> 3
[esp + 0xc {var_8_1}].d = ecx
ecx = eax
edx = 1
edx = edx << cl
esi = ebx + (eax << 3) + 0x28
eax = [ebx {sub_0}].d
if ((edx & eax) != 0) then 149 @ 0x215c else 151 @ 0x2156

call([0x100080ec].d)
edx = [esp + 0x18 {arg1}].d
eax = [esp + 0xc {var_8_1}].d
goto 154 @ 0x209c

if ([eax + 0x10].d != edi) then 155 @ 0x2087 else 157 @ 0x2082

eax = [esp + 0xc {var_8_1}].d
goto 159 @ 0x20a7

ecx = [edi + 0x1c].d
eax = 1
eax = eax << cl
eax = not.d(eax)
[ebx + 4 {&data_4}].d = [ebx + 4 {&data_4}].d & eax
goto 79 @ 0x20eb

ecx = [esi + 8 {0x10008120}].d
if (ecx u>= [ebx + 0x10 {&data_10}].d) then 160 @ 0x216c else 166 @ 0x2164

eax = eax | edx
[ebx {sub_0}].d = eax
goto 168 @ 0x216a

if (esi == 0) then 79 @ 0x20eb else 170 @ 0x209e

[eax + 0x14].d = esi
goto 154 @ 0x209c

[eax + 0x10].d = esi
goto 154 @ 0x209c

if (esi u< [ebx + 0x10 {&data_10}].d) then 171 @ 0x20de else 174 @ 0x20a9

eax = [esp + 0xc {var_8_1}].d
[esi + 8 {0x10008120}].d = eax
[ecx + 0xc].d = eax
[eax + 8 {0x100080f0}].d = ecx
[eax + 0xc {0x100080f4}].d = esi
goto 118 @ 0x217c

call([0x100080ec].d)
goto 168 @ 0x216a

ecx = esi
goto 160 @ 0x216c

goto 159 @ 0x20a7

call([0x100080ec].d)
edx = [esp + 0x18 {arg1}].d
goto 79 @ 0x20eb

[esi + 0x18].d = eax
eax = [edi + 0x10].d
if (eax == 0) then 177 @ 0x20ca else 179 @ 0x20b6

eax = [edi + 0x14].d
if (eax == 0) then 79 @ 0x20eb else 180 @ 0x20d4

if (eax u< [ebx + 0x10 {&data_10}].d) then 181 @ 0x20c0 else 184 @ 0x20b8

if (eax u< [ebx + 0x10 {&data_10}].d) then 171 @ 0x20de else 187 @ 0x20d6

call([0x100080ec].d)
edx = [esp + 0x18 {arg1}].d
goto 177 @ 0x20ca

[esi + 0x10].d = eax
[eax + 0x18].d = esi
goto 177 @ 0x20ca

[esi + 0x14].d = eax
[eax + 0x18].d = esi
goto 79 @ 0x20eb

void* sub_21a0(int32_t* arg1, void* arg2)
esp = esp - 0xc
push(ebx)
push(ebp)
ebp = [esp + 0x1c {arg2}].d
push(esi)
ebx = ebp
esi = 0
eax = ebp
ebx = neg.d(ebx)
eax = eax u>> 8
cond:0 = eax != 0
push(edi)
[esp + 0x24 {arg2}].d = esi
if (cond:0) then 14 @ 0x21c5 else 15 @ 0x21bc

if (eax u<= 0xffff) then 17 @ 0x21ce else 25 @ 0x21c7

edi = 0
goto 27 @ 0x21e2

eax, eflags = _bit_scan_reverse(eax)
ecx = eax + 7
edx = ebp
edx = edx u>> cl
[esp + 0x10 {var_c_1}].d = eax
edx = edx & 1
edi = edx + (eax << 1)
goto 27 @ 0x21e2

edi = 0x1f
goto 27 @ 0x21e2

eax = [esp + 0x20 {arg1}].d
eax = [eax + (edi << 2) + 0x130].d
if (eax == 0) then 30 @ 0x2258 else 37 @ 0x21f4

edx = edx | 0xffffffff
ecx = edi
edx = edx << cl
ecx = [esp + 0x20 {arg1}].d
edx = edx + edx
edx = edx & [ecx + 4].d
if (edx == 0) then 38 @ 0x2286 else 39 @ 0x226a

if (edi != 0x1f) then 48 @ 0x21fa else 53 @ 0x21f6

if (eax == 0) then 55 @ 0x22b0 else 56 @ 0x2288

eax = edx
eax = neg.d(eax)
eax = eax & edx
ecx, eflags = _bit_scan_forward(eax)
eax = [esp + 0x20 {arg1}].d
edx = ecx
eax = [eax + (edx << 2) + 0x130].d
[esp + 0x14 {var_8_1}].d = ecx
goto 38 @ 0x2286

edx = edi
edx = edx u>> 1
ecx = 0x19
ecx = ecx - edx
goto 60 @ 0x2205

ecx = 0
goto 60 @ 0x2205

if (esi == 0) then 65 @ 0x25e9 else 72 @ 0x22b6

ecx = [eax + 4].d
ecx = ecx & 0xfffffff8
ecx = ecx - ebp
if (ecx u>= ebx) then 76 @ 0x2298 else 78 @ 0x2294

edx = ebp
edx = edx << cl
[esp + 0x10 {i_2}].d = esi
ecx = ecx
goto 81 @ 0x2210

edi = pop
esi = pop
ebp = pop
eax = 0
ebx = pop
esp = esp + 0xc
<return> jump(pop)

eax = [esp + 0x20 {arg1}].d
ecx = [eax + 8].d
ecx = ecx - ebp
if (ebx u>= ecx) then 65 @ 0x25e9 else 85 @ 0x22c7

ecx = [eax + 0x10].d
if (ecx == 0) then 87 @ 0x22a3 else 89 @ 0x229f

ebx = ecx
esi = eax
goto 76 @ 0x2298

ecx = [eax + 4].d
ecx = ecx & 0xfffffff8
ecx = ecx - ebp
if (ecx u>= ebx) then 91 @ 0x2228 else 97 @ 0x221c

edx = [eax + 0x10].d
if (esi u< edx) then 102 @ 0x25e3 else 104 @ 0x22d2

eax = [eax + 0x14].d
goto 106 @ 0x22a8

eax = ecx
goto 106 @ 0x22a8

ecx = [eax + 0x14].d
esi = edx
esi = esi u>> 0x1f
cond:1 = ecx == 0
eax = [eax + (esi << 2) + 0x10].d
if (cond:1) then 107 @ 0x2242 else 108 @ 0x223a

cond:2 = ecx == 0
esi = eax
[esp + 0x24 {arg2}].d = esi
ebx = ecx
if (cond:2) then 109 @ 0x2252 else 91 @ 0x2228

call([0x100080ec].d)
goto 65 @ 0x25e9

edi = esi + ebp
if (esi u>= edi) then 102 @ 0x25e3 else 110 @ 0x22dd

if (eax != 0) then 56 @ 0x2288 else 116 @ 0x22aa

if (eax == 0) then 118 @ 0x2248 else 121 @ 0x2244

if (ecx == eax) then 107 @ 0x2242 else 123 @ 0x223c

if (eax != 0) then 56 @ 0x2288 else 125 @ 0x2256

eax = [esp + 0x24 {arg2}].d
esi = [eax + 0xc].d
cond:3 = esi == eax
ecx = [eax + 0x18].d
[esp + 0x10 {var_c_2}].d = ecx
if (cond:3) then 126 @ 0x22fe else 131 @ 0x22ef

[esp + 0x24 {arg2}].d = esi
goto 55 @ 0x22b0

eax = [esp + 0x10 {i_2}].d
esi = [esp + 0x24 {arg2}].d
goto 109 @ 0x2252

edx = edx + edx
goto 81 @ 0x2210

[esp + 0x10 {i_2}].d = ecx
goto 107 @ 0x2242

if (esi != 0) then 72 @ 0x22b6 else 30 @ 0x2258

eax = [esp + 0x24 {arg2}].d
esi = [eax + 0x14].d
cond:4 = esi != 0
ecx = eax + 0x14
if (cond:4) then 133 @ 0x2316 else 136 @ 0x230c

eax = [eax + 8].d
if (eax u< edx) then 140 @ 0x233a else 142 @ 0x22f6

cond:5 = [esi + 0x14].d != 0
eax = esi + 0x14
if (cond:5) then 145 @ 0x2328 else 148 @ 0x231f

esi = [eax + 0x10].d
cond:6 = esi == 0
ecx = eax + 0x10
if (cond:6) then 151 @ 0x2345 else 133 @ 0x2316

call([0x100080ec].d)
goto 151 @ 0x2345

[eax + 0xc].d = esi
[esi + 8].d = eax
goto 151 @ 0x2345

esi = [eax].d
ecx = eax
goto 133 @ 0x2316

cond:7 = [esi + 0x10].d == 0
eax = esi + 0x10
if (cond:7) then 152 @ 0x2330 else 145 @ 0x2328

if ([esp + 0x10 {var_c_2}].d == 0) then 153 @ 0x23f2 else 154 @ 0x234b

if (ecx u< edx) then 140 @ 0x233a else 160 @ 0x2332

if (ebx u>= 0x10) then 162 @ 0x2426 else 176 @ 0x23f4

ecx = [esp + 0x24 {arg2}].d
eax = [ecx + 0x1c].d
edx = [esp + 0x20 {arg1}].d
cond:8 = ecx != [edx + (eax << 2) + 0x130].d
eax = edx + (eax << 2) + 0x130
if (cond:8) then 194 @ 0x237d else 196 @ 0x2366

[ecx].d = 0
goto 151 @ 0x2345

eax = [0x10009f1c].d
eax = eax ^ [esp + 0x20 {arg1}].d
edx = [esp + 0x24 {arg2}].d
ebp = ebp | 3
[edx + 4].d = ebp
ecx = ebx
ecx = ecx | 1
[edi].d = eax
[edi + 4].d = ecx
ecx = ebx
ecx = ecx u>> 3
cond:9 = ecx u>= 0x20
[edi + ebx].d = ebx
if (cond:9) then 199 @ 0x24cc else 202 @ 0x2450

eax = [esp + 0x24 {arg2}].d
ecx = [0x10009f1c].d
ecx = ecx ^ [esp + 0x20 {arg1}].d
edx = ebx + ebp
ebx = ebx + eax
edx = edx | 3
[eax + 4].d = edx
[ebx + ebp + 4].d = [ebx + ebp + 4].d | 1
eax = ebx + ebp
edi = pop
esi = pop
[eax].d = ecx
eax = [esp + 0x1c {arg2}].d
ebp = pop
eax = eax + 8
ebx = pop
esp = esp + 0xc
<return> jump(pop)

eax = [esp + 0x10 {var_c_2}].d
if (eax u< [edx + 0x10].d) then 209 @ 0x2395 else 211 @ 0x2389

cond:10 = esi != 0
[eax].d = esi
if (cond:10) then 212 @ 0x23aa else 213 @ 0x236c

eax = ebx
eax = eax u>> 8
if (eax != 0) then 219 @ 0x24dc else 220 @ 0x24d3

edx = [esp + 0x20 {arg1}].d
eax = 1
eax = eax << cl
esi = edx + (ecx << 3) + 0x28
ecx = [edx].d
ebx = esi
if ((eax & ecx) != 0) then 222 @ 0x2486 else 224 @ 0x2467

call([0x100080ec].d)
goto 238 @ 0x239d

if ([eax + 0x10].d != ecx) then 239 @ 0x2390 else 241 @ 0x238b

if (esi u< [edx + 0x10].d) then 243 @ 0x23e9 else 245 @ 0x23ac

ecx = [ecx + 0x1c].d
eax = 1
eax = eax << cl
eax = not.d(eax)
[edx + 4].d = [edx + 4].d & eax
goto 153 @ 0x23f2

if (eax u<= 0xffff) then 249 @ 0x24e5 else 258 @ 0x24de

ecx = 0
goto 260 @ 0x24fb

eax = [esi + 8].d
if (eax u< [edx + 0x10].d) then 270 @ 0x24ab else 283 @ 0x248e

ecx = ecx | eax
eax = [esp + 0x24 {arg2}].d
[edx].d = ecx
[esi + 8].d = edi
[ebx + 0xc].d = edi
[edi + 8].d = ebx
[edi + 0xc].d = esi
edi = pop
esi = pop
ebp = pop
eax = eax + 8
ebx = pop
esp = esp + 0xc
<return> jump(pop)

if (esi == 0) then 153 @ 0x23f2 else 296 @ 0x239f

[eax + 0x14].d = esi
goto 238 @ 0x239d

[eax + 0x10].d = esi
goto 238 @ 0x239d

call([0x100080ec].d)
goto 153 @ 0x23f2

eax = [esp + 0x10 {var_c_2}].d
[esi + 0x18].d = eax
eax = [ecx + 0x10].d
if (eax == 0) then 299 @ 0x23d1 else 301 @ 0x23bd

edx, eflags = _bit_scan_reverse(eax)
eax = edx
[esp + 0x18 {var_4_1}].d = edx
ecx = eax + 7
edx = ebx
edx = edx u>> cl
edx = edx & 1
ecx = edx + (eax << 1)
goto 260 @ 0x24fb

ecx = 0x1f
goto 260 @ 0x24fb

ebp = [esp + 0x20 {arg1}].d
eax = 0
[edi + 0x14].d = eax
[edi + 0x10].d = eax
eax = 1
eax = eax << cl
[edi + 0x1c].d = ecx
esi = [ebp + 4].d
edx = ebp + (ecx << 2) + 0x130
if ((esi & eax) != 0) then 302 @ 0x253e else 305 @ 0x251f

call([0x100080ec].d)
eax = [esp + 0x24 {arg2}].d
[esi + 8].d = edi
[ebx + 0xc].d = edi
[edi + 8].d = ebx
[edi + 0xc].d = esi
edi = pop
esi = pop
ebp = pop
eax = eax + 8
ebx = pop
esp = esp + 0xc
<return> jump(pop)

ebx = eax
eax = [esp + 0x24 {arg2}].d
[esi + 8].d = edi
[ebx + 0xc].d = edi
[edi + 8].d = ebx
[edi + 0xc].d = esi
edi = pop
esi = pop
ebp = pop
eax = eax + 8
ebx = pop
esp = esp + 0xc
<return> jump(pop)

ecx = [esp + 0x24 {arg2}].d
edx = [esp + 0x20 {arg1}].d
goto 212 @ 0x23aa

eax = [ecx + 0x14].d
if (eax == 0) then 153 @ 0x23f2 else 319 @ 0x23d8

if (eax u< [edx + 0x10].d) then 321 @ 0x23c7 else 324 @ 0x23bf

cond:11 = ecx != 0x1f
eax = [edx].d
if (cond:11) then 327 @ 0x2549 else 331 @ 0x2545

eax = eax | esi
[ebp + 4].d = eax
eax = [esp + 0x24 {arg2}].d
[edx].d = edi
[edi + 0x18].d = edx
[edi + 0xc].d = edi
[edi + 8].d = edi
edi = pop
esi = pop
ebp = pop
eax = eax + 8
ebx = pop
esp = esp + 0xc
<return> jump(pop)

ecx = [esp + 0x20 {arg1}].d
if (eax u< [ecx + 0x10].d) then 243 @ 0x23e9 else 333 @ 0x23e1

call([0x100080ec].d)
ecx = [esp + 0x24 {arg2}].d
goto 299 @ 0x23d1

[esi + 0x10].d = eax
[eax + 0x18].d = esi
goto 299 @ 0x23d1

ecx = ecx u>> 1
esi = 0x19
esi = esi - ecx
goto 336 @ 0x2552

esi = 0
goto 336 @ 0x2552

[esi + 0x14].d = eax
[eax + 0x18].d = esi
goto 153 @ 0x23f2

ecx = esi
edx = ebx
edx = edx << cl
ecx = [eax + 4].d
ecx = ecx & 0xfffffff8
if (ecx == ebx) then 342 @ 0x257f else 346 @ 0x2562

edx = [ebp + 0x10].d
cond:12 = eax u< edx
ecx = [eax + 8].d
if (cond:12) then 352 @ 0x25ce else 361 @ 0x258b

ecx = edx
ecx = ecx u>> 0x1f
esi = eax + (ecx << 2) + 0x10
ecx = [esi].d
edx = edx + edx
if (ecx == 0) then 362 @ 0x25b2 else 363 @ 0x2573

call([0x100080ec].d)
eax = [esp + 0x24 {arg2}].d
edi = pop
esi = pop
ebp = pop
eax = eax + 8
ebx = pop
esp = esp + 0xc
<return> jump(pop)

if (ecx u< edx) then 352 @ 0x25ce else 367 @ 0x258d

if (esi u< [ebp + 0x10].d) then 352 @ 0x25ce else 380 @ 0x25b4

eax = ecx
ecx = [eax + 4].d
ecx = ecx & 0xfffffff8
if (ecx != ebx) then 346 @ 0x2562 else 342 @ 0x257f

[ecx + 0xc].d = edi
[eax + 8].d = edi
[edi + 0xc].d = eax
eax = [esp + 0x24 {arg2}].d
[edi + 8].d = ecx
[edi + 0x18].d = 0
edi = pop
esi = pop
ebp = pop
eax = eax + 8
ebx = pop
esp = esp + 0xc
<return> jump(pop)

[esi].d = edi
[edi + 0x18].d = eax
eax = [esp + 0x24 {arg2}].d
[edi + 0xc].d = edi
[edi + 8].d = edi
edi = pop
esi = pop
ebp = pop
eax = eax + 8
ebx = pop
esp = esp + 0xc
<return> jump(pop)

void* __convention("regparm") sub_2600(void* arg1, int32_t arg2, void* arg3, int32_t* arg4)
esp = esp - 0xc
push(ebx)
push(ebp)
push(esi)
esi = ecx
ecx = edx
ecx = ecx & 7
cond:0 = ecx == 0
push(edi)
edi = [esp + 0x20 {arg4}].d
if (cond:0) then 11 @ 0x2619 else 17 @ 0x2614

ebp = ecx + edx
ecx = esi
ecx = ecx & 7
cond:1 = ecx == 0
[esp + 0x18 {var_4}].d = ebp
if (cond:1) then 20 @ 0x262c else 33 @ 0x2627

ecx = neg.d(ecx)
ecx = ecx & 7
goto 11 @ 0x2619

esi = esi + ecx
edx = esi
ebx = eax + ebp
edx = edx - ebp
edx = edx - eax
eax = eax | 3
[ebp + 4].d = eax
eax = [0x10009f1c].d
eax = eax ^ edi
[ebx].d = eax
cond:2 = esi != [edi + 0x18].d
[esp + 0x20 {arg4}].d = edx
if (cond:2) then 36 @ 0x2670 else 37 @ 0x264f

ecx = neg.d(ecx)
ecx = ecx & 7
goto 20 @ 0x262c

if (esi != [edi + 0x14].d) then 50 @ 0x2695 else 54 @ 0x2672

[edi + 0xc].d = [edi + 0xc].d + edx
eax = [edi + 0xc].d
[edi + 0x18].d = ebx
edi = pop
eax = eax | 1
[ebx + 4].d = eax
eax = [esp + 0x14 {var_4}].d
esi = pop
ebp = pop
eax = eax + 8
ebx = pop
esp = esp + 0xc
<return> jump(pop)

eax = [esi + 4].d
ecx = eax
cl = cl & 3
if (cl != 1) then 69 @ 0x2807 else 78 @ 0x26a6

[edi + 8].d = [edi + 8].d + edx
eax = [edi + 8].d
[edi + 0x14].d = ebx
ecx = eax
edi = pop
ecx = ecx | 1
[ebx + 4].d = ecx
[eax + ebx].d = eax
eax = [esp + 0x14 {var_4}].d
esi = pop
ebp = pop
eax = eax + 8
ebx = pop
esp = esp + 0xc
<return> jump(pop)

[esi + 4].d = [esi + 4].d & 0xfffffffe
ecx = edx
ecx = ecx | 1
[ebx + 4].d = ecx
ecx = edx
ecx = ecx u>> 3
cond:3 = ecx u>= 0x20
[edx + ebx].d = edx
if (cond:3) then 85 @ 0x2898 else 88 @ 0x2820

ebp = [esi + 0xc].d
eax = eax & 0xfffffff8
ecx = eax
ecx = ecx u>> 3
cond:4 = ecx u>= 0x20
[esp + 0x14 {var_8_1}].d = eax
if (cond:4) then 94 @ 0x26fa else 98 @ 0x26ba

eax = edx
eax = eax u>> 8
if (eax != 0) then 100 @ 0x28a8 else 101 @ 0x289f

eax = 1
eax = eax << cl
esi = edi + (ecx << 3) + 0x28
ecx = [edi].d
ebp = esi
if ((ecx & eax) != 0) then 103 @ 0x2852 else 105 @ 0x2833

cond:5 = ebp == esi
eax = [esi + 0x18].d
[esp + 0x10 {var_c_1}].d = eax
if (cond:5) then 119 @ 0x2715 else 123 @ 0x2705

eax = [esi + 8].d
if (eax != ebp) then 125 @ 0x26d1 else 127 @ 0x26c1

if (eax u<= 0xffff) then 132 @ 0x28b1 else 140 @ 0x28aa

ecx = 0
goto 142 @ 0x28c5

eax = [esi + 8].d
if (eax u< [edi + 0x10].d) then 151 @ 0x2877 else 164 @ 0x285a

eax = eax | ecx
[edi].d = eax
eax = [esp + 0x18 {var_4}].d
[esi + 8].d = ebx
[ebp + 0xc].d = ebx
edi = pop
[ebx + 0xc].d = esi
esi = pop
[ebx + 8].d = ebp
ebp = pop
eax = eax + 8
ebx = pop
esp = esp + 0xc
<return> jump(pop)

ebp = [esi + 0x14].d
cond:6 = ebp != 0
ecx = esi + 0x14
if (cond:6) then 177 @ 0x2730 else 180 @ 0x271f

ecx = [esi + 8].d
if (ecx u< [edi + 0x10].d) then 184 @ 0x2755 else 187 @ 0x270d

ecx = edi + (ecx << 3) + 0x28
if (eax == ecx) then 190 @ 0x26e4 else 191 @ 0x26dc

eax = 1
eax = eax << cl
eax = not.d(eax)
[edi].d = [edi].d & eax
goto 192 @ 0x27ff

eax, eflags = _bit_scan_reverse(eax)
ecx = eax + 7
esi = edx
esi = esi u>> cl
[esp + 0x14 {var_8_2}].d = eax
esi = esi & 1
ecx = esi + (eax << 1)
goto 142 @ 0x28c5

ecx = 0x1f
goto 142 @ 0x28c5

eax = 0
[ebx + 0x14].d = eax
[ebx + 0x10].d = eax
eax = 1
eax = eax << cl
[ebx + 0x1c].d = ecx
ebp = [edi + 4].d
esi = edi + (ecx << 2) + 0x130
if ((ebp & eax) != 0) then 196 @ 0x2904 else 199 @ 0x28e5

call([0x100080ec].d)
eax = [esp + 0x18 {var_4}].d
[esi + 8].d = ebx
[ebp + 0xc].d = ebx
edi = pop
[ebx + 0xc].d = esi
esi = pop
[ebx + 8].d = ebp
ebp = pop
eax = eax + 8
ebx = pop
esp = esp + 0xc
<return> jump(pop)

ebp = eax
eax = [esp + 0x18 {var_4}].d
[esi + 8].d = ebx
[ebp + 0xc].d = ebx
edi = pop
[ebx + 0xc].d = esi
esi = pop
[ebx + 8].d = ebp
ebp = pop
eax = eax + 8
ebx = pop
esp = esp + 0xc
<return> jump(pop)

cond:7 = [ebp + 0x14].d != 0
eax = ebp + 0x14
if (cond:7) then 213 @ 0x2742 else 216 @ 0x2739

ebp = [esi + 0x10].d
cond:8 = ebp == 0
ecx = esi + 0x10
if (cond:8) then 219 @ 0x2765 else 220 @ 0x2729

call([0x100080ec].d)
edx = [esp + 0x20 {arg4}].d
goto 222 @ 0x275f

[ecx + 0xc].d = ebp
[ebp + 8].d = ecx
goto 219 @ 0x2765

if (ebp == ecx) then 224 @ 0x26ef else 227 @ 0x26e9

if (eax u< [edi + 0x10].d) then 228 @ 0x27f5 else 190 @ 0x26e4

eax = [esp + 0x14 {var_8_1}].d
esi = esi + eax
edx = edx + eax
goto 69 @ 0x2807

cond:9 = ecx != 0x1f
eax = [esi].d
if (cond:9) then 231 @ 0x290f else 235 @ 0x290b

eax = eax | ebp
[edi + 4].d = eax
eax = [esp + 0x18 {var_4}].d
[esi].d = ebx
edi = pop
[ebx + 0x18].d = esi
esi = pop
ebp = pop
[ebx + 0xc].d = ebx
[ebx + 8].d = ebx
eax = eax + 8
ebx = pop
esp = esp + 0xc
<return> jump(pop)

ebp = [eax].d
ecx = eax
goto 177 @ 0x2730

cond:10 = [ebp + 0x10].d == 0
eax = ebp + 0x10
if (cond:10) then 237 @ 0x274b else 213 @ 0x2742

if (eax == 0) then 192 @ 0x27ff else 238 @ 0x276b

esp = esp
goto 177 @ 0x2730

eax = [esp + 0x10 {var_c_1}].d
goto 219 @ 0x2765

[eax + 0xc].d = ebp
[ebp + 8].d = eax
goto 192 @ 0x27ff

if (ebp u< [edi + 0x10].d) then 228 @ 0x27f5 else 224 @ 0x26ef

call([0x100080ec].d)
edx = [esp + 0x20 {arg4}].d
goto 192 @ 0x27ff

ecx = ecx u>> 1
ebp = 0x19
ebp = ebp - ecx
goto 242 @ 0x2918

ebp = 0
goto 242 @ 0x2918

if (ecx u< [edi + 0x10].d) then 184 @ 0x2755 else 248 @ 0x274d

ecx = [esi + 0x1c].d
cond:11 = esi != [edi + (ecx << 2) + 0x130].d
ecx = edi + (ecx << 2) + 0x130
if (cond:11) then 250 @ 0x2798 else 251 @ 0x277e

ecx = ebp
esi = edx
esi = esi << cl
ecx = [eax + 4].d
ecx = ecx & 0xfffffff8
if (ecx == edx) then 254 @ 0x294e else 258 @ 0x2928

[ecx].d = 0
goto 222 @ 0x275f

if (eax u< [edi + 0x10].d) then 259 @ 0x27a9 else 263 @ 0x279d

cond:12 = ebp != 0
[ecx].d = ebp
if (cond:12) then 264 @ 0x27be else 265 @ 0x2784

edi = [edi + 0x10].d
cond:13 = eax u< edi
ecx = [eax + 8].d
if (cond:13) then 271 @ 0x299e else 280 @ 0x295a

goto 281 @ 0x2930

call([0x100080ec].d)
edx = [esp + 0x20 {arg4}].d
eax = [esp + 0x10 {var_c_1}].d
goto 287 @ 0x27b9

if ([eax + 0x10].d != esi) then 288 @ 0x27a4 else 290 @ 0x279f

if (ebp u< [edi + 0x10].d) then 228 @ 0x27f5 else 292 @ 0x27c0

ecx = [esi + 0x1c].d
eax = 1
eax = eax << cl
eax = not.d(eax)
[edi + 4].d = [edi + 4].d & eax
goto 192 @ 0x27ff

call([0x100080ec].d)
eax = [esp + 0x18 {var_4}].d
edi = pop
esi = pop
ebp = pop
eax = eax + 8
ebx = pop
esp = esp + 0xc
<return> jump(pop)

if (ecx u< edi) then 271 @ 0x299e else 295 @ 0x295c

ecx = esi
ecx = ecx u>> 0x1f
ebp = eax + (ecx << 2) + 0x10
ecx = [ebp].d
esi = esi + esi
if (ecx == 0) then 308 @ 0x2981 else 309 @ 0x2942

if (ebp == 0) then 192 @ 0x27ff else 264 @ 0x27be

[eax + 0x14].d = ebp
goto 287 @ 0x27b9

[eax + 0x10].d = ebp
goto 287 @ 0x27b9

[ebp + 0x18].d = eax
eax = [esi + 0x10].d
if (eax == 0) then 313 @ 0x27e1 else 315 @ 0x27cd

[ecx + 0xc].d = ebx
[eax + 8].d = ebx
edi = pop
[ebx + 0xc].d = eax
eax = [esp + 0x14 {var_4}].d
esi = pop
ebp = pop
[ebx + 8].d = ecx
[ebx + 0x18].d = 0
eax = eax + 8
ebx = pop
esp = esp + 0xc
<return> jump(pop)

if (ebp u< [edi + 0x10].d) then 271 @ 0x299e else 316 @ 0x2983

eax = ecx
ecx = [eax + 4].d
ecx = ecx & 0xfffffff8
if (ecx != edx) then 281 @ 0x2930 else 254 @ 0x294e

eax = [esi + 0x14].d
if (eax == 0) then 192 @ 0x27ff else 328 @ 0x27eb

if (eax u< [edi + 0x10].d) then 329 @ 0x27d7 else 332 @ 0x27cf

[ebp].d = ebx
edi = pop
[ebx + 0x18].d = eax
eax = [esp + 0x14 {var_4}].d
esi = pop
ebp = pop
[ebx + 0xc].d = ebx
[ebx + 8].d = ebx
eax = eax + 8
ebx = pop
esp = esp + 0xc
<return> jump(pop)

if (eax u< [edi + 0x10].d) then 228 @ 0x27f5 else 335 @ 0x27ed

call([0x100080ec].d)
edx = [esp + 0x20 {arg4}].d
goto 313 @ 0x27e1

[ebp + 0x10].d = eax
[eax + 0x18].d = ebp
goto 313 @ 0x27e1

[ebp + 0x14].d = eax
[eax + 0x18].d = ebp
goto 192 @ 0x27ff

void* __convention("regparm") sub_29c0(void* arg1)
eax = eax + 0x28
ecx = 0x20
goto 3 @ 0x29d0

[eax + 0xc].d = eax
[eax + 8].d = eax
eax = eax + 8
temp0.d = ecx
ecx = ecx - 1
if (temp0.d != 1) then 3 @ 0x29d0 else 9 @ 0x29de

<return> jump(pop)

int32_t __convention("fastcall") sub_29e0(void* arg1, int32_t arg2, void* arg3 @ esi)
eax = ecx
eax = eax & 7
if (eax == 0) then 3 @ 0x29ec else 14 @ 0x29e7

ecx = ecx + eax
edx = edx - eax
eax = edx
[esi + 0x18].d = ecx
[esi + 0xc].d = edx
eax = eax | 1
[ecx + 4].d = eax
[ecx + edx + 4].d = 0x28
ecx = [0x10009f2c].d
[esi + 0x1c].d = ecx
<return> jump(pop)

eax = neg.d(eax)
eax = eax & 7
goto 3 @ 0x29ec

void __convention("regparm") sub_2a10(int32_t (* arg1)(), int32_t arg2)
ecx = [eax + 4].d
push(esi)
esi = edx
esi = esi & 0xfffffff8
ecx = ecx & 0xfffffff8
if (esi u< 0x100) then 6 @ 0x2a39 else 8 @ 0x2a24

eax = 0
goto 10 @ 0x2a3b

esi = edx + 4
if (ecx u< esi) then 6 @ 0x2a39 else 12 @ 0x2a2b

esi = pop
<return> jump(pop)

ecx = ecx - edx
edx = [0x10009f24].d
edx = edx + edx
if (ecx u<= edx) then 10 @ 0x2a3b else 6 @ 0x2a39

void* __convention("regparm") sub_2a40(void* arg1, int32_t* arg2)
ecx = [edx].d
eax = eax + 0x1bc
push(esi)
goto 4 @ 0x2a4a

if (eax u< ecx) then 5 @ 0x2a55 else 7 @ 0x2a4c

eax = [eax + 8].d
if (eax != 0) then 4 @ 0x2a4a else 10 @ 0x2a5c

esi = [edx + 4].d
esi = esi + ecx
if (eax u< esi) then 12 @ 0x2a5e else 5 @ 0x2a55

esi = pop
<return> jump(pop)

eax = 1
esi = pop
<return> jump(pop)

int32_t* __convention("regparm") sub_2a70(void* arg1, int32_t arg2)
eax = eax + 0x1bc
push(esi)
goto 3 @ 0x2a76

ecx = [eax].d
if (edx u< ecx) then 5 @ 0x2a85 else 7 @ 0x2a7c

eax = [eax + 8].d
if (eax != 0) then 3 @ 0x2a76 else 10 @ 0x2a8c

esi = [eax + 4].d
esi = esi + ecx
if (edx u< esi) then 10 @ 0x2a8c else 5 @ 0x2a85

esi = pop
<return> jump(pop)

int32_t sub_2a90(int32_t* arg1 @ esi)
eax = [esi].d
if (eax == 0) then 2 @ 0x2aab else 8 @ 0x2a96

ecx = 1
edx = esi
temp0.d = [edx].d
[edx].d = ecx
ecx = temp0.d
if (ecx != 0) then 10 @ 0x2ace else 12 @ 0x2ab8

call([0x10008018].d)
if ([esi + 0x48].d != eax) then 10 @ 0x2ace else 17 @ 0x2aa1

eax = 0
<return> jump(pop)

call([0x10008018].d)
[esi + 0x48].d = eax
[esi + 0x44].d = 1
eax = 1
<return> jump(pop)

[esi + 0x44].d = [esi + 0x44].d + 1
eax = 1
<return> jump(pop)

void __convention("regparm") sub_2ae0(int32_t* arg1)
temp1.d = [eax + 0x44].d
[eax + 0x44].d = [eax + 0x44].d - 1
if (temp1.d != 1) then 3 @ 0x2af1 else 4 @ 0x2ae6

<return> jump(pop)

[eax + 0x48].d = 0
ecx = 0
temp0.d = [eax].d
[eax].d = ecx
ecx = temp0.d
goto 3 @ 0x2af1

int32_t sub_2b00(int32_t* arg1 @ esi)
push(ebx)
push(edi)
edi = [0x10008018].d
ebx = 0
ebx = ebx
goto 6 @ 0x2b10

eax = [esi].d
if (eax == 0) then 8 @ 0x2b26 else 14 @ 0x2b16

ecx = 1
edx = esi
temp0.d = [edx].d
[edx].d = ecx
ecx = temp0.d
if (ecx == 0) then 16 @ 0x2b47 else 23 @ 0x2b33

call(edi)
if ([esi + 0x48].d != eax) then 23 @ 0x2b33 else 25 @ 0x2b1d

call(edi)
edi = pop
[esi + 0x48].d = eax
[esi + 0x44].d = 1
eax = 0
ebx = pop
<return> jump(pop)

ebx = ebx + 1
if ((bl & 0x3f) != 0) then 6 @ 0x2b10 else 30 @ 0x2b3b

[esi + 0x44].d = [esi + 0x44].d + 1
edi = pop
eax = 0
ebx = pop
<return> jump(pop)

push(zx.d(0))
push(zx.d(0))
call([0x10008020].d), esp += 8
goto 6 @ 0x2b10

int32_t __convention("regparm") sub_2b60(int32_t arg1, int32_t arg2, int32_t arg3)
esp = esp - 0x1c
push(ebx)
push(ebp)
push(esi)
push(edi)
edi = eax
cond:0 = edi == 0
esi = ecx
if (cond:0) then 9 @ 0x2bc2 else 16 @ 0x2b6f

edi = pop
esi = pop
ebp = pop
eax = 0
ebx = pop
esp = esp + 0x1c
<return> jump(pop)

ebp = [0x10008014].d
ebx = [0x1000802c].d
goto 19 @ 0x2b80

push(zx.d(0x1c))
eax = esp + 0x14 {var_1c}
push(eax)
push(esi)
call(ebp), esp += 0xc
if (eax == 0) then 25 @ 0x2bcc else 32 @ 0x2b92

edi = pop
esi = pop
ebp = pop
eax = eax | 0xffffffff
ebx = pop
esp = esp + 0x1c
<return> jump(pop)

if ([esp + 0x10 {var_1c}].d != esi) then 25 @ 0x2bcc else 33 @ 0x2b98

if ([esp + 0x14 {var_18}].d != esi) then 25 @ 0x2bcc else 34 @ 0x2ba2

if ([esp + 0x20 {var_c}].d != &data_1000) then 25 @ 0x2bcc else 35 @ 0x2ba8

if ([esp + 0x1c {var_10}].d u> edi) then 25 @ 0x2bcc else 36 @ 0x2baa

push(0x8000)
push(zx.d(0))
push(esi)
call(ebx), esp += 0xc
if (eax == 0) then 25 @ 0x2bcc else 41 @ 0x2bb8

eax = [esp + 0x1c {var_10}].d
esi = esi + eax
temp0.d = edi
edi = edi - eax
if (temp0.d != eax) then 19 @ 0x2b80 else 9 @ 0x2bc2

int32_t __convention("regparm") sub_2be0(int32_t arg1)
push(zx.d(4))
push(0x103000)
push(eax)
push(zx.d(0))
call([0x10008034].d), esp += 0x10
if (eax != 0) then 6 @ 0x2bf7 else 7 @ 0x2bf4

<return> jump(pop)

eax = eax | 0xffffffff
goto 6 @ 0x2bf7

int32_t __convention("regparm") sub_2c00(int32_t arg1)
push(zx.d(4))
push(0x3000)
push(eax)
push(zx.d(0))
call([0x10008034].d), esp += 0x10
if (eax != 0) then 6 @ 0x2c17 else 7 @ 0x2c14

<return> jump(pop)

eax = eax | 0xffffffff
goto 6 @ 0x2c17

int32_t sub_2c20(int32_t* arg1, void* arg2)
edx = [esp + 8 {arg2}].d
call(sub_1e60)
if (eax == 0) then 3 @ 0x2c45 else 5 @ 0x2c2d

eax = 0
<return> jump(pop)

eax = [eax + 0x218].d
if (eax == 0) then 3 @ 0x2c45 else 7 @ 0x2c37

ecx = [esp + 4 {arg1}].d
if (ecx == 0) then 9 @ 0x2c41 else 11 @ 0x2c3f

eax = [eax + 0x4c].d
<return> jump(pop)

[ecx].d = eax
goto 9 @ 0x2c41

void* sub_2c50(void* arg1 @ edi, int32_t* arg2)
push(ecx)
ecx = [esp + 8 {arg2}].d
push(ebx)
push(ebp)
push(esi)
esi = [ecx].d
edx = esi
edx = edx u>> 4
ecx, eflags = _bit_scan_reverse(edx)
ebx = ecx
[esp + 0xc {var_4}].d = ecx
ecx = ebx + 4
edx = 1
edx = edx << cl
eax = 0
ebp = 0
cond:0 = esi u< edx
if (esi u<= edx) then 18 @ 0x2c81 else 20 @ 0x2c7a

ecx = [edi + (ebx << 3) + 0x18].d
if (cond:0) then 24 else 26 @ 0x2c88

edx = edx + edx
ebx = ebx + 1
cond:0 = esi u< edx
goto 18 @ 0x2c81

esi = edx
goto 26 @ 0x2c88

cond:1 = ecx == 0
edx = edi + (ebx << 3) + 0x18
if (cond:1) then 29 @ 0x2c98 else 30 @ 0x2c93

if (ebx u>= 9) then 31 @ 0x2ca0 else 33 @ 0x2c9a

if ([ecx + 8].d u>= esi) then 31 @ 0x2ca0 else 29 @ 0x2c98

ebx = 0
if (ecx == ebx) then 36 @ 0x2cbe else 39 @ 0x2ca6

ecx = [edx + 8].d
edx = edx + 8
goto 31 @ 0x2ca0

ecx = 1
[edi + 8].d = [edi + 8].d + ecx
if (eax == ebx) then 43 @ 0x2cdb else 50 @ 0x2cca

eax = [ecx + 0xc].d
cond:2 = eax == ebx
ebp = [ecx + 8].d
if (cond:2) then 59 @ 0x2cb3 else 62 @ 0x2cb0

ecx = [esp + 0x14 {arg2}].d
[ecx].d = esi
esi = pop
ebp = pop
ebx = pop
ecx = pop
<return> jump(pop)

edx = [esp + 0x14 {arg2}].d
[edi + 0x10].d = [edi + 0x10].d + ecx
[edi + 0x14].d = [edi + 0x14].d - ebp
[edx].d = esi
esi = pop
ebp = pop
ebx = pop
ecx = pop
<return> jump(pop)

cond:3 = eax != ebx
[edx].d = eax
if (cond:3) then 64 @ 0x2cbc else 66 @ 0x2cb9

[eax + 0x10].d = ebx
goto 59 @ 0x2cb3

eax = ecx
goto 36 @ 0x2cbe

[edx + 4].d = ebx
goto 64 @ 0x2cbc

int32_t sub_2cf0(int32_t* arg1, void* arg2)
push(edi)
edi = [esp + 0xc {arg2}].d
if (edi == 0) then 3 @ 0x2d36 else 6 @ 0x2cf9

eax = 0
edi = pop
<return> jump(pop)

push(esi)
esi = [esp + 0xc {arg1}].d
if (esi == 0) then 9 @ 0x2d08 else 12 @ 0x2d02

edx = edi
call(sub_1e60)
if (eax == 0) then 14 @ 0x2d29 else 20 @ 0x2d15

[esi].d = 1
goto 9 @ 0x2d08

push(edi)
call([0x10009bd8].d)
esp = esp + 4
esi = pop
edi = pop
<return> jump(pop)

if (esi == 0) then 21 @ 0x2d1d else 27 @ 0x2d17

eax = [edi - 4].d
eax = eax & 0xfffffff8
esi = pop
eax = eax - 8
edi = pop
<return> jump(pop)

[esi].d = 0
goto 21 @ 0x2d1d

int32_t __convention("regparm") sub_2d40(void* arg1)
ecx = [0x10009f1c].d
push(ebx)
ebx = 0
if ([eax + 0x24].d != ecx) then 4 @ 0x2d8a else 8 @ 0x2d4e

call([0x100080ec].d)
eax = ebx
ebx = pop
<return> jump(pop)

push(esi)
esi = eax + 0x1bc
if (esi == 0) then 11 @ 0x2d85 else 15 @ 0x2d59

esi = pop
eax = ebx
ebx = pop
<return> jump(pop)

push(edi)
ebx = ebx
goto 18 @ 0x2d60

eax = [esi + 0xc].d
cond:0 = (al & 1) == 0
ecx = [esi].d
edi = [esi + 4].d
esi = [esi + 8].d
if (cond:0) then 24 @ 0x2d82 else 25 @ 0x2d71

if (esi != 0) then 18 @ 0x2d60 else 26 @ 0x2d84

if ((al & 8) != 0) then 24 @ 0x2d82 else 28 @ 0x2d73

edi = pop
goto 11 @ 0x2d85

eax = edi
call(sub_2b60)
if (eax != 0) then 24 @ 0x2d82 else 31 @ 0x2d7e

ebx = ebx + edi
goto 24 @ 0x2d82

int32_t __convention("regparm") sub_2da0(int32_t arg1) __noreturn
push(ebp)
push(esi)
push(edi)
edi = eax
eax = eax & 7
if (eax != 0) then 6 @ 0x2dae else 10 @ 0x2daa

eax = neg.d(eax)
eax = eax & 7
ebp = eax
goto 12 @ 0x2db5

ebp = 0
goto 12 @ 0x2db5

push(0x228)
esi = edi + ebp + 8
push(zx.d(0))
push(esi)
call(sub_6938)
noreturn
{ Does not return }

int32_t sub_2e90()
esp = esp - 0x20
eax = ebx + 0x1bc
edx = 0
[esp + 0x10 {i_2}].d = eax
eax = [eax + 8 {&data_1c4}].d
cond:0 = eax == edx
[esp + 4 {var_1c}].d = edx
[esp + 8 {var_18}].d = edx
[esp {i_1}].d = eax
if (cond:0) then 10 @ 0x3151 else 12 @ 0x2eb5

eax = 0xfff
goto 16 @ 0x3156

push(ebp)
push(esi)
push(edi)
goto 20 @ 0x2ec0

[ebx + 0x20 {&data_20}].d = eax
eax = [esp + 4 {var_1c}].d
esp = esp + 0x20
<return> jump(pop)

eax = [esp + 0xc {i_1}].d
edi = [eax].d
ebp = [eax + 4].d
ecx = [eax + 8].d
eax = [eax + 0xc].d
[esp + 0x14 {var_18}].d = [esp + 0x14 {var_18}].d + 1
cond:1 = (al & 1) == 0
[esp + 0x24 {var_8_1}].d = edi
[esp + 0x18 {var_14_1}].d = ebp
[esp + 0x20 {var_c_1}].d = ecx
if (cond:1) then 31 @ 0x3129 else 38 @ 0x2eea

edx = [esp + 0xc {i_1}].d
eax = [esp + 0x20 {var_c_1}].d
[esp + 0x1c {i_2}].d = edx
edx = 0
cond:2 = eax != edx
[esp + 0xc {i_1}].d = eax
if (cond:2) then 20 @ 0x2ec0 else 39 @ 0x3143

if ((al & 8) != 0) then 31 @ 0x3129 else 45 @ 0x2ef0

eax = [esp + 0x14 {var_18}].d
cond:3 = eax s> 0xfff
edi = pop
esi = pop
ebp = pop
if (cond:3) then 16 @ 0x3156 else 10 @ 0x3151

eax = edi
eax = eax & 7
if (eax == 0) then 48 @ 0x2efc else 56 @ 0x2ef7

esi = eax + edi
eax = [esi + 4].d
ecx = eax
ecx = ecx & 0xfffffff8
al = al & 3
cond:4 = al != 1
[esp + 0x28 {var_4_1}].d = ecx
if (cond:4) then 31 @ 0x3129 else 59 @ 0x2f15

eax = neg.d(eax)
eax = eax & 7
goto 48 @ 0x2efc

eax = edi + ebp - 0x28
ecx = ecx + esi
if (ecx u< eax) then 31 @ 0x3129 else 62 @ 0x2f26

if (esi != [ebx + 0x14 {&data_14}].d) then 63 @ 0x2f33 else 67 @ 0x2f28

edi = [esi + 0xc].d
cond:5 = edi == esi
ebp = [esi + 0x18].d
if (cond:5) then 70 @ 0x2f4d else 74 @ 0x2f3d

[ebx + 0x14 {&data_14}].d = edx
[ebx + 8 {&data_8}].d = edx
goto 76 @ 0x3012

edi = [esi + 0x14].d
cond:6 = edi != edx
ecx = esi + 0x14
if (cond:6) then 80 @ 0x2f61 else 83 @ 0x2f57

eax = [esi + 8].d
if (eax u< [ebx + 0x10 {&data_10}].d) then 87 @ 0x2f80 else 89 @ 0x2f45

eax = [esp + 0x18 {var_14_1}].d
ecx = [esp + 0x24 {var_8_1}].d
call(sub_2b60)
if (eax != 0) then 92 @ 0x3045 else 96 @ 0x3023

cond:7 = [edi + 0x14].d != edx
eax = edi + 0x14
if (cond:7) then 104 @ 0x2f71 else 107 @ 0x2f69

edi = [esi + 0x10].d
cond:8 = edi == edx
ecx = esi + 0x10
if (cond:8) then 110 @ 0x2f88 else 80 @ 0x2f61

call([0x100080ec].d)
goto 110 @ 0x2f88

[eax + 0xc].d = edi
[edi + 8].d = eax
goto 110 @ 0x2f88

ebp = [esp + 0x28 {var_4_1}].d
eax = ebp
eax = eax u>> 8
if (eax != 0) then 111 @ 0x3059 else 112 @ 0x3050

eax = [esp + 0x18 {var_14_1}].d
[esp + 0x10 {var_1c}].d = [esp + 0x10 {var_1c}].d + eax
[ebx + 0x1b0 {&data_1b0}].d = [ebx + 0x1b0 {&data_1b0}].d - eax
eax = [esp + 0x1c {i_2}].d
ecx = [esp + 0x20 {var_c_1}].d
[esp + 0xc {i_1}].d = eax
[eax + 8].d = ecx
goto 31 @ 0x3129

edi = [eax].d
ecx = eax
goto 80 @ 0x2f61

cond:9 = [edi + 0x10].d == edx
eax = edi + 0x10
if (cond:9) then 114 @ 0x2f7a else 104 @ 0x2f71

if (ebp == 0) then 76 @ 0x3012 else 115 @ 0x2f8e

if (eax u<= 0xffff) then 119 @ 0x3062 else 128 @ 0x305b

ecx = 0
goto 130 @ 0x3078

if (ecx u< [ebx + 0x10 {&data_10}].d) then 87 @ 0x2f80 else 139 @ 0x2f7c

ecx = [esi + 0x1c].d
cond:10 = esi != [ebx + (ecx << 2) + 0x130].d
eax = ebx + (ecx << 2) + 0x130
if (cond:10) then 141 @ 0x2fbb else 142 @ 0x2fa1

edx, eflags = _bit_scan_reverse(eax)
eax = edx
[esp + 0x28 {var_4_2}].d = edx
ecx = eax + 7
edx = ebp
edx = edx u>> cl
edx = edx & 1
ecx = edx + (eax << 1)
goto 130 @ 0x3078

ecx = 0x1f
goto 130 @ 0x3078

eax = 0
[esi + 0x14].d = eax
[esi + 0x10].d = eax
eax = 1
eax = eax << cl
[esi + 0x1c].d = ecx
edi = [ebx + 4 {&data_4}].d
edx = ebx + (ecx << 2) + 0x130
if ((edi & eax) != 0) then 145 @ 0x30ad else 148 @ 0x3098

[ecx].d = edx
goto 110 @ 0x2f88

if (ebp u< [ebx + 0x10 {&data_10}].d) then 155 @ 0x2fcc else 157 @ 0x2fc0

cond:11 = edi != 0
[eax].d = edi
if (cond:11) then 158 @ 0x2fd9 else 159 @ 0x2fa7

cond:12 = ecx != 0x1f
eax = [edx].d
if (cond:12) then 165 @ 0x30b8 else 169 @ 0x30b4

eax = eax | edi
[ebx + 4 {&data_4}].d = eax
[edx].d = esi
[esi + 0x18].d = edx
[esi + 0xc].d = esi
[esi + 8].d = esi
goto 31 @ 0x3129

call([0x100080ec].d)
goto 171 @ 0x2fd4

if ([ebp + 0x10].d != esi) then 172 @ 0x2fc7 else 174 @ 0x2fc2

if (edi u< [ebx + 0x10 {&data_10}].d) then 176 @ 0x300c else 178 @ 0x2fdb

ecx = [esi + 0x1c].d
edx = 1
edx = edx << cl
edx = not.d(edx)
[ebx + 4 {&data_4}].d = [ebx + 4 {&data_4}].d & edx
goto 76 @ 0x3012

ecx = ecx u>> 1
edi = 0x19
edi = edi - ecx
goto 181 @ 0x30c1

edi = 0
goto 181 @ 0x30c1

if (edi == 0) then 76 @ 0x3012 else 158 @ 0x2fd9

[ebp + 0x14].d = edi
goto 171 @ 0x2fd4

[ebp + 0x10].d = edi
goto 171 @ 0x2fd4

call([0x100080ec].d)
goto 76 @ 0x3012

[edi + 0x18].d = ebp
eax = [esi + 0x10].d
if (eax == 0) then 187 @ 0x2ff8 else 189 @ 0x2fe8

ecx = edi
edx = ebp
edx = edx << cl
ecx = [eax + 4].d
ecx = ecx & 0xfffffff8
if (ecx == ebp) then 190 @ 0x30ee else 194 @ 0x30d1

eax = [esi + 0x14].d
if (eax == 0) then 76 @ 0x3012 else 200 @ 0x3002

if (eax u< [ebx + 0x10 {&data_10}].d) then 201 @ 0x2ff2 else 203 @ 0x2fea

edx = [ebx + 0x10 {&data_10}].d
cond:13 = eax u< edx
ecx = [eax + 8].d
if (cond:13) then 206 @ 0x3123 else 208 @ 0x30fa

ecx = edx
ecx = ecx u>> 0x1f
edi = eax + (ecx << 2) + 0x10
ecx = [edi].d
edx = edx + edx
if (ecx == 0) then 209 @ 0x3114 else 210 @ 0x30e2

if (eax u< [ebx + 0x10 {&data_10}].d) then 176 @ 0x300c else 214 @ 0x3004

call([0x100080ec].d)
goto 187 @ 0x2ff8

[edi + 0x10].d = eax
[eax + 0x18].d = edi
goto 187 @ 0x2ff8

call([0x100080ec].d)
goto 31 @ 0x3129

if (ecx u< edx) then 206 @ 0x3123 else 217 @ 0x30fc

if (edi u< [ebx + 0x10 {&data_10}].d) then 206 @ 0x3123 else 223 @ 0x3116

eax = ecx
ecx = [eax + 4].d
ecx = ecx & 0xfffffff8
if (ecx != ebp) then 194 @ 0x30d1 else 190 @ 0x30ee

[edi + 0x14].d = eax
[eax + 0x18].d = edi
goto 76 @ 0x3012

[ecx + 0xc].d = esi
[eax + 8].d = esi
[esi + 8].d = ecx
[esi + 0xc].d = eax
[esi + 0x18].d = 0
goto 31 @ 0x3129

[edi].d = esi
[esi + 0x18].d = eax
[esi + 0xc].d = esi
[esi + 8].d = esi
goto 31 @ 0x3129

void __convention("regparm") sub_3170(int32_t* arg1, void* arg2, int32_t arg3, int32_t arg4)
esp = esp - 8
push(ebx)
ebx = [esp + 0x10 {arg2}].d
push(ebp)
push(esi)
esi = [eax + 0x18].d
push(edi)
ecx = eax + 0x1bc
goto 9 @ 0x3184

edx = [ecx].d
if (esi u< edx) then 11 @ 0x3193 else 13 @ 0x318a

ecx = [ecx + 8].d
if (ecx != 0) then 9 @ 0x3184 else 16 @ 0x319a

edi = [ecx + 4].d
edi = edi + edx
if (esi u< edi) then 16 @ 0x319a else 11 @ 0x3193

edx = [ecx + 4].d
edx = edx + [ecx].d
[esp + 0x10 {var_8}].d = edx
edx = edx - 0x2f
ecx = edx
ecx = ecx & 7
if (ecx == 0) then 23 @ 0x31b2 else 26 @ 0x31ad

edi = ecx + edx
ecx = esi + 0x10
if (edi u>= ecx) then 29 @ 0x31be else 36 @ 0x31bc

ecx = neg.d(ecx)
ecx = ecx & 7
goto 23 @ 0x31b2

edx = [esp + 0x20 {arg3}].d
ebp = ebx
edx = edx - 0x28
ebp = ebp & 7
cond:0 = ebp == 0
ecx = edi + 8
if (cond:0) then 38 @ 0x31d4 else 73 @ 0x31cf

edi = esi
goto 29 @ 0x31be

edx = edx - ebp
[eax + 0xc].d = edx
ebx = ebx + ebp
ebp = edx
[eax + 0x18].d = ebx
ebp = ebp | 1
[ebx + 4].d = ebp
[ebx + edx + 4].d = 0x28
edx = [0x10009f2c].d
[eax + 0x1c].d = edx
edx = [0x10009f1c].d
[edi + 4].d = 0x1b
edx = edx ^ eax
[edi + 0x18].d = edx
edx = [eax + 0x1bc].d
[ecx].d = edx
edx = [eax + 0x1c0].d
ebx = [esp + 0x10 {var_8}].d
[ecx + 4].d = edx
edx = [eax + 0x1c4].d
[ecx + 8].d = edx
edx = [eax + 0x1c8].d
[ecx + 0xc].d = edx
edx = [esp + 0x1c {arg2}].d
[eax + 0x1bc].d = edx
edx = [esp + 0x20 {arg3}].d
[eax + 0x1c0].d = edx
edx = [esp + 0x24 {arg4}].d
[eax + 0x1c4].d = ecx
ecx = edi + 0x1c
[eax + 0x1c8].d = edx
edx = ecx + 4
cond:1 = edx u>= ebx
[ecx].d = 7
if (cond:1) then 76 @ 0x3276 else 77 @ 0x3264

ebp = neg.d(ebp)
ebp = ebp & 7
goto 38 @ 0x31d4

if (edi == esi) then 82 @ 0x335a else 88 @ 0x327c

ecx = ecx + 4
edx = edx + 4
cond:2 = edx u< ebx
[ecx].d = 7
if (cond:2) then 77 @ 0x3264 else 76 @ 0x3276

edi = pop
esi = pop
ebp = pop
ebx = pop
esp = esp + 8
<return> jump(pop)

edi = edi - esi
[edi + esi + 4].d = [edi + esi + 4].d & 0xfffffffe
ecx = edi
ecx = ecx | 1
[esi + 4].d = ecx
ecx = edi
ecx = ecx u>> 3
cond:3 = ecx u>= 0x20
[edi + esi].d = edi
if (cond:3) then 98 @ 0x32fb else 101 @ 0x3298

ecx = edi
ecx = ecx u>> 8
if (ecx != 0) then 107 @ 0x330c else 108 @ 0x3302

edx = 1
edx = edx << cl
edi = eax + (ecx << 3) + 0x28
ecx = [eax].d
ebx = edi
if ((edx & ecx) != 0) then 110 @ 0x32c3 else 112 @ 0x32ab

if (ecx u<= 0xffff) then 124 @ 0x3315 else 132 @ 0x330e

ecx = 0
goto 134 @ 0x3329

ecx = [edi + 8].d
if (ecx u< [eax + 0x10].d) then 144 @ 0x32e1 else 155 @ 0x32cb

ecx = ecx | edx
[eax].d = ecx
[edi + 8].d = esi
[ebx + 0xc].d = esi
[esi + 0xc].d = edi
edi = pop
[esi + 8].d = ebx
esi = pop
ebp = pop
ebx = pop
esp = esp + 8
<return> jump(pop)

edx, eflags = _bit_scan_reverse(ecx)
ecx = edx + 7
ebx = edi
ebx = ebx u>> cl
[esp + 0x14 {var_4_1}].d = edx
ebx = ebx & 1
ecx = ebx + (edx << 1)
goto 134 @ 0x3329

ecx = 0x1f
goto 134 @ 0x3329

edx = 0
ebx = 1
ebx = ebx << cl
[esi + 0x1c].d = ecx
[esi + 0x14].d = edx
[esi + 0x10].d = edx
edx = [eax + 4].d
cond:4 = (ebx & edx) != 0
ebp = eax + (ecx << 2) + 0x130
if (cond:4) then 166 @ 0x3362 else 169 @ 0x3349

call([0x100080ec].d)
[edi + 8].d = esi
[ebx + 0xc].d = esi
[esi + 0xc].d = edi
edi = pop
[esi + 8].d = ebx
esi = pop
ebp = pop
ebx = pop
esp = esp + 8
<return> jump(pop)

[edi + 8].d = esi
ebx = ecx
[ebx + 0xc].d = esi
[esi + 0xc].d = edi
edi = pop
[esi + 8].d = ebx
esi = pop
ebp = pop
ebx = pop
esp = esp + 8
<return> jump(pop)

cond:5 = ecx != 0x1f
edx = [ebp].d
if (cond:5) then 176 @ 0x336e else 180 @ 0x336a

edx = edx | ebx
[eax + 4].d = edx
[ebp].d = esi
[esi + 0x18].d = ebp
[esi + 0xc].d = esi
[esi + 8].d = esi
goto 82 @ 0x335a

ecx = ecx u>> 1
ebp = 0x19
ebp = ebp - ecx
goto 182 @ 0x3377

ebp = 0
goto 182 @ 0x3377

ecx = ebp
ebx = edi
ebx = ebx << cl
ecx = [edx + 4].d
ecx = ecx & 0xfffffff8
if (ecx == edi) then 188 @ 0x33a5 else 192 @ 0x3387

eax = [eax + 0x10].d
cond:6 = edx u< eax
ecx = [edx + 8].d
if (cond:6) then 198 @ 0x33f4 else 204 @ 0x33b1

ecx = ebx
ecx = ecx u>> 0x1f
ebp = edx + (ecx << 2) + 0x10
ecx = [ebp].d
ebx = ebx + ebx
if (ecx == 0) then 205 @ 0x33d1 else 206 @ 0x3399

edi = pop
esi = pop
ebp = pop
ebx = pop
esp = esp + 8
jump([0x100080ec].d)

if (ecx u< eax) then 198 @ 0x33f4 else 210 @ 0x33b3

if (ebp u< [eax + 0x10].d) then 221 @ 0x33e7 else 227 @ 0x33d3

edx = ecx
ecx = [edx + 4].d
ecx = ecx & 0xfffffff8
if (ecx != edi) then 192 @ 0x3387 else 188 @ 0x33a5

[ecx + 0xc].d = esi
[edx + 8].d = esi
edi = pop
[esi + 8].d = ecx
[esi + 0xc].d = edx
[esi + 0x18].d = 0
esi = pop
ebp = pop
ebx = pop
esp = esp + 8
<return> jump(pop)

edi = pop
esi = pop
ebp = pop
ebx = pop
esp = esp + 8
jump([0x100080ec].d)

[ebp].d = esi
edi = pop
[esi + 0x18].d = edx
[esi + 0xc].d = esi
[esi + 8].d = esi
esi = pop
ebp = pop
ebx = pop
esp = esp + 8
<return> jump(pop)

void* __convention("regparm") sub_3410(int32_t arg1, void* arg2 @ edi)
ecx = [0x10009f24].d
push(ebx)
ebx = ecx + eax + 0x1e
ecx = ecx - 1
ecx = not.d(ecx)
ebx = ebx & ecx
if (ebx u<= eax) then 7 @ 0x34a4 else 10 @ 0x3426

eax = 0
ebx = pop
<return> jump(pop)

push(zx.d(4))
push(0x103000)
push(ebx)
push(zx.d(0))
call([0x10008034].d), esp += 0x10
if (eax == 0) then 7 @ 0x34a4 else 16 @ 0x343d

if (eax == -1) then 7 @ 0x34a4 else 17 @ 0x343f

push(esi)
esi = eax
esi = esi & 7
if (esi == 0) then 21 @ 0x344c else 36 @ 0x3447

edx = eax + esi
[edx].d = esi
ecx = ebx
ecx = ecx - esi
esi = [0x10009f1c].d
ecx = ecx - 0x10
[edx + 4].d = ecx
esi = esi ^ edi
[edx + ecx].d = esi
[edx + ecx + 4].d = 7
[edx + ecx + 8].d = 0
ecx = [edi + 0x10].d
cond:0 = ecx == 0
esi = pop
if (cond:0) then 39 @ 0x3482 else 41 @ 0x3480

esi = neg.d(esi)
esi = esi & 7
goto 21 @ 0x344c

[edi + 0x10].d = eax
goto 42 @ 0x3485

if (eax u>= ecx) then 42 @ 0x3485 else 39 @ 0x3482

[edi + 0x1b0].d = [edi + 0x1b0].d + ebx
eax = [edi + 0x1b0].d
if (eax u<= [edi + 0x1b4].d) then 45 @ 0x349f else 48 @ 0x3499

eax = edx + 8
ebx = pop
<return> jump(pop)

[edi + 0x1b4].d = eax
goto 45 @ 0x349f

int32_t sub_34b0()
esp = esp - 0x24
push(esi)
esi = 0x1000e400
call(sub_2b00)
eax = [0x10009f1c].d
if (eax != 0) then 6 @ 0x3527 else 12 @ 0x34c7

eax = 1
temp1.d = [0x1000e444].d
[0x1000e444].d = [0x1000e444].d - eax
cond:0 = temp1.d != eax
esi = pop
if (cond:0) then 18 @ 0x3548 else 20 @ 0x3535

ecx = esp + 4 {var_24}
push(ecx)
call([0x10008010].d), esp += 4
esi = [esp + 8 {var_20}].d
edx = esi - 1
if ((esi & edx) == 0) then 27 @ 0x34e3 else 38 @ 0x34dd

esp = esp + 0x24
<return> jump(pop)

[0x1000e448].d = 0
ecx = 0
edx = 0x1000e400
temp0.d = [edx {0x1000e400}].d
[edx {0x1000e400}].d = ecx
ecx = temp0.d
goto 18 @ 0x3548

[0x10009f24].d = 0x100000
[0x10009f20].d = esi
[0x10009f28].d = 0x40000
[0x10009f2c].d = 0x200000
[0x10009f30].d = 7
call([0x10008028].d)
eax = eax ^ 0x55555550
eax = eax & 0xfffffff8
eax = eax | 8
[0x10009f1c].d = eax
goto 6 @ 0x3527

call([0x100080ec].d)
goto 27 @ 0x34e3

int32_t sub_3550(int32_t arg1 @ esi)
eax = [0x10009f1c].d
push(edi)
edi = 0
if (eax != 0) then 4 @ 0x3561 else 7 @ 0x355c

ecx = 0xfffffdb0
ecx = ecx - [0x10009f20].d
if (esi u>= ecx) then 9 @ 0x35bf else 12 @ 0x3570

call(sub_34b0)
goto 4 @ 0x3561

eax = edi
edi = pop
<return> jump(pop)

cond:0 = esi == 0
eax = [0x10009f24].d
ecx = eax
if (cond:0) then 16 @ 0x3581 else 27 @ 0x357b

push(ebx)
ebx = eax + ecx - 1
eax = eax - 1
push(zx.d(4))
eax = not.d(eax)
push(0x3000)
ebx = ebx & eax
push(ebx)
push(zx.d(0))
call([0x10008034].d), esp += 0x10
if (eax == 0) then 29 @ 0x35c3 else 33 @ 0x35a4

ecx = esi + 0x250
goto 16 @ 0x3581

ebx = pop
eax = edi
edi = pop
<return> jump(pop)

if (eax == -1) then 29 @ 0x35c3 else 34 @ 0x35a6

call(sub_2da0)
noreturn
{ Does not return }

int32_t __convention("regparm") sub_35d0(int32_t arg1, int32_t arg2, void* arg3)
push(ecx)
push(ebx)
push(esi)
esi = eax
eax = [0x10009f1c].d
push(edi)
edi = 0
cond:0 = eax != 0
ebx = ecx
[esp + 0xc {var_4}].d = edi
if (cond:0) then 11 @ 0x35ef else 12 @ 0x35e7

if (esi u>= -0x40) then 14 @ 0x369b else 22 @ 0x35f5

call(sub_34b0)
goto 11 @ 0x35ef

eax = 0
cond:1 = edi != 0
edi = pop
esi = pop
al = cond:1
ebx = pop
ecx = pop
<return> jump(pop)

push(ebp)
ebp = [ebx + 0x18].d
if (ebp == 0) then 25 @ 0x369a else 27 @ 0x3601

ebp = pop
goto 14 @ 0x369b

eax = [ebx + 0xc].d
esi = esi + 0x28
if (eax u<= esi) then 30 @ 0x367e else 35 @ 0x360b

call(sub_2e90)
edi = [esp + 0x10 {var_4}].d
temp3.d = edi
edi = edi + eax
if (temp3.d != neg.d(eax)) then 25 @ 0x369a else 53 @ 0x368b

ecx = [0x10009f24].d
eax = eax - esi
eax = eax + ecx - 1
edx = 0
temp2.d = ecx
temp0.d = divu.dp.d(edx:eax, temp2.d)
temp1.d = modu.dp.d(edx:eax, temp2.d)
eax = temp0.d
edx = temp1.d
edx = ebp
edi = eax
edi = edi - 1
eax = ebx
edi = edi * ecx
call(sub_2a70)
esi = eax
eax = [esi + 0xc].d
if ((al & 8) != 0) then 30 @ 0x367e else 55 @ 0x3637

ecx = [ebx + 0xc].d
if (ecx u<= [ebx + 0x1c].d) then 25 @ 0x369a else 56 @ 0x3693

if ((al & 1) == 0) then 30 @ 0x367e else 58 @ 0x3639

[ebx + 0x1c].d = -1
goto 25 @ 0x369a

ebp = [esi + 4].d
if (ebp u< edi) then 30 @ 0x367e else 60 @ 0x3640

edx = esi
eax = ebx
call(sub_2a40)
if (eax != 0) then 30 @ 0x367e else 64 @ 0x364d

ecx = [esi].d
ebp = ebp - edi
ecx = ecx + ebp
eax = edi
call(sub_2b60)
if (eax != 0) then 30 @ 0x367e else 70 @ 0x365e

cond:2 = edi == 0
[esp + 0x10 {var_4}].d = edi
if (cond:2) then 30 @ 0x367e else 73 @ 0x3666

[esi + 4].d = [esi + 4].d - edi
edx = [ebx + 0xc].d
ecx = [ebx + 0x18].d
[ebx + 0x1b0].d = [ebx + 0x1b0].d - edi
edx = edx - edi
esi = ebx
call(sub_29e0)
goto 30 @ 0x367e

void* __convention("regparm") sub_36b0(int32_t* arg1, void* arg2)
push(ebx)
push(esi)
esi = eax
eax = [0x10009f1c].d
cond:0 = eax != 0
push(edi)
if (cond:0) then 7 @ 0x36c3 else 10 @ 0x36be

cond:1 = ([esi + 0x1b8].b & 1) == 0
ebx = [esp + 0x10 {arg2}].d
if (cond:1) then 12 @ 0x36ef else 19 @ 0x36d6

call(sub_34b0)
goto 7 @ 0x36c3

eax = [0x10009f24].d
push(ebp)
ebp = eax + ebx + 0x2f
eax = eax - 1
eax = not.d(eax)
ebp = ebp & eax
if (ebp u<= ebx) then 20 @ 0x38cc else 23 @ 0x3708

if (ebx u< [0x10009f28].d) then 12 @ 0x36ef else 30 @ 0x36dc

eax = 0
ebp = pop
goto 31 @ 0x38cf

push(zx.d(4))
push(0x3000)
push(ebp)
push(zx.d(0))
call([0x10008034].d), esp += 0x10
edx = eax
if (edx == 0) then 20 @ 0x38cc else 35 @ 0x3725

if ([esi + 0xc].d == 0) then 12 @ 0x36ef else 36 @ 0x36de

edi = pop
esi = pop
ebx = pop
<return> jump(pop)

if (edx == -1) then 20 @ 0x38cc else 40 @ 0x372b

eax = ebx
edi = esi
call(sub_3410)
if (eax != 0) then 31 @ 0x38cf else 12 @ 0x36ef

[esi + 0x1b0].d = [esi + 0x1b0].d + ebp
eax = [esi + 0x1b0].d
if (eax u<= [esi + 0x1b4].d) then 43 @ 0x3745 else 45 @ 0x373f

ebx = [esi + 0x18].d
if (ebx != 0) then 47 @ 0x37e0 else 49 @ 0x3750

[esi + 0x1b4].d = eax
goto 43 @ 0x3745

ecx = esi + 0x1bc
if (ecx == 0) then 51 @ 0x3803 else 52 @ 0x37ea

eax = [esi + 0x10].d
if (eax == 0) then 54 @ 0x375b else 56 @ 0x3759

if (edx u>= [esi + 0x10].d) then 57 @ 0x3808 else 59 @ 0x3805

ebx = ebx
goto 61 @ 0x37f0

[esi + 0x10].d = edx
goto 64 @ 0x375e

if (edx u>= eax) then 64 @ 0x375e else 54 @ 0x375b

eax = esi + 0x1bc
if (eax == 0) then 74 @ 0x3824 else 81 @ 0x3812

[esi + 0x10].d = edx
goto 57 @ 0x3808

eax = [ecx + 4].d
eax = eax + [ecx].d
if (edx == eax) then 83 @ 0x386c else 85 @ 0x37f9

ecx = [0x10009f1c].d
[esi + 0x24].d = ecx
[esi + 0x1bc].d = edx
[esi + 0x1c0].d = ebp
[esi + 0x1c8].d = 1
[esi + 0x20].d = 0xfff
eax = esi + 0x28
ecx = 0x20
esp = esp
goto 87 @ 0x3790

push(zx.d(1))
push(ebp)
push(edx)
eax = esi
call(sub_3170)
esp = esp + 0xc
goto 93 @ 0x3832

ecx = edx + ebp
goto 96 @ 0x3817

eax = [ecx + 0xc].d
if ((al & 8) != 0) then 51 @ 0x3803 else 97 @ 0x3875

ecx = [ecx + 8].d
if (ecx != 0) then 61 @ 0x37f0 else 51 @ 0x3803

[eax + 0xc].d = eax
[eax + 8].d = eax
eax = eax + 8
temp0.d = ecx
ecx = ecx - 1
if (temp0.d != 1) then 87 @ 0x3790 else 98 @ 0x379e

eax = [esi + 0xc].d
edi = [esp + 0x14 {arg2}].d
if (edi u>= eax) then 20 @ 0x38cc else 107 @ 0x3841

if ([eax].d == ecx) then 125 @ 0x389e else 127 @ 0x381d

if ((al & 1) == 0) then 51 @ 0x3803 else 129 @ 0x3877

eax = [esi - 4].d
eax = eax & 0xfffffff8
edi = eax + esi - 8
edx = edx - edi
ecx = edi
ecx = ecx & 7
cond:2 = ecx == 0
eax = edx + ebp - 0x28
if (cond:2) then 131 @ 0x37ba else 142 @ 0x37b5

ecx = [esi + 0x18].d
eax = eax - edi
[esi + 0xc].d = eax
edx = ecx + edi
eax = eax | 1
[esi + 0x18].d = edx
[edx + 4].d = eax
eax = [0x10009f1c].d
edi = edi | 3
ebp = pop
[ecx + 4].d = edi
eax = eax ^ esi
edi = pop
esi = pop
[edx].d = eax
eax = ecx + 8
ebx = pop
<return> jump(pop)

ecx = [eax + 0xc].d
if ((cl & 8) != 0) then 74 @ 0x3824 else 145 @ 0x38ad

eax = [eax + 8].d
if (eax != 0) then 96 @ 0x3817 else 74 @ 0x3824

eax = [ecx].d
if (ebx u< eax) then 51 @ 0x3803 else 146 @ 0x387d

edx = ecx + edi
eax = eax - ecx
ecx = eax
[esi + 0x18].d = edx
[esi + 0xc].d = eax
ecx = ecx | 1
[edx + 4].d = ecx
[edx + eax + 4].d = 0x28
edx = [0x10009f2c].d
[esi + 0x1c].d = edx
goto 93 @ 0x3832

ecx = neg.d(ecx)
ecx = ecx & 7
goto 131 @ 0x37ba

if ((cl & 1) == 0) then 74 @ 0x3824 else 149 @ 0x38b3

edi = [ecx + 4].d
eax = eax + edi
if (ebx u>= eax) then 51 @ 0x3803 else 161 @ 0x388a

ecx = [eax].d
[eax + 4].d = [eax + 4].d + ebp
[eax].d = edx
eax = [esp + 0x14 {arg2}].d
push(esi)
call(sub_2600)
esp = esp + 4
ebp = pop
edi = pop
esi = pop
ebx = pop
<return> jump(pop)

edi = edi + ebp
[ecx + 4].d = edi
edx = [esi + 0xc].d
ecx = [esi + 0x18].d
edx = edx + ebp
call(sub_29e0)
goto 93 @ 0x3832

int32_t* const sub_38e0()
eax = [0x10009f1c].d
esp = esp - 0xc
if (eax != 0) then 3 @ 0x38f1 else 6 @ 0x38ec

cond:0 = ([ebx + 0x1b8 {&data_1b8}].b & 2) == 0
push(esi)
if (cond:0) then 8 @ 0x390e else 15 @ 0x38fb

call(sub_34b0)
goto 3 @ 0x38f1

push(ebp)
eax = 0
ebp = 0
cond:1 = [ebx + 0x18 {sub_18}].d == ebp
push(edi)
[esp + 0xc {var_c_1}].d = eax
if (cond:1) then 18 @ 0x3998 else 46 @ 0x391d

esi = ebx + 0x1cc
call(sub_2b00)
if (eax != 0) then 55 @ 0x3a00 else 8 @ 0x390e

esi = [0x10008080].d
push(eax)
push(0x10008148)
call(esi)
edi = [0x10008084].d
eax = eax + 0x40
push(eax)
call(edi)
eax = [esp + 0x18 {var_c_1}].d
esp = esp + 0xc
push(eax)
push(0x10008164)
call(esi)
eax = eax + 0x40
push(eax)
call(edi)
esp = esp + 0xc
push(ebp)
push(0x10008180)
call(esi)
eax = eax + 0x40
push(eax)
call(edi)
esp = esp + 0xc
cond:2 = ([ebx + 0x1b8 {&data_1b8}].b & 2) == 0
edi = pop
ebp = pop
if (cond:2) then 55 @ 0x3a00 else 58 @ 0x39e6

ebp = [ebx + 0x1b0 {&data_1b0}].d
eax = [ebx + 0x1b4 {&data_1b4}].d
[esp + 0xc {var_c_1}].d = ebp
ebp = ebp - [ebx + 0xc {&data_c}].d
edi = ebx + 0x1bc
ebp = ebp - 0x28
cond:3 = edi == 0
[esp + 0x14 {var_4}].d = eax
if (cond:3) then 18 @ 0x3998 else 63 @ 0x3941

esi = pop
esp = esp + 0xc
<return> jump(pop)

temp1.d = [ebx + 0x210 {&data_210}].d
[ebx + 0x210 {&data_210}].d = [ebx + 0x210 {&data_210}].d - 1
cond:4 = temp1.d != 1
eax = ebx + 0x1cc
if (cond:4) then 55 @ 0x3a00 else 67 @ 0x39f5

esi = [edi].d
eax = esi
eax = eax & 7
if (eax == 0) then 73 @ 0x394f else 75 @ 0x394a

[eax + 0x48 {&data_214}].d = 0
ecx = 0
temp0.d = [eax {&data_1cc}].d
[eax {&data_1cc}].d = ecx
ecx = temp0.d
goto 55 @ 0x3a00

ecx = esi + eax
if (ecx u< esi) then 78 @ 0x398d else 80 @ 0x3956

eax = neg.d(eax)
eax = eax & 7
goto 73 @ 0x394f

edi = [edi + 8].d
if (edi != 0) then 63 @ 0x3941 else 84 @ 0x3994

edx = [edi + 4].d
edx = edx + esi
[esp + 0x10 {var_8_1}].d = edx
goto 86 @ 0x3964

eax = [esp + 0x14 {var_4}].d
goto 18 @ 0x3998

if (ecx u>= [esp + 0x10 {var_8_1}].d) then 78 @ 0x398d else 87 @ 0x3969

if (ecx == [ebx + 0x18 {sub_18}].d) then 78 @ 0x398d else 88 @ 0x396b

eax = [ecx + 4].d
if (eax == 7) then 78 @ 0x398d else 90 @ 0x3973

edx = eax
dl = dl & 3
if (dl != 1) then 93 @ 0x3984 else 96 @ 0x397d

eax = eax & 0xfffffff8
ecx = ecx + eax
if (ecx u>= esi) then 86 @ 0x3964 else 78 @ 0x398d

edx = eax
edx = edx & 0xfffffff8
ebp = ebp - edx
goto 93 @ 0x3984

int32_t* sub_3a10(int32_t* arg1 @ edi, void* arg2)
eax = [0x10009f1c].d
esp = esp - 0x14
push(ebx)
ebx = 0
cond:0 = eax != 0
push(ebp)
push(esi)
[edi].d = ebx
[edi + 4].d = ebx
[edi + 8].d = ebx
[edi + 0xc].d = ebx
[edi + 0x10].d = ebx
[edi + 0x14].d = ebx
[edi + 0x18].d = ebx
[edi + 0x1c].d = ebx
[edi + 0x20].d = ebx
[edi + 0x24].d = ebx
if (cond:0) then 18 @ 0x3a43 else 20 @ 0x3a3e

ebp = [esp + 0x24 {arg2}].d
if (([ebp + 0x1b8].b & 2) == 0) then 22 @ 0x3a63 else 26 @ 0x3a50

call(sub_34b0)
goto 18 @ 0x3a43

eax = [ebp + 0x18].d
cond:1 = eax == ebx
[esp + 0x1c {var_4_1}].d = eax
if (cond:1) then 29 @ 0x3b36 else 30 @ 0x3a72

esi = ebp + 0x1cc
call(sub_2b00)
if (eax != ebx) then 39 @ 0x3b4e else 22 @ 0x3a63

if (([ebp + 0x1b8].b & 2) == 0) then 39 @ 0x3b4e else 45 @ 0x3b38

eax = [ebp + 0xc].d
ebx = ebp + 0x1bc
cond:2 = ebx == 0
ecx = eax + 0x28
[esp + 0x14 {var_c_1}].d = 1
[esp + 0x10 {var_10_1}].d = ecx
edx = ecx
[esp + 0xc {i_1}].d = ebx
if (cond:2) then 50 @ 0x3b00 else 66 @ 0x3a94

esi = pop
ebp = pop
eax = edi
ebx = pop
esp = esp + 0x14
<return> jump(pop)

temp1.d = [ebp + 0x210].d
[ebp + 0x210].d = [ebp + 0x210].d - 1
cond:3 = temp1.d != 1
eax = ebp + 0x1cc
if (cond:3) then 39 @ 0x3b4e else 70 @ 0x3b47

eax = [esp + 0x14 {var_c_1}].d
[edi + 4].d = eax
eax = [ebp + 0x1b0].d
esi = eax
eax = eax - ecx
esi = esi - edx
[edi].d = edx
edx = [ebp + 0x1b4].d
[edi + 0x1c].d = eax
eax = [ebp + 0xc].d
[edi + 0x10].d = esi
[edi + 0x14].d = edx
[edi + 0x20].d = ecx
[edi + 0x24].d = eax
ebx = 0
goto 29 @ 0x3b36

ebp = [ebx].d
eax = ebp
eax = eax & 7
if (eax == 0) then 76 @ 0x3aa2 else 78 @ 0x3a9d

[eax + 0x48].d = ebx
ecx = 0
temp0.d = [eax].d
[eax].d = ecx
ecx = temp0.d
goto 39 @ 0x3b4e

esi = eax + ebp
if (esi u< ebp) then 81 @ 0x3aed else 85 @ 0x3aa9

eax = neg.d(eax)
eax = eax & 7
goto 76 @ 0x3aa2

ebx = [ebx + 8].d
cond:4 = ebx != 0
[esp + 0xc {i_1}].d = ebx
if (cond:4) then 66 @ 0x3a94 else 89 @ 0x3af8

ecx = [ebx + 4].d
ecx = ecx + ebp
[esp + 0x18 {var_8_1}].d = ecx
goto 92 @ 0x3ab6

ebp = [esp + 0x24 {arg2}].d
ecx = [esp + 0x10 {var_10_1}].d
goto 50 @ 0x3b00

if (esi u>= [esp + 0x18 {var_8_1}].d) then 81 @ 0x3aed else 93 @ 0x3abc

if (esi == [esp + 0x1c {var_4_1}].d) then 81 @ 0x3aed else 94 @ 0x3abe

ecx = [esi + 4].d
if (ecx == 7) then 81 @ 0x3aed else 96 @ 0x3ac6

eax = ecx
eax = eax & 0xfffffff8
ebx = ecx
bl = bl & 3
edx = edx + eax
if (bl != 1) then 102 @ 0x3ae0 else 106 @ 0x3ad7

ebx = [esp + 0xc {i_1}].d
ecx = ecx & 0xfffffff8
esi = esi + ecx
if (esi u>= ebp) then 92 @ 0x3ab6 else 81 @ 0x3aed

[esp + 0x10 {var_10_1}].d = [esp + 0x10 {var_10_1}].d + eax
[esp + 0x14 {var_c_1}].d = [esp + 0x14 {var_c_1}].d + 1
goto 102 @ 0x3ae0

int32_t sub_3b60(int32_t arg1 @ esi, int32_t arg2 @ edi)
eax = [0x10009f1c].d
if (eax != 0) then 2 @ 0x3b71 else 3 @ 0x3b69

if (esi != -1) then 5 @ 0x3b77 else 7 @ 0x3b73

call(sub_34b0)
goto 2 @ 0x3b71

eax = esi
goto 9 @ 0x3b7c

eax = eax | esi
goto 9 @ 0x3b7c

if (edi == -3) then 10 @ 0x3bb0 else 13 @ 0x3b81

[0x10009f28].d = eax
eax = 1
<return> jump(pop)

if (edi == -2) then 14 @ 0x3b99 else 15 @ 0x3b86

if (eax u< [0x10009f20].d) then 16 @ 0x3bad else 18 @ 0x3b9b

if (edi != -1) then 16 @ 0x3bad else 20 @ 0x3b88

eax = 0
<return> jump(pop)

ecx = eax - 1
if ((eax & ecx) != 0) then 16 @ 0x3bad else 23 @ 0x3ba2

[0x10009f2c].d = eax
eax = 1
<return> jump(pop)

[0x10009f24].d = eax
eax = 1
<return> jump(pop)

int32_t sub_3bc0(void* arg1, int32_t* arg2, int32_t* arg3, int32_t arg4)
eax = [esp + 0xc {arg3}].d
push(ebx)
push(ebp)
ebp = [esp + 0xc {arg1}].d
push(esi)
push(edi)
edi = [eax].d
edi = edi + 1
cond:0 = [ebp + (edi << 2) + 0x458].d == 0
ebx = ebp + (edi << 2) + 0x458
esi = edi
if (cond:0) then 12 @ 0x3c32 else 15 @ 0x3be4

ecx = [esp + 0x1c {arg3}].d
esi = 0
if ([ecx].d s<= esi) then 17 @ 0x3ca9 else 18 @ 0x3c3c

eax = ebx
goto 21 @ 0x3bf0

if (edi s>= [ebp + 0x50].d) then 25 @ 0x3d82 else 38 @ 0x3caf

edx = ebp + 0x458
[esp + 0x14 {arg1}].d = edx
goto 40 @ 0x3c46

edi = [eax].d
ecx = [edi + 0x1cc].d
edi = edi + 0x1cc
if (ecx == 0) then 43 @ 0x3c16 else 49 @ 0x3c02

edx = [esp + 0x1c {arg3}].d
eax = [edx].d
esi = [ebp + (eax << 2) + 0x458].d
esi = esi + 0x1cc
call(sub_2b00)
ecx = [esp + 0x1c {arg3}].d
edx = [ecx].d
eax = [ebp + (edx << 2) + 0x458].d
edi = pop
esi = pop
ebp = pop
ebx = pop
<return> jump(pop)

edx = [0x10009f1c].d
if (edx != 0) then 51 @ 0x3cbe else 55 @ 0x3cb9

eax = [esp + 0x14 {arg1}].d
ebx = [eax].d
if (ebx == 0) then 17 @ 0x3ca9 else 57 @ 0x3c50

edx = 1
eax = edi
temp0.d = [eax].d
[eax].d = edx
edx = temp0.d
if (edx == 0) then 60 @ 0x3c74 else 64 @ 0x3c23

call([0x10008018].d)
if ([edi + 0x48].d != eax) then 64 @ 0x3c23 else 70 @ 0x3c0d

ecx = [esp + 0x20 {arg4}].d
eax = 0xfffffdb0
eax = eax - [0x10009f20].d
if (ecx u>= eax) then 25 @ 0x3d82 else 72 @ 0x3cd5

call(sub_34b0)
goto 51 @ 0x3cbe

ecx = [ebx + 0x1cc].d
ebx = ebx + 0x1cc
if (ecx == 0) then 75 @ 0x3c89 else 81 @ 0x3c60

call([0x10008018].d)
[edi + 0x48].d = eax
[edi + 0x44].d = 1
goto 83 @ 0x3dd3

ebx = ebx + 4
esi = esi + 1
cond:1 = [ebx].d != 0
edi = esi
eax = ebx
if (cond:1) then 21 @ 0x3bf0 else 12 @ 0x3c32

[edi + 0x44].d = [edi + 0x44].d + 1
goto 83 @ 0x3dd3

cond:2 = ecx != 0
eax = [0x10009f24].d
if (cond:2) then 88 @ 0x3cf7 else 90 @ 0x3cde

edx = 1
eax = ebx
temp0.d = [eax].d
[eax].d = edx
edx = temp0.d
if (edx == 0) then 92 @ 0x3ce2 else 96 @ 0x3c96

call([0x10008018].d)
if ([ebx + 0x48].d != eax) then 96 @ 0x3c96 else 100 @ 0x3c6b

eax = [esp + 0x18 {arg2}].d
cond:3 = eax == 0
edx = [esp + 0x1c {arg3}].d
[edx].d = esi
if (cond:3) then 102 @ 0x3def else 109 @ 0x3de1

ecx = ecx + 0x250
goto 116 @ 0x3cfd

ecx = eax
goto 116 @ 0x3cfd

call([0x10008018].d)
[ebx + 0x48].d = eax
[ebx + 0x44].d = 1
goto 83 @ 0x3dd3

ecx = [esp + 0x1c {arg3}].d
[esp + 0x14 {arg1}].d = [esp + 0x14 {arg1}].d + 4
esi = esi + 1
if (esi s< [ecx].d) then 40 @ 0x3c46 else 17 @ 0x3ca9

[ebx + 0x44].d = [ebx + 0x44].d + 1
goto 83 @ 0x3dd3

ecx = [ebp + 0x454].d
eax = eax | 0xffffffff
eax = eax - esi
push(eax)
push(ecx)
call([0x10008030].d), esp += 8
if (eax != 0) then 126 @ 0x3e0c else 132 @ 0x3e06

edi = pop
[eax].d = esi
eax = [ebp + (esi << 2) + 0x458].d
esi = pop
ebp = pop
ebx = pop
<return> jump(pop)

ebx = eax + ecx - 1
eax = eax - 1
push(zx.d(4))
eax = not.d(eax)
push(0x3000)
ebx = ebx & eax
push(ebx)
push(zx.d(0))
call([0x10008034].d), esp += 0x10
if (eax == 0) then 25 @ 0x3d82 else 134 @ 0x3d1f

eax = [ebp + (esi << 2) + 0x458].d
edi = pop
esi = pop
ebp = pop
ebx = pop
<return> jump(pop)

call([0x100080ec].d)
goto 126 @ 0x3e0c

if (eax == -1) then 25 @ 0x3d82 else 135 @ 0x3d21

call(sub_2da0)
noreturn
{ Does not return }

int32_t sub_3e20(int32_t arg1 @ esi, int32_t arg2 @ edi)
eax = [0x10009f1c].d
if (eax != 0) then 2 @ 0x3e31 else 3 @ 0x3e29

if (esi != -1) then 5 @ 0x3e37 else 7 @ 0x3e33

call(sub_34b0)
goto 2 @ 0x3e31

eax = esi
goto 9 @ 0x3e3c

eax = eax | esi
goto 9 @ 0x3e3c

if (edi == -3) then 10 @ 0x3e70 else 13 @ 0x3e41

[0x10009f28].d = eax
eax = 1
<return> jump(pop)

if (edi == -2) then 14 @ 0x3e59 else 15 @ 0x3e46

if (eax u< [0x10009f20].d) then 16 @ 0x3e6d else 18 @ 0x3e5b

if (edi != -1) then 16 @ 0x3e6d else 20 @ 0x3e48

eax = 0
<return> jump(pop)

ecx = eax - 1
if ((eax & ecx) != 0) then 16 @ 0x3e6d else 23 @ 0x3e62

[0x10009f2c].d = eax
eax = 1
<return> jump(pop)

[0x10009f24].d = eax
eax = 1
<return> jump(pop)

int32_t __convention("regparm") sub_3e80(void* arg1)
esp = esp - 0x2c
push(esi)
esi = eax
eax = [0x10009f1c].d
cond:0 = [esi + 0x24].d == eax
push(edi)
if (cond:0) then 7 @ 0x3e97 else 15 @ 0x3e91

push(esi)
edi = esp + 0xc {var_2c}
call(sub_3a10)
esi = eax
esp = esp + 4
ecx = 0xa
edi = ebx
if (flag:d) then 17 else 19

call([0x100080ec].d)
goto 7 @ 0x3e97

edi, esi, ecx = __memcpy_u32(edi - (ecx << 2), esi - (ecx << 2), ecx << 2)
goto 21 @ 0x3eaf

edi, esi, ecx = __memcpy_u32(edi, esi, ecx << 2)
goto 21 @ 0x3eaf

edi = pop
eax = ebx
esi = pop
esp = esp + 0x2c
<return> jump(pop)

int32_t* __convention("regparm") sub_3ec0(void* arg1)
push(ebx)
ebx = eax
eax = [0x10009f1c].d
if ([ebx + 0x24].d != eax) then 4 @ 0x3ed4 else 6 @ 0x3ecd

ebx = pop
jump([0x100080ec].d)

call(sub_38e0)
ebx = pop
<return> jump(pop)

int32_t sub_3ee0(void* arg1 @ edi, int32_t arg2)
eax = [0x10009f1c].d
push(ebp)
ebp = 0
if ([edi + 0x24].d != eax) then 4 @ 0x3f33 else 6 @ 0x3ef4

call([0x100080ec].d)
goto 7 @ 0x3f39

if (([edi + 0x1b8].b & 2) == 0) then 9 @ 0x3f07 else 13 @ 0x3ef6

eax = ebp
goto 19 @ 0x3f3b

eax = [esp + 8 {arg2}].d
ecx = edi
call(sub_35d0)
if (([edi + 0x1b8].b & 2) == 0) then 19 @ 0x3f3b else 21 @ 0x3f1b

push(esi)
esi = edi + 0x1cc
call(sub_2b00)
cond:0 = eax != ebp
esi = pop
if (cond:0) then 7 @ 0x3f39 else 9 @ 0x3f07

ebp = pop
<return> jump(pop)

temp1.d = [edi + 0x210].d
[edi + 0x210].d = [edi + 0x210].d - 1
cond:1 = temp1.d != 1
ecx = edi + 0x1cc
if (cond:1) then 19 @ 0x3f3b else 26 @ 0x3f2a

[ecx + 0x48].d = ebp
edx = 0
temp0.d = [ecx].d
[ecx].d = edx
edx = temp0.d
ebp = pop
<return> jump(pop)

void __convention("regparm") sub_3f40(int32_t* arg1)
esp = esp - 0xc
push(edi)
edi = eax
if (edi == 0) then 4 @ 0x44ee else 7 @ 0x3f4e

edi = pop
esp = esp + 0xc
<return> jump(pop)

eax = [edi - 4].d
edi = edi - 8
eax = eax & 0xfffffff8
push(ebx)
ebx = [0x10009f1c].d
ebx = ebx ^ [eax + edi].d
eax = eax + edi
eax = [0x10009f1c].d
if ([ebx + 0x24].d == eax) then 16 @ 0x3f78 else 19 @ 0x3f6d

cond:0 = ([ebx + 0x1b8].b & 2) == 0
push(esi)
if (cond:0) then 23 @ 0x3f95 else 26 @ 0x3f82

ebx = pop
edi = pop
esp = esp + 0xc
jump([0x100080ec].d)

cond:1 = edi u< [ebx + 0x10].d
push(ebp)
if (cond:1) then 29 @ 0x44c5 else 31 @ 0x3f9f

esi = ebx + 0x1cc
call(sub_2b00)
if (eax != 0) then 35 @ 0x44ec else 23 @ 0x3f95

call([0x100080ec].d)
goto 38 @ 0x44cb

eax = [edi + 4].d
ecx = eax
ecx = ecx & 3
if (ecx == 1) then 29 @ 0x44c5 else 41 @ 0x3fb0

esi = pop
ebx = pop
goto 4 @ 0x44ee

cond:5 = ([ebx + 0x1b8].b & 2) == 0
ebp = pop
if (cond:5) then 35 @ 0x44ec else 47 @ 0x44d5

ebp = eax
ebp = ebp & 0xfffffff8
cond:2 = (al & 1) != 0
edx = edi + ebp
[esp + 0x10 {var_c_1}].d = edx
if (cond:2) then 51 @ 0x4027 else 53 @ 0x3fc0

ebx = ebx + 0x1cc
temp1.d = [ebx + 0x44].d
[ebx + 0x44].d = [ebx + 0x44].d - 1
if (temp1.d != 1) then 35 @ 0x44ec else 56 @ 0x44e1

edx = [esp + 0x10 {var_c_1}].d
if (edi u>= edx) then 29 @ 0x44c5 else 62 @ 0x4033

cond:3 = ecx != 0
eax = [edi].d
if (cond:3) then 64 @ 0x3fe8 else 70 @ 0x3fc6

[ebx + 0x48].d = 0
edx = 0
temp0.d = [ebx].d
[ebx].d = edx
edx = temp0.d
goto 35 @ 0x44ec

eax = [edx + 4].d
if ((al & 1) == 0) then 29 @ 0x44c5 else 76 @ 0x4040

esi = [ebx + 0x10].d
edi = edi - eax
ebp = ebp + eax
cond:4 = edi u< esi
[esp + 0x14 {i_1}].d = ebp
if (cond:4) then 29 @ 0x44c5 else 77 @ 0x3ffe

esi = eax + ebp + 0x10
ecx = edi
ecx = ecx - eax
eax = esi
call(sub_2b60)
if (eax != 0) then 38 @ 0x44cb else 78 @ 0x3fdd

if ((al & 2) != 0) then 80 @ 0x4366 else 87 @ 0x4049

if (edi == [ebx + 0x14].d) then 88 @ 0x41b7 else 91 @ 0x4004

[ebx + 0x1b0].d = [ebx + 0x1b0].d - esi
goto 38 @ 0x44cb

eax = eax & 0xfffffffe
ecx = ebp
[edx + 4].d = eax
ecx = ecx | 1
[edi + 4].d = ecx
[edi + ebp].d = ebp
goto 93 @ 0x4377

if (edx != [ebx + 0x18].d) then 96 @ 0x41df else 97 @ 0x404f

eax = [edx + 4].d
eax = eax & 3
if (al != 3) then 51 @ 0x4027 else 104 @ 0x41c5

eax = eax u>> 3
if (eax u>= 0x20) then 111 @ 0x40ab else 116 @ 0x4010

ecx = ebp
ecx = ecx u>> 3
if (ecx u>= 0x20) then 119 @ 0x43db else 122 @ 0x4381

if (edx != [ebx + 0x14].d) then 128 @ 0x41fa else 133 @ 0x41e1

[ebx + 0xc].d = [ebx + 0xc].d + ebp
eax = [ebx + 0xc].d
edx = eax
edx = edx | 1
[ebx + 0x18].d = edi
[edi + 4].d = edx
if (edi != [ebx + 0x14].d) then 141 @ 0x4070 else 142 @ 0x4065

[ebx + 8].d = ebp
[edx + 4].d = [edx + 4].d & 0xfffffffe
ecx = ebp
ecx = ecx | 1
[edi + 4].d = ecx
[edi + ebp].d = ebp
goto 38 @ 0x44cb

esi = [edi + 0xc].d
cond:6 = esi == edi
edx = [edi + 0x18].d
[esp + 0x18 {var_4_1}].d = edx
if (cond:6) then 146 @ 0x40c9 else 150 @ 0x40b9

ecx = [edi + 8].d
edx = [edi + 0xc].d
if (ecx != edx) then 152 @ 0x4084 else 154 @ 0x401a

eax = ebp
eax = eax u>> 8
if (eax != 0) then 160 @ 0x43eb else 161 @ 0x43e2

eax = 1
eax = eax << cl
esi = ebx + (ecx << 3) + 0x28
ecx = [ebx].d
ebp = esi
if ((ecx & eax) != 0) then 163 @ 0x43a9 else 165 @ 0x4394

eax = eax & 0xfffffff8
ecx = eax
ecx = ecx u>> 3
ebp = ebp + eax
if (ecx u>= 0x20) then 172 @ 0x424c else 178 @ 0x4209

[ebx + 8].d = [ebx + 8].d + ebp
eax = [ebx + 8].d
ecx = eax
[ebx + 0x14].d = edi
ecx = ecx | 1
[edi + 4].d = ecx
[eax + edi].d = eax
goto 38 @ 0x44cb

if (eax u<= [ebx + 0x1c].d) then 38 @ 0x44cb else 181 @ 0x4076

ecx = 0
[ebx + 0x14].d = ecx
[ebx + 8].d = ecx
goto 141 @ 0x4070

esi = [edi + 0x14].d
cond:7 = esi != 0
ecx = edi + 0x14
if (cond:7) then 185 @ 0x40e0 else 188 @ 0x40d3

eax = [edi + 8].d
if (eax u< [ebx + 0x10].d) then 192 @ 0x4105 else 195 @ 0x40c1

eax = ebx + (eax << 3) + 0x28
if (ecx == eax) then 198 @ 0x4092 else 199 @ 0x408e

edx = 1
ecx = eax
edx = edx << cl
edx = not.d(edx)
[ebx].d = [ebx].d & edx
goto 51 @ 0x4027

if (eax u<= 0xffff) then 200 @ 0x43f4 else 209 @ 0x43ed

ecx = 0
goto 211 @ 0x440a

eax = [esi + 8].d
if (eax u< [ebx + 0x10].d) then 220 @ 0x43c4 else 226 @ 0x43b1

eax = eax | ecx
[ebx].d = eax
[esi + 8].d = edi
[ebp + 0xc].d = edi
[edi + 8].d = ebp
[edi + 0xc].d = esi
goto 38 @ 0x44cb

eax = edx
esi = [eax + 0xc].d
cond:8 = esi == eax
ecx = [eax + 0x18].d
[esp + 0x18 {var_4_2}].d = ecx
if (cond:8) then 232 @ 0x426c else 236 @ 0x425c

eax = [edx + 8].d
edx = [edx + 0xc].d
if (eax != edx) then 238 @ 0x4223 else 240 @ 0x4213

eax = 0
ecx = ebx
call(sub_35d0)
goto 38 @ 0x44cb

cond:9 = [esi + 0x14].d != 0
eax = esi + 0x14
if (cond:9) then 245 @ 0x40f2 else 248 @ 0x40e9

esi = [edi + 0x10].d
cond:10 = esi == 0
ecx = edi + 0x10
if (cond:10) then 251 @ 0x4111 else 252 @ 0x40dd

call([0x100080ec].d)
edx = [esp + 0x18 {var_4_1}].d
goto 251 @ 0x4111

[eax + 0xc].d = esi
[esi + 8].d = eax
goto 251 @ 0x4111

if (edx == eax) then 254 @ 0x40a0 else 257 @ 0x4096

if (ecx u< esi) then 258 @ 0x4098 else 198 @ 0x4092

edx, eflags = _bit_scan_reverse(eax)
eax = edx
[esp + 0x18 {var_4_3}].d = edx
ecx = eax + 7
edx = ebp
edx = edx u>> cl
edx = edx & 1
ecx = edx + (eax << 1)
goto 211 @ 0x440a

ecx = 0x1f
goto 211 @ 0x440a

eax = 0
[edi + 0x14].d = eax
[edi + 0x10].d = eax
eax = 1
eax = eax << cl
[edi + 0x1c].d = ecx
esi = [ebx + 4].d
edx = ebx + (ecx << 2) + 0x130
if ((esi & eax) != 0) then 260 @ 0x443c else 263 @ 0x442a

call([0x100080ec].d)
[esi + 8].d = edi
[ebp + 0xc].d = edi
[edi + 8].d = ebp
[edi + 0xc].d = esi
goto 38 @ 0x44cb

ebp = eax
[esi + 8].d = edi
[ebp + 0xc].d = edi
[edi + 8].d = ebp
[edi + 0xc].d = esi
goto 38 @ 0x44cb

esi = [eax + 0x14].d
cond:12 = esi != 0
ecx = eax + 0x14
if (cond:12) then 270 @ 0x4280 else 273 @ 0x4276

eax = [eax + 8].d
if (eax u< [ebx + 0x10].d) then 277 @ 0x42a5 else 279 @ 0x4264

ecx = ebx + (ecx << 3) + 0x28
if (eax == ecx) then 282 @ 0x4236 else 283 @ 0x422e

edx = 1
edx = edx << cl
edx = not.d(edx)
[ebx].d = [ebx].d & edx
goto 284 @ 0x434e

esi = [eax].d
ecx = eax
goto 185 @ 0x40e0

cond:13 = [esi + 0x10].d == 0
eax = esi + 0x10
if (cond:13) then 289 @ 0x40fb else 245 @ 0x40f2

if (edx == 0) then 51 @ 0x4027 else 290 @ 0x4117

ecx = ecx
goto 185 @ 0x40e0

[ecx + 0xc].d = edx
[edx + 8].d = ecx
goto 51 @ 0x4027

if (edx u>= esi) then 254 @ 0x40a0 else 258 @ 0x4098

call([0x100080ec].d)
goto 51 @ 0x4027

cond:11 = ecx != 0x1f
eax = [edx].d
if (cond:11) then 294 @ 0x4447 else 298 @ 0x4443

eax = eax | esi
[ebx + 4].d = eax
[edx].d = edi
[edi + 0x18].d = edx
[edi + 0xc].d = edi
[edi + 8].d = edi
goto 300 @ 0x44b8

cond:15 = [esi + 0x14].d != 0
eax = esi + 0x14
if (cond:15) then 303 @ 0x4292 else 306 @ 0x4289

esi = [eax + 0x10].d
cond:16 = esi == 0
ecx = eax + 0x10
if (cond:16) then 309 @ 0x42b0 else 270 @ 0x4280

call([0x100080ec].d)
goto 309 @ 0x42b0

[eax + 0xc].d = esi
[esi + 8].d = eax
goto 309 @ 0x42b0

if (edx == ecx) then 310 @ 0x4241 else 313 @ 0x423b

if (eax u< [ebx + 0x10].d) then 314 @ 0x4348 else 282 @ 0x4236

eax = ebp
eax = eax | 1
[edi + 4].d = eax
[edi + ebp].d = ebp
if (edi != [ebx + 0x14].d) then 93 @ 0x4377 else 316 @ 0x435e

if (ecx u< [ebx + 0x10].d) then 192 @ 0x4105 else 318 @ 0x40fd

eax = [edi + 0x1c].d
cond:14 = edi != [ebx + (eax << 2) + 0x130].d
eax = ebx + (eax << 2) + 0x130
if (cond:14) then 320 @ 0x4147 else 321 @ 0x412a

ecx = ecx u>> 1
esi = 0x19
esi = esi - ecx
goto 324 @ 0x4450

esi = 0
goto 324 @ 0x4450

temp2.d = [ebx + 0x20].d
[ebx + 0x20].d = [ebx + 0x20].d - 1
if (temp2.d != 1) then 38 @ 0x44cb else 330 @ 0x44be

esi = [eax].d
ecx = eax
goto 270 @ 0x4280

cond:19 = [esi + 0x10].d == 0
eax = esi + 0x10
if (cond:19) then 332 @ 0x429b else 303 @ 0x4292

if ([esp + 0x18 {var_4_2}].d == 0) then 284 @ 0x434e else 333 @ 0x42b6

[eax + 0xc].d = edx
[edx + 8].d = eax
goto 284 @ 0x434e

if (edx u< [ebx + 0x10].d) then 314 @ 0x4348 else 310 @ 0x4241

call([0x100080ec].d)
goto 284 @ 0x434e

[ebx + 8].d = ebp
goto 38 @ 0x44cb

[ecx].d = 0
goto 251 @ 0x4111

if (edx u< [ebx + 0x10].d) then 338 @ 0x4158 else 342 @ 0x414c

cond:17 = esi != 0
[eax].d = esi
if (cond:17) then 343 @ 0x4171 else 344 @ 0x4130

ecx = esi
edx = ebp
edx = edx << cl
ecx = [eax + 4].d
ecx = ecx & 0xfffffff8
if (ecx == ebp) then 350 @ 0x447d else 354 @ 0x4460

call(sub_2e90)
goto 38 @ 0x44cb

if (ecx u< [ebx + 0x10].d) then 277 @ 0x42a5 else 360 @ 0x429d

ecx = [esp + 0x10 {var_c_1}].d
edx = [ecx + 0x1c].d
cond:20 = ecx != [ebx + (edx << 2) + 0x130].d
eax = ebx + (edx << 2) + 0x130
if (cond:20) then 362 @ 0x42e4 else 364 @ 0x42cd

call([0x100080ec].d)
edx = [esp + 0x18 {var_4_1}].d
ebp = [esp + 0x14 {i_1}].d
goto 367 @ 0x4168

if ([edx + 0x10].d != edi) then 368 @ 0x4153 else 370 @ 0x414e

if (esi u< [ebx + 0x10].d) then 258 @ 0x4098 else 372 @ 0x4177

ecx = [edi + 0x1c].d
edx = 1
edx = edx << cl
edx = not.d(edx)
[ebx + 4].d = [ebx + 4].d & edx
goto 51 @ 0x4027

edx = [ebx + 0x10].d
cond:18 = eax u< edx
ecx = [eax + 8].d
if (cond:18) then 375 @ 0x44b2 else 377 @ 0x4489

ecx = edx
ecx = ecx u>> 0x1f
esi = eax + (ecx << 2) + 0x10
ecx = [esi].d
edx = edx + edx
if (ecx == 0) then 378 @ 0x44a3 else 379 @ 0x4471

[ecx].d = 0
goto 309 @ 0x42b0

eax = [esp + 0x18 {var_4_2}].d
if (eax u< [ebx + 0x10].d) then 383 @ 0x42fc else 385 @ 0x42f0

cond:21 = esi != 0
[eax].d = esi
if (cond:21) then 386 @ 0x430d else 387 @ 0x42d3

if (esi == 0) then 51 @ 0x4027 else 343 @ 0x4171

[edx + 0x14].d = esi
goto 367 @ 0x4168

[edx + 0x10].d = esi
goto 367 @ 0x4168

[esi + 0x18].d = edx
eax = [edi + 0x10].d
if (eax == 0) then 393 @ 0x4198 else 395 @ 0x4184

call([0x100080ec].d)
goto 300 @ 0x44b8

if (ecx u< edx) then 375 @ 0x44b2 else 396 @ 0x448b

if (esi u< [ebx + 0x10].d) then 375 @ 0x44b2 else 402 @ 0x44a5

eax = ecx
ecx = [eax + 4].d
ecx = ecx & 0xfffffff8
if (ecx != ebp) then 354 @ 0x4460 else 350 @ 0x447d

call([0x100080ec].d)
goto 407 @ 0x4304

if ([eax + 0x10].d != ecx) then 408 @ 0x42f7 else 410 @ 0x42f2

if (esi u< [ebx + 0x10].d) then 314 @ 0x4348 else 412 @ 0x430f

ecx = [ecx + 0x1c].d
eax = 1
eax = eax << cl
eax = not.d(eax)
[ebx + 4].d = [ebx + 4].d & eax
goto 284 @ 0x434e

eax = [edi + 0x14].d
if (eax == 0) then 51 @ 0x4027 else 416 @ 0x41a6

if (eax u< [ebx + 0x10].d) then 417 @ 0x418e else 420 @ 0x4186

[ecx + 0xc].d = edi
[eax + 8].d = edi
[edi + 8].d = ecx
[edi + 0xc].d = eax
[edi + 0x18].d = 0
goto 300 @ 0x44b8

[esi].d = edi
[edi + 0x18].d = eax
[edi + 0xc].d = edi
[edi + 8].d = edi
goto 300 @ 0x44b8

if (esi == 0) then 284 @ 0x434e else 423 @ 0x4306

[eax + 0x14].d = esi
goto 407 @ 0x4304

[eax + 0x10].d = esi
goto 407 @ 0x4304

edx = [esp + 0x18 {var_4_2}].d
[esi + 0x18].d = edx
eax = [ecx + 0x10].d
if (eax == 0) then 425 @ 0x4334 else 427 @ 0x4320

if (eax u< [ebx + 0x10].d) then 258 @ 0x4098 else 428 @ 0x41ac

call([0x100080ec].d)
ebp = [esp + 0x14 {i_1}].d
goto 393 @ 0x4198

[esi + 0x10].d = eax
[eax + 0x18].d = esi
goto 393 @ 0x4198

ecx = [esp + 0x10 {var_c_1}].d
goto 386 @ 0x430d

eax = [ecx + 0x14].d
if (eax == 0) then 284 @ 0x434e else 431 @ 0x433e

if (eax u< [ebx + 0x10].d) then 432 @ 0x432a else 435 @ 0x4322

[esi + 0x14].d = eax
[eax + 0x18].d = esi
goto 51 @ 0x4027

if (eax u< [ebx + 0x10].d) then 314 @ 0x4348 else 438 @ 0x4340

call([0x100080ec].d)
ecx = [esp + 0x10 {var_c_1}].d
goto 425 @ 0x4334

[esi + 0x10].d = eax
[eax + 0x18].d = esi
goto 425 @ 0x4334

[esi + 0x14].d = eax
[eax + 0x18].d = esi
goto 284 @ 0x434e

void* __convention("regparm") sub_4500(int32_t arg1, int32_t arg2, int32_t* arg3)
esp = esp - 0xc
push(ebx)
push(edi)
edi = eax
eax = [0x10009f1c].d
ebx = ecx
if ([ebx + 0x24].d == eax) then 7 @ 0x4521 else 10 @ 0x4513

cond:0 = ([ebx + 0x1b8].b & 2) == 0
push(esi)
if (cond:0) then 16 @ 0x453e else 19 @ 0x452b

call([0x100080ec].d)
edi = pop
eax = 0
ebx = pop
esp = esp + 0xc
<return> jump(pop)

cond:1 = edi u> 0xf0
push(ebp)
if (cond:1) then 22 @ 0x46c9 else 23 @ 0x454e

esi = ebx + 0x1cc
call(sub_2b00)
if (eax != 0) then 24 @ 0x47af else 16 @ 0x453e

if (edi u< -0x40) then 26 @ 0x46d0 else 29 @ 0x46cb

if (edi u>= 7) then 31 @ 0x4557 else 34 @ 0x4550

eax = 0
goto 36 @ 0x47b1

esi = edi + 0xf
esi = esi & 0xfffffff8
if ([ebx + 4].d == 0) then 41 @ 0x46ee else 43 @ 0x46dc

esi = esi | 0xffffffff
goto 41 @ 0x46ee

esi = edi + 0xf
esi = esi & 0xfffffff8
goto 48 @ 0x455d

esi = 0x10
goto 48 @ 0x455d

esi = pop
edi = pop
ebx = pop
esp = esp + 0xc
<return> jump(pop)

edx = [ebx + 8].d
if (esi u> edx) then 55 @ 0x474d else 57 @ 0x46f5

push(esi)
push(ebx)
call(sub_21a0)
esp = esp + 8
goto 61 @ 0x46e8

edx = [ebx].d
edi = esi
edi = edi u>> 3
eax = edx
ecx = edi
eax = eax u>> cl
if ((al & 3) == 0) then 62 @ 0x45d2 else 63 @ 0x456e

eax = [ebx + 0xc].d
if (esi u>= eax) then 72 @ 0x477c else 77 @ 0x4754

ecx = [ebx + 0x14].d
eax = edx
eax = eax - esi
if (eax u< 0x10) then 91 @ 0x4729 else 103 @ 0x4701

if (eax != 0) then 117 @ 0x4787 else 41 @ 0x46ee

if (esi u<= [ebx + 8].d) then 41 @ 0x46ee else 120 @ 0x45da

eax = not.d(eax)
eax = eax & 1
edi = edi + eax
esi = [ebx + (edi << 3) + 0x30].d
ecx = [esi + 8].d
eax = ebx + (edi << 3) + 0x28
cond:2 = eax != ecx
ebp = esi + 8
if (cond:2) then 121 @ 0x459b else 122 @ 0x4587

push(esi)
eax = ebx
call(sub_36b0)
esp = esp + 4
goto 117 @ 0x4787

ecx = [ebx + 0x18].d
eax = eax - esi
[ebx + 0xc].d = eax
edx = ecx + esi
eax = eax | 1
[ebx + 0x18].d = edx
[edx + 4].d = eax
eax = [0x10009f1c].d
esi = esi | 3
eax = eax ^ ebx
[ecx + 4].d = esi
[edx].d = eax
eax = ecx + 8
goto 117 @ 0x4787

eax = 0
[ebx + 8].d = eax
[ebx + 0x14].d = eax
eax = edx
eax = eax | 3
[ecx + 4].d = eax
eax = [0x10009f1c].d
[edx + ecx + 4].d = [edx + ecx + 4].d | 1
eax = eax ^ ebx
[edx + ecx].d = eax
eax = ecx + 8
goto 117 @ 0x4787

edx = ecx + esi
[ebx + 8].d = eax
edi = eax
[ebx + 0x14].d = edx
edi = edi | 1
[edx + 4].d = edi
[edx + eax].d = eax
eax = [0x10009f1c].d
esi = esi | 3
eax = eax ^ ebx
[ecx + 4].d = esi
[edx].d = eax
eax = ecx + 8
goto 117 @ 0x4787

cond:3 = ([ebx + 0x1b8].b & 2) == 0
ebp = pop
if (cond:3) then 36 @ 0x47b1 else 129 @ 0x4791

if (eax == 0) then 133 @ 0x46b9 else 134 @ 0x45e0

if (ecx u< [ebx + 0x10].d) then 152 @ 0x45a5 else 154 @ 0x459d

eax = 1
ecx = edi
eax = eax << cl
eax = not.d(eax)
eax = eax & edx
[ebx].d = eax
goto 157 @ 0x45ab

ebx = ebx + 0x1cc
temp1.d = [ebx + 0x44].d
[ebx + 0x44].d = [ebx + 0x44].d - 1
if (temp1.d != 1) then 36 @ 0x47b1 else 166 @ 0x479d

if ([ebx + 4].d == 0) then 41 @ 0x46ee else 176 @ 0x46bb

ecx = edi
eax = eax << cl
ebp = ebp | 0xffffffff
ebp = ebp << cl
ebp = ebp + ebp
eax = eax & ebp
ecx = eax
ecx = neg.d(ecx)
ecx = ecx & eax
eax, eflags = _bit_scan_forward(ecx)
edi = eax
ebp = [ebx + (edi << 3) + 0x30].d
[esp + 0x10 {var_c_1}].d = eax
eax = ebx + (edi << 3) + 0x28
ecx = ebp + 8
[esp + 0x18 {var_4_1}].d = ecx
ecx = [ecx].d
if (eax != ecx) then 180 @ 0x4625 else 181 @ 0x4611

call([0x100080ec].d)
goto 157 @ 0x45ab

[eax + 8].d = ecx
[ecx + 0xc].d = eax
goto 157 @ 0x45ab

edx = [0x10009f1c].d
ecx = edi << 3
ecx = ecx | 3
[esi + 4].d = ecx
[esi + (edi << 3) + 4].d = [esi + (edi << 3) + 4].d | 1
edx = edx ^ ebx
[esi + (edi << 3)].d = edx
eax = ebp
goto 117 @ 0x4787

[ebx + 0x48].d = 0
ecx = 0
temp0.d = [ebx].d
[ebx].d = ecx
ecx = temp0.d
esi = pop
edi = pop
ebx = pop
esp = esp + 0xc
<return> jump(pop)

push(esi)
call(sub_1f70)
esp = esp + 4
goto 61 @ 0x46e8

if (ecx u< [ebx + 0x10].d) then 188 @ 0x462f else 190 @ 0x4627

eax = 1
ecx = edi
eax = eax << cl
eax = not.d(eax)
eax = eax & edx
[ebx].d = eax
goto 193 @ 0x4635

call([0x100080ec].d)
goto 193 @ 0x4635

[eax + 8].d = ecx
[ecx + 0xc].d = eax
goto 193 @ 0x4635

edx = [0x10009f1c].d
edi = edi + edi
edi = edi + edi
edi = edi + edi
edi = edi - esi
ecx = esi
esi = esi + ebp
ecx = ecx | 3
[ebp + 4].d = ecx
edx = edx ^ ebx
eax = edi
eax = eax | 1
[esi].d = edx
[esi + 4].d = eax
[esi + edi].d = edi
eax = [ebx + 8].d
if (eax == 0) then 210 @ 0x46a6 else 214 @ 0x4663

eax = [esp + 0x18 {var_4_1}].d
[ebx + 8].d = edi
[ebx + 0x14].d = esi
goto 117 @ 0x4787

ecx = [ebx + 0x14].d
eax = eax u>> 3
[esp + 0x14 {var_8_1}].d = ecx
ecx = eax
edx = 1
edx = edx << cl
ebp = ebx + (eax << 3) + 0x28
eax = [ebx].d
if ((edx & eax) != 0) then 223 @ 0x4686 else 225 @ 0x4680

ecx = [ebp + 8].d
if (ecx u>= [ebx + 0x10].d) then 228 @ 0x4696 else 234 @ 0x468e

eax = eax | edx
[ebx].d = eax
goto 236 @ 0x4694

eax = [esp + 0x14 {var_8_1}].d
[ebp + 8].d = eax
[ecx + 0xc].d = eax
[eax + 8].d = ecx
[eax + 0xc].d = ebp
goto 210 @ 0x46a6

call([0x100080ec].d)
goto 236 @ 0x4694

ecx = ebp
goto 228 @ 0x4696

void* __convention("regparm") sub_47c0(void* arg1, int32_t* arg2, int32_t arg3, int32_t* arg4, char arg5)
esp = esp - 0xc
push(esi)
esi = eax
eax = [0x10009f1c].d
if (eax != 0) then 5 @ 0x47d4 else 7 @ 0x47cf

ecx = 0
if (esi == ecx) then 9 @ 0x47f3 else 11 @ 0x47da

call(sub_34b0)
goto 5 @ 0x47d4

eax = [esp + 0x18 {arg3}].d
if (eax != ecx) then 13 @ 0x480a else 19 @ 0x47fb

edx = [esp + 0x18 {arg3}].d
if (edx != ecx) then 24 @ 0x47e9 else 27 @ 0x47e2

edx = [esp + 0x18 {arg3}].d
eax = eax + eax
eax = eax + eax
cond:0 = eax u>= 7
[esp + 4 {var_c}].d = ecx
if (cond:0) then 31 @ 0x4825 else 35 @ 0x481b

ecx = [esp + 0x14 {arg2}].d
eax = 0
esi = pop
esp = esp + 0xc
<return> tailcall(sub_4500)

[esp + 4 {var_c}].d = esi
[esp + 8 {var_8}].d = ecx
goto 37 @ 0x482f

eax = esi
esi = pop
esp = esp + 0xc
<return> jump(pop)

eax = eax + 0xf
eax = eax & 0xfffffff8
[esp + 8 {var_8}].d = eax
goto 37 @ 0x482f

[esp + 8 {var_8}].d = 0x10
goto 37 @ 0x482f

cond:1 = ([esp + 0x20 {arg5}].b & 1) == 0
push(ebp)
if (cond:1) then 40 @ 0x4864 else 44 @ 0x4837

[esp + 0x10 {var_4}].d = ecx
ebp = 0
ebx = ebx
goto 47 @ 0x4870

ecx = [esp + 0x20 {arg4}].d
eax = [ecx].d
if (eax u>= 7) then 50 @ 0x4853 else 56 @ 0x4842

eax = [esp + 0x20 {arg4}].d
eax = [eax + (ecx << 2)].d
if (eax u>= 7) then 60 @ 0x4883 else 63 @ 0x487c

eax = eax + 0xf
eax = eax & 0xfffffff8
ebp = eax
[esp + 0x10 {var_4}].d = eax
ebp = ebp * edx
goto 65 @ 0x4892

[esp + 0x10 {var_4}].d = 0x10
ebp = [esp + 0x10 {var_4}].d
ebp = ebp * edx
goto 65 @ 0x4892

eax = eax + 0xf
eax = eax & 0xfffffff8
goto 80 @ 0x4889

eax = 0x10
goto 80 @ 0x4889

ecx = [esp + 0xc {var_8}].d
push(ebx)
push(edi)
edi = [esp + 0x20 {arg2}].d
eax = [edi + 0x1b8].d
esi = eax
eax = eax & 0xfffffffe
[edi + 0x1b8].d = eax
eax = ecx + ebp - 8
ecx = edi
esi = esi & 1
call(sub_4500)
cond:2 = esi == 0
ebx = eax
if (cond:2) then 83 @ 0x48ca else 84 @ 0x48c1

ecx = ecx + 1
ebp = ebp + eax
if (ecx != edx) then 47 @ 0x4870 else 65 @ 0x4892

if (ebx == 0) then 86 @ 0x48e4 else 93 @ 0x48d3

[edi + 0x1b8].d = [edi + 0x1b8].d | 1
goto 83 @ 0x48ca

edi = pop
ebx = pop
ebp = pop
eax = 0
esi = pop
esp = esp + 0xc
<return> jump(pop)

if (([edi + 0x1b8].b & 2) == 0) then 94 @ 0x48ee else 98 @ 0x48d5

edi = [ebx - 4].d
esi = ebx - 8
edi = edi & 0xfffffff8
if (([esp + 0x2c {arg5}].b & 2) == 0) then 101 @ 0x4913 else 104 @ 0x48fe

esi = edi + 0x1cc
call(sub_2b00)
if (eax == 0) then 94 @ 0x48ee else 86 @ 0x48e4

cond:3 = [esp + 0x10 {var_c}].d != 0
ebx = [esp + 0x20 {arg2}].d
if (cond:3) then 112 @ 0x493f else 120 @ 0x491e

edx = edi
edx = edx - [esp + 0x14 {var_8}].d
edx = edx - 4
push(edx)
push(zx.d(0))
push(ebx)
call(sub_6938)
noreturn
{ Does not return }

eax = [esp + 0x10 {var_c}].d
edx = esi + 8
[eax].d = edx
edx = [esp + 0x24 {arg3}].d
ecx = 0
temp1.d = edx
edx = edx - 1
if (temp1.d == 1) then 132 @ 0x49ad else 139 @ 0x4953

eax = esi + ebp
edi = edi - ebp
ecx = eax + 8
[esp + 0x10 {var_c}].d = ecx
ecx = [0x10009f1c].d
edx = edi
edx = edx | 3
ecx = ecx ^ ebx
[eax + 4].d = edx
[edi + eax].d = ecx
edi = ebp
goto 112 @ 0x493f

edx = [0x10009f1c].d
ecx = edi
ecx = ecx | 3
edx = edx ^ ebx
[esi + 4].d = ecx
[edi + esi].d = edx
if (([ebx + 0x1b8].b & 2) == 0) then 141 @ 0x49e0 else 148 @ 0x49c9

eax = 0
goto 152 @ 0x4955

eax = [esp + 0x10 {var_c}].d
edi = pop
ebx = pop
ebp = pop
esi = pop
esp = esp + 0xc
<return> jump(pop)

ebx = ebx + 0x1cc
temp2.d = [ebx + 0x44].d
[ebx + 0x44].d = [ebx + 0x44].d - 1
if (temp2.d != 1) then 141 @ 0x49e0 else 154 @ 0x49d5

ebp = [esp + 0x18 {var_4}].d
if (ebp == 0) then 160 @ 0x4961 else 163 @ 0x495d

[ebx + 0x48].d = 0
eax = 0
temp0.d = [ebx].d
[ebx].d = eax
eax = temp0.d
goto 141 @ 0x49e0

ebp = [esp + 0x28 {arg4}].d
eax = [eax + ebp].d
if (eax u>= 7) then 165 @ 0x4974 else 168 @ 0x496d

eax = ebp
goto 170 @ 0x497a

eax = eax + 0xf
eax = eax & 0xfffffff8
goto 170 @ 0x497a

eax = 0x10
goto 170 @ 0x497a

ebp = eax
ebp = ebp | 3
[esi + 4].d = ebp
ebp = [0x10009f1c].d
ebp = ebp ^ ebx
[esi + eax].d = ebp
ebp = [esp + 0x10 {var_c}].d
esi = esi + eax
ecx = ecx + 1
edi = edi - eax
cond:4 = ecx != edx
ebx = esi + 8
eax = ecx << 2
[eax + ebp].d = ebx
ebx = [esp + 0x20 {arg2}].d
if (cond:4) then 152 @ 0x4955 else 132 @ 0x49ad

void* __convention("regparm") sub_49f0(int32_t arg1, int32_t arg2, int32_t* arg3, int32_t arg4)
esp = esp - 0xc
push(ebx)
push(ebp)
ebp = [esp + 0x18 {arg4}].d
cond:0 = ebp u> 8
ebx = ecx
if (cond:0) then 7 @ 0x4a0d else 8 @ 0x4a00

if (ebp u>= 0x10) then 12 @ 0x4a14 else 14 @ 0x4a0f

ebp = pop
ebx = pop
esp = esp + 0xc
<return> tailcall(sub_4500)

ecx = ebp - 1
if ((ebp & ecx) == 0) then 16 @ 0x4a2c else 21 @ 0x4a1b

ebp = 0x10
goto 12 @ 0x4a14

edx = 0xffffffc0
edx = edx - ebp
cond:1 = eax u>= edx
push(esi)
if (cond:1) then 23 @ 0x4be1 else 29 @ 0x4a3f

ecx = 0x10
if (ebp u<= ecx) then 30 @ 0x4a2a else 32 @ 0x4a24

esi = pop
ebp = pop
eax = 0
ebx = pop
esp = esp + 0xc
<return> jump(pop)

if (eax u>= 7) then 34 @ 0x4a4c else 39 @ 0x4a41

ebp = ecx
goto 16 @ 0x4a2c

ecx = ecx + ecx
if (ecx u< ebp) then 32 @ 0x4a24 else 30 @ 0x4a2a

eax = eax + 0xf
eax = eax & 0xfffffff8
[esp + 0x1c {arg4}].d = eax
esi = eax
goto 42 @ 0x4a58

esi = 0x10
[esp + 0x1c {arg4}].d = esi
goto 42 @ 0x4a58

eax = esi + ebp + 8
ecx = ebx
call(sub_4500)
ecx = eax
eax = 0
cond:3 = ecx == eax
[esp + 0x10 {var_8_1}].d = ecx
if (cond:3) then 23 @ 0x4be1 else 50 @ 0x4a73

cond:2 = ([ebx + 0x1b8].b & 2) == 0
push(edi)
[esp + 0x10 {var_c}].d = eax
[esp + 0x18 {var_4}].d = eax
edi = ecx - 8
if (cond:2) then 56 @ 0x4aa9 else 64 @ 0x4a88

edx = 0
eax = ecx
temp2.d = ebp
temp0.d = divu.dp.d(edx:eax, temp2.d)
temp1.d = modu.dp.d(edx:eax, temp2.d)
eax = temp0.d
edx = temp1.d
if (edx == 0) then 67 @ 0x4b3f else 69 @ 0x4ab7

esi = ebx + 0x1cc
call(sub_2b00)
if (eax == 0) then 77 @ 0x4aa1 else 80 @ 0x4a97

ebp = 1
goto 87 @ 0x4b44

esi = ecx + ebp - 1
eax = ebp
eax = neg.d(eax)
esi = esi & eax
esi = esi - 8
ecx = esi
ecx = ecx - edi
if (ecx u>= 0x10) then 89 @ 0x4acf else 98 @ 0x4acd

ecx = [esp + 0x14 {var_8_1}].d
esi = [esp + 0x20 {arg4}].d
goto 56 @ 0x4aa9

edi = pop
esi = pop
ebp = pop
eax = 0
ebx = pop
esp = esp + 0xc
<return> jump(pop)

ecx = [edi + 4].d
if ((cl & 3) == 0) then 100 @ 0x4b9a else 102 @ 0x4b4c

edx = [edi + 4].d
eax = esi
ecx = edx
eax = eax - edi
ecx = ecx & 0xfffffff8
ecx = ecx - eax
cond:4 = (dl & 3) != 0
ebp = 1
if (cond:4) then 106 @ 0x4af8 else 129 @ 0x4ae7

esi = esi + ebp
goto 89 @ 0x4acf

esi = [esp + 0x18 {var_4}].d
goto 136 @ 0x4ba5

eax = ecx
eax = eax & 0xfffffff8
edx = esi + 0x10
if (eax u<= edx) then 100 @ 0x4b9a else 137 @ 0x4b58

edx = [esi + 4].d
edx = edx & ebp
edx = edx | ecx
edx = edx | 2
[esi + 4].d = edx
edx = [0x10009f1c].d
[ecx + esi + 4].d = [ecx + esi + 4].d | ebp
edx = edx ^ ebx
[ecx + esi].d = edx
ecx = [edi + 4].d
edx = [0x10009f1c].d
ecx = ecx & ebp
ecx = ecx | eax
ecx = ecx | 2
[edi + 4].d = ecx
[eax + edi + 4].d = [eax + edi + 4].d | ebp
edx = edx ^ ebx
[eax + edi].d = edx
edi = edi + 8
[esp + 0x10 {var_c}].d = edi
edi = esi
esi = [esp + 0x20 {arg4}].d
goto 87 @ 0x4b44

edx = [edi].d
edx = edx + eax
[esi].d = edx
[esi + 4].d = ecx
edi = esi
esi = [esp + 0x20 {arg4}].d
goto 87 @ 0x4b44

if (([ebx + 0x1b8].b & 2) == 0) then 159 @ 0x4bbe else 161 @ 0x4ba7

ecx = ecx & ebp
ecx = ecx | esi
ecx = ecx | 2
[edi + 4].d = ecx
ecx = [0x10009f1c].d
[edi + esi + 4].d = [edi + esi + 4].d | ebp
eax = eax - esi
ecx = ecx ^ ebx
[edi + esi].d = ecx
ecx = [edi + esi + 4].d
edx = eax
eax = edi + esi
ecx = ecx & ebp
ecx = ecx | edx
ecx = ecx | 2
[eax + 4].d = ecx
ecx = [0x10009f1c].d
[eax + edx + 4].d = [eax + edx + 4].d | ebp
ecx = ecx ^ ebx
[eax + edx].d = ecx
esi = eax + 8
goto 136 @ 0x4ba5

eax = [esp + 0x10 {var_c}].d
if (eax == 0) then 165 @ 0x4bcd else 166 @ 0x4bc6

ebx = ebx + 0x1cc
temp3.d = [ebx + 0x44].d
[ebx + 0x44].d = [ebx + 0x44].d - 1
if (temp3.d != 1) then 159 @ 0x4bbe else 168 @ 0x4bb3

if (esi == 0) then 174 @ 0x4bd6 else 181 @ 0x4bcf

call(sub_3f40)
goto 165 @ 0x4bcd

[ebx + 0x48].d = 0
edx = 0
temp0.d = [ebx].d
[ebx].d = edx
edx = temp0.d
goto 159 @ 0x4bbe

eax = edi + 8
edi = pop
esi = pop
ebp = pop
ebx = pop
esp = esp + 0xc
<return> jump(pop)

eax = esi
call(sub_3f40)
goto 174 @ 0x4bd6

void* __convention("regparm") sub_4bf0(int32_t* arg1, void* arg2, void* arg3)
esp = esp - 8
cond:0 = [esp + 0x10 {arg3}].d u< -0x40
push(edi)
edi = eax
if (cond:0) then 5 @ 0x4c04 else 8 @ 0x4bfd

cond:1 = ([edi + 0x1b8].b & 2) == 0
push(esi)
if (cond:1) then 12 @ 0x4c21 else 25 @ 0x4c0e

eax = 0
edi = pop
esp = esp + 8
<return> jump(pop)

eax = [esp + 0x14 {arg2}].d
ecx = [eax - 4].d
eax = eax - 8
push(ebx)
ebx = ecx
edx = 0
ebx = ebx & 0xfffffff8
cond:2 = eax u< [edi + 0x10].d
push(ebp)
ebp = ebx + eax
[esp + 0x10 {var_8}].d = edx
[esp + 0x14 {var_4}].d = edx
if (cond:2) then 28 @ 0x4d94 else 30 @ 0x4c48

esi = edi + 0x1cc
call(sub_2b00)
if (eax != 0) then 33 @ 0x4dc4 else 12 @ 0x4c21

call([0x100080ec].d)
if (([edi + 0x1b8].b & 2) == 0) then 38 @ 0x4dba else 45 @ 0x4da3

esi = ecx
esi = esi & 3
if (esi == 1) then 28 @ 0x4d94 else 49 @ 0x4c58

esi = pop
eax = 0
edi = pop
esp = esp + 8
<return> jump(pop)

ebp = pop
ebx = pop
esi = pop
eax = 0
edi = pop
esp = esp + 8
<return> jump(pop)

edi = edi + 0x1cc
temp1.d = [edi + 0x44].d
[edi + 0x44].d = [edi + 0x44].d - 1
if (temp1.d != 1) then 38 @ 0x4dba else 50 @ 0x4daf

if (eax u>= ebp) then 28 @ 0x4d94 else 56 @ 0x4c62

[edi + 0x48].d = 0
eax = 0
temp0.d = [edi].d
[edi].d = eax
eax = temp0.d
goto 38 @ 0x4dba

if (([ebp + 4].b & 1) == 0) then 28 @ 0x4d94 else 57 @ 0x4c68

edx = [esp + 0x20 {arg3}].d
if (edx u>= 7) then 59 @ 0x4c78 else 62 @ 0x4c71

edx = edx + 0xf
edx = edx & 0xfffffff8
goto 64 @ 0x4c80

edx = 0x10
goto 64 @ 0x4c80

if (esi != 0) then 65 @ 0x4c8e else 66 @ 0x4c82

if (ebx u< edx) then 68 @ 0x4ce3 else 69 @ 0x4c90

call(sub_2a10)
goto 74 @ 0x4d20

if (ebp != [edi + 0x18].d) then 76 @ 0x4d2b else 77 @ 0x4ce5

ebp = ebx
ebp = ebp - edx
cond:3 = ebp u< 0x10
[esp + 0x10 {var_8}].d = eax
if (cond:3) then 76 @ 0x4d2b else 80 @ 0x4ca1

[esp + 0x10 {var_8}].d = eax
goto 76 @ 0x4d2b

if (([edi + 0x1b8].b & 2) == 0) then 100 @ 0x4d38 else 102 @ 0x4d2d

esi = [edi + 0xc].d
ebp = esi + ebx
if (ebp u<= edx) then 76 @ 0x4d2b else 105 @ 0x4cef

ecx = ecx & 1
esi = edx + eax
ecx = ecx | edx
ecx = ecx | 2
[eax + 4].d = ecx
ecx = [0x10009f1c].d
eax = 1
[esi + 4].d = [esi + 4].d | eax
ecx = ecx ^ edi
[esi].d = ecx
edx = ebp
edx = edx | 3
[esi + 4].d = edx
[esi + ebp + 4].d = [esi + ebp + 4].d | eax
eax = [0x10009f1c].d
eax = eax ^ edi
[esi + ebp].d = eax
esi = esi + 8
[esp + 0x14 {var_4}].d = esi
goto 76 @ 0x4d2b

esi = [esp + 0x10 {var_8}].d
if (esi == 0) then 123 @ 0x4d58 else 129 @ 0x4d40

eax = edi + 0x1cc
call(sub_2ae0)
goto 100 @ 0x4d38

ecx = ecx & 1
ecx = ecx | edx
esi = esi - edx
ecx = ecx | 2
[eax + 4].d = ecx
ecx = [0x10009f1c].d
[edx + eax + 4].d = [edx + eax + 4].d | 1
esi = esi + ebx
ebp = esi
esi = edx + eax
ecx = ecx ^ edi
edx = ebp
[esi].d = ecx
edx = edx | 1
[esi + 4].d = edx
[edi + 0x18].d = esi
[edi + 0xc].d = ebp
goto 74 @ 0x4d20

ebp = [esp + 0x20 {arg3}].d
eax = ebp
ecx = edi
call(sub_4500)
esi = eax
if (esi == 0) then 131 @ 0x4d8a else 138 @ 0x4d6b

eax = [esp + 0x14 {var_4}].d
if (eax == 0) then 140 @ 0x4d4d else 147 @ 0x4d48

ebp = pop
ebx = pop
eax = esi
esi = pop
edi = pop
esp = esp + 8
<return> jump(pop)

ebx = ebx - 8
if (ebx u< ebp) then 149 @ 0x4d74 else 155 @ 0x4d72

ebp = pop
ebx = pop
eax = esi + 8
esi = pop
edi = pop
esp = esp + 8
<return> jump(pop)

call(sub_3f40)
goto 140 @ 0x4d4d

edi = [esp + 0x1c {arg2}].d
push(ebx)
push(edi)
push(esi)
call(sub_693e)
noreturn
{ Does not return }

ebx = ebp
goto 149 @ 0x4d74

int32_t sub_4dd0(int32_t arg1, int32_t arg2)
eax = [0x10009f1c].d
if (eax != 0) then 2 @ 0x4dde else 4 @ 0x4dd9

eax = [esp + 0xc {arg2}].d
if (eax != -1) then 6 @ 0x4de9 else 8 @ 0x4de7

call(sub_34b0)
goto 2 @ 0x4dde

ecx = [esp + 8 {arg1}].d
if (ecx == -3) then 10 @ 0x4e24 else 13 @ 0x4df5

eax = eax
goto 6 @ 0x4de9

[0x10009f28].d = eax
eax = 1
<return> jump(pop)

if (ecx == -2) then 14 @ 0x4e0d else 15 @ 0x4dfa

if (eax u< [0x10009f20].d) then 16 @ 0x4e21 else 18 @ 0x4e0f

if (ecx != -1) then 16 @ 0x4e21 else 20 @ 0x4dfc

eax = 0
<return> jump(pop)

ecx = eax - 1
if ((eax & ecx) != 0) then 16 @ 0x4e21 else 23 @ 0x4e16

[0x10009f2c].d = eax
eax = 1
<return> jump(pop)

[0x10009f24].d = eax
eax = 1
<return> jump(pop)

void* sub_4e30(int32_t* arg1, int32_t arg2, int32_t arg3)
eax = [esp + 8 {arg2}].d
push(esi)
push(edi)
edi = [ebx + (eax << 2) + 0x458].d
ecx = [edi + 0x1cc].d
cond:0 = ecx == 0
esi = edi + 0x1cc
if (cond:0) then 8 @ 0x4e61 else 14 @ 0x4e4d

edx = 1
eax = esi
temp0.d = [eax].d
[eax].d = edx
edx = temp0.d
if (edx != 0) then 16 @ 0x4e83 else 28 @ 0x4e6e

call([0x10008018].d)
if ([esi + 0x48].d != eax) then 16 @ 0x4e83 else 35 @ 0x4e58

ecx = [esp + 0x14 {arg3}].d
eax = [esp + 0xc {arg1}].d
push(ecx)
edx = esp + 0x14 {arg2}
push(edx)
push(eax)
push(ebx)
call(sub_3bc0)
esp = esp + 0x10
edi = pop
esi = pop
<return> jump(pop)

call([0x10008018].d)
[esi + 0x48].d = eax
eax = edi
edi = pop
[esi + 0x44].d = 1
esi = pop
<return> jump(pop)

[esi + 0x44].d = [esi + 0x44].d + 1
eax = edi
edi = pop
esi = pop
<return> jump(pop)

int32_t sub_4ea0(int32_t arg1, int32_t arg2)
eax = [0x10009f1c].d
if (eax != 0) then 2 @ 0x4eae else 4 @ 0x4ea9

eax = [esp + 8 {arg2}].d
if (eax != -1) then 6 @ 0x4eb9 else 8 @ 0x4eb7

call(sub_34b0)
goto 2 @ 0x4eae

ecx = [esp + 4 {arg1}].d
if (ecx == -3) then 10 @ 0x4ef4 else 13 @ 0x4ec5

eax = eax
goto 6 @ 0x4eb9

[0x10009f28].d = eax
eax = 1
<return> jump(pop)

if (ecx == -2) then 14 @ 0x4edd else 15 @ 0x4eca

if (eax u< [0x10009f20].d) then 16 @ 0x4ef1 else 18 @ 0x4edf

if (ecx != -1) then 16 @ 0x4ef1 else 20 @ 0x4ecc

eax = 0
<return> jump(pop)

ecx = eax - 1
if ((eax & ecx) != 0) then 16 @ 0x4ef1 else 23 @ 0x4ee6

[0x10009f2c].d = eax
eax = 1
<return> jump(pop)

[0x10009f24].d = eax
eax = 1
<return> jump(pop)

int32_t j_sub_3f40()
<return> tailcall(sub_3f40)

void* __convention("regparm") sub_4f10(int32_t* arg1, int32_t arg2, int32_t* arg3, void* arg4)
ecx = [0x10009f1c].d
if ([eax + 0x24].d == ecx) then 2 @ 0x4f24 else 12 @ 0x4f1b

edx = [esp + 8 {arg3}].d
ecx = [esp + 4 {arg2}].d
push(zx.d(0))
push(edx)
push(ecx)
push(eax)
eax = [esp + 0x1c {arg4}].d
call(sub_47c0)
esp = esp + 0x10
<return> jump(pop)

call([0x100080ec].d)
eax = 0
<return> jump(pop)

void* __convention("regparm") sub_4f40(int32_t* arg1, int32_t arg2, int32_t arg3, int32_t* arg4, void* arg5)
push(ecx)
edx = [0x10009f1c].d
cond:0 = [eax + 0x24].d == edx
[esp {var_4}].d = ecx
if (cond:0) then 5 @ 0x4f59 else 16 @ 0x4f4f

edx = [esp + 8 {arg4}].d
push(zx.d(3))
ecx = esp + 4 {var_4}
push(ecx)
push(edx)
push(eax)
eax = [esp + 0x1c {arg5}].d
call(sub_47c0)
esp = esp + 0x10
ecx = pop
<return> jump(pop)

call([0x100080ec].d)
eax = 0
ecx = pop
<return> jump(pop)

void* __convention("regparm") sub_4f80(int32_t arg1, int32_t arg2, int32_t* arg3, int32_t arg4, int32_t arg5)
eax = [0x10009f1c].d
if ([ecx + 0x24].d == eax) then 2 @ 0x4f93 else 8 @ 0x4f8a

edx = [esp + 4 {arg4}].d
eax = [esp + 8 {arg5}].d
push(edx)
call(sub_49f0)
esp = esp + 4
<return> jump(pop)

call([0x100080ec].d)
eax = 0
<return> jump(pop)

void* __convention("regparm") sub_4fb0(int32_t arg1, int32_t arg2, void* arg3, int32_t arg4 @ esi, int32_t* arg5)
if (ecx != 0) then 1 @ 0x4fbf else 8 @ 0x4fb4

eax = [ecx - 4].d
eax = eax & 0xfffffff8
edx = eax + ecx - 8
eax = [0x10009f1c].d
eax = eax ^ [edx].d
edx = [0x10009f1c].d
if ([eax + 0x24].d == edx) then 11 @ 0x4fe4 else 16 @ 0x4fdb

eax = esi
ecx = [esp + 4 {arg5}].d
<return> tailcall(sub_4500)

push(esi)
push(ecx)
call(sub_4bf0)
esp = esp + 8
<return> jump(pop)

call([0x100080ec].d)
eax = 0
<return> jump(pop)

void* __convention("regparm") sub_4ff0(int32_t arg1, int32_t arg2, int32_t* arg3)
push(edi)
edi = eax
eax = [0x10009f1c].d
if ([ecx + 0x24].d == eax) then 4 @ 0x500d else 5 @ 0x4ffd

if ((edi & 0xffff0000) == 0) then 9 @ 0x5016 else 14 @ 0x5011

call([0x100080ec].d)
eax = 0
edi = pop
<return> jump(pop)

push(esi)
eax = edi
call(sub_4500)
esi = eax
if (esi == 0) then 15 @ 0x5036 else 19 @ 0x5028

if (edi == edi) then 9 @ 0x5016 else 20 @ 0x5013

eax = esi
esi = pop
edi = pop
<return> jump(pop)

if (([esi - 4].b & 3) == 0) then 15 @ 0x5036 else 22 @ 0x502a

edi = edi | 0xffffffff
goto 9 @ 0x5016

push(edi)
push(zx.d(0))
push(esi)
call(sub_6938)
noreturn
{ Does not return }

int32_t __stdcall sub_5033(int32_t arg1 @ esi, int32_t arg2, int32_t arg3) __pure
esp = esp + 0xc
eax = esi
esi = pop
edi = pop
<return> jump(pop)

void sub_5040(void* arg1 @ edi, int32_t arg2)
push(ecx)
push(ebx)
push(ebp)
ebp = [esp + 0x10 {arg2}].d
push(esi)
esi = edi + 0x18
[esp + 0xc {i_1}].d = 0xa
ebx = 0
goto 9 @ 0x5058

if ([esi + 4].d == ebx) then 10 @ 0x509e else 14 @ 0x505a

esi = esi + 8
temp0.d = [esp + 0xc {i_1}].d
[esp + 0xc {i_1}].d = [esp + 0xc {i_1}].d - 1
if (temp0.d != 1) then 9 @ 0x5058 else 16 @ 0x50a8

ebx = ebx
goto 21 @ 0x5060

esi = pop
ebp = pop
ebx = pop
ecx = pop
<return> jump(pop)

eax = [esi + 4].d
ecx = [edi + 0xc].d
ecx = ecx - [eax + 4].d
if (ecx u< ebp) then 10 @ 0x509e else 25 @ 0x506d

ecx = [eax + 0x10].d
cond:0 = ecx == ebx
edx = [eax + 8].d
[esi + 4].d = ecx
if (cond:0) then 30 @ 0x507f else 32 @ 0x507a

[esi].d = ebx
goto 34 @ 0x5081

[ecx + 0xc].d = ebx
goto 34 @ 0x5081

[edi + 0x14].d = [edi + 0x14].d - edx
if ([eax].d == ebx) then 36 @ 0x5094 else 38 @ 0x5088

call(sub_3f40)
goto 42 @ 0x509c

push(eax)
call([0x10009094].d)
esp = esp + 4
goto 42 @ 0x509c

if ([esi + 4].d != ebx) then 21 @ 0x5060 else 10 @ 0x509e

void* sub_50b0(int32_t arg1 @ edi)
eax = [0x10009f1c].d
cond:0 = [ebx + 0x24 {&data_24}].d == eax
push(esi)
if (cond:0) then 4 @ 0x50c5 else 9 @ 0x50bb

eax = edi
ecx = ebx
call(sub_4500)
esi = eax
if (esi == 0) then 11 @ 0x50c1 else 14 @ 0x50d8

call([0x100080ec].d)
goto 11 @ 0x50c1

eax = 0
esi = pop
<return> jump(pop)

if (([esi - 4].b & 3) == 0) then 15 @ 0x50e6 else 19 @ 0x50da

eax = [esi - 4].d
ecx = [0x10009f18].d
eax = eax & 0xfffffff8
if (ecx == 0) then 24 @ 0x50fb else 27 @ 0x50f9

push(edi)
push(zx.d(0))
push(esi)
call(sub_6938)
noreturn
{ Does not return }

ecx = [ebx + 0x10 {&data_10}].d
[0x10009f18].d = ecx
goto 28 @ 0x5104

if ([ebx + 0x10 {&data_10}].d u>= ecx) then 28 @ 0x5104 else 24 @ 0x50fb

ecx = [0x10009f34].d
if (ecx == 0) then 30 @ 0x5112 else 37 @ 0x5110

ecx = [0x10009f20].d
edx = ecx + eax
ecx = ecx - 1
ecx = not.d(ecx)
edx = edx & ecx
[0x10009f34].d = edx
goto 38 @ 0x5128

if (eax u<= ecx) then 38 @ 0x5128 else 30 @ 0x5112

eax = esi
esi = pop
<return> jump(pop)

void* __stdcall sub_50e3(void* arg1 @ esi, int32_t arg2)
esp = esp + 0xc
eax = [esi - 4].d
ecx = [0x10009f18].d
eax = eax & 0xfffffff8
if (ecx == 0) then 5 @ 0x50fb else 8 @ 0x50f9

ecx = [ebx + 0x10 {&data_10}].d
[0x10009f18].d = ecx
goto 9 @ 0x5104

if ([ebx + 0x10 {&data_10}].d u>= ecx) then 9 @ 0x5104 else 5 @ 0x50fb

ecx = [0x10009f34].d
if (ecx == 0) then 11 @ 0x5112 else 18 @ 0x5110

ecx = [0x10009f20].d
edx = ecx + eax
ecx = ecx - 1
ecx = not.d(ecx)
edx = edx & ecx
[0x10009f34].d = edx
goto 19 @ 0x5128

if (eax u<= ecx) then 19 @ 0x5128 else 11 @ 0x5112

eax = esi
esi = pop
<return> jump(pop)

void* __convention("fastcall") sub_5130(int32_t arg1, int32_t* arg2 @ esi)
if (ecx == 0) then 1 @ 0x5156 else 4 @ 0x5134

ecx = esi
call(sub_4500)
goto 6 @ 0x515f

edx = [0x10009f1c].d
if ([esi + 0x24].d == edx) then 7 @ 0x5149 else 12 @ 0x513f

if (eax == 0) then 15 @ 0x51a3 else 17 @ 0x5161

push(ecx)
ecx = esi
call(sub_49f0)
esp = esp + 4
goto 6 @ 0x515f

call([0x100080ec].d)
eax = 0
goto 6 @ 0x515f

eax = 0
goto 21 @ 0x51a5

ecx = [eax - 4].d
edx = [0x10009f18].d
ecx = ecx & 0xfffffff8
if (edx == 0) then 22 @ 0x5176 else 25 @ 0x5174

<return> jump(pop)

edx = [esi + 0x10].d
[0x10009f18].d = edx
goto 26 @ 0x517f

if ([esi + 0x10].d u>= edx) then 26 @ 0x517f else 22 @ 0x5176

edx = [0x10009f34].d
if (edx == 0) then 28 @ 0x518d else 35 @ 0x518b

edx = [0x10009f20].d
ecx = ecx + edx
edx = edx - 1
edx = not.d(edx)
ecx = ecx & edx
[0x10009f34].d = ecx
<return> jump(pop)

if (ecx u<= edx) then 21 @ 0x51a5 else 28 @ 0x518d

int32_t* sub_51b0(void* arg1 @ edi)
push(ecx)
push(ebx)
push(ebp)
push(esi)
ebp = 0x40
ebx = 0
goto 7 @ 0x51c0

eax = [edi + 0x14].d
if (eax u< 0x80000) then 9 @ 0x5231 else 14 @ 0x51cc

esi = pop
ebp = pop
ebx = pop
ecx = pop
<return> jump(pop)

if (eax == ebx) then 15 @ 0x522d else 17 @ 0x51ce

ebp = ebp u>> 1
if (ebp != 0) then 7 @ 0x51c0 else 9 @ 0x5231

esi = edi + 0x18
[esp + 0xc {j_1}].d = 0xa
esp = esp
goto 21 @ 0x51e3

if ([esi + 4].d == ebx) then 22 @ 0x5223 else 26 @ 0x51e5

esi = esi + 8
temp0.d = [esp + 0xc {j_1}].d
[esp + 0xc {j_1}].d = [esp + 0xc {j_1}].d - 1
if (temp0.d != 1) then 21 @ 0x51e3 else 15 @ 0x522d

eax = [esi + 4].d
ecx = [edi + 0xc].d
ecx = ecx - [eax + 4].d
if (ecx u< ebp) then 22 @ 0x5223 else 30 @ 0x51f2

ecx = [eax + 0x10].d
cond:0 = ecx == ebx
edx = [eax + 8].d
[esi + 4].d = ecx
if (cond:0) then 35 @ 0x5204 else 37 @ 0x51ff

[esi].d = ebx
goto 39 @ 0x5206

[ecx + 0xc].d = ebx
goto 39 @ 0x5206

[edi + 0x14].d = [edi + 0x14].d - edx
if ([eax].d == ebx) then 41 @ 0x5219 else 43 @ 0x520d

call(sub_3f40)
goto 47 @ 0x5221

push(eax)
call([0x10009094].d)
esp = esp + 4
goto 47 @ 0x5221

if ([esi + 4].d != ebx) then 26 @ 0x51e5 else 22 @ 0x5223

void* __convention("regparm") sub_5240(int32_t* arg1)
push(ebp)
push(esi)
esi = eax
call(sub_2b00)
ebp = 0
eax = esi + 0x54
edi = edi
goto 8 @ 0x5253

if ([eax].d == 0) then 9 @ 0x5269 else 10 @ 0x5255

if (ebp != 0x100) then 13 @ 0x5281 else 18 @ 0x526b

ebp = ebp + 1
eax = eax + 4
if (ebp s< 0x100) then 8 @ 0x5253 else 9 @ 0x5269

ecx = [0x10009f1c].d
push(ebx)
push(edi)
edi = [esi + 0x458].d
if ([edi + 0x24].d == ecx) then 21 @ 0x52b8 else 26 @ 0x5294

temp2.d = [esi + 0x44].d
[esi + 0x44].d = [esi + 0x44].d - 1
if (temp2.d != 1) then 28 @ 0x527c else 32 @ 0x5271

eax = 0x68
ecx = edi
call(sub_4500)
ebx = eax
if (ebx == 0) then 38 @ 0x529a else 40 @ 0x52ce  {"t\rjhj"}

call([0x100080ec].d)
goto 38 @ 0x529a

esi = pop
eax = 0
ebp = pop
<return> jump(pop)

[esi + 0x48].d = 0
eax = 0
temp0.d = [esi].d
[esi].d = eax
eax = temp0.d
goto 28 @ 0x527c

ebx = 0
goto 41 @ 0x529c

if (([ebx - 4].b & 3) == 0) then 44 @ 0x52dd else 48 @ 0x52d0

cond:2 = ebx != 0
[esi + (ebp << 2) + 0x54].d = ebx
if (cond:2) then 53 @ 0x5322 else 59 @ 0x52a4

eax = [ebx - 4].d
ecx = [0x10009f18].d
eax = eax & 0xfffffff8
if (ecx == 0) then 62 @ 0x52f2 else 65 @ 0x52f0

push(zx.d(0x68))
push(zx.d(0))
push(ebx)
call(sub_6938)
noreturn
{ Does not return }

call([0x10008018].d)
edi = 0
cond:0 = [esi + 0x458].d == edi
ecx = esi + 0x458
[ebx + 4].d = eax
if (cond:0) then 66 @ 0x534b else 79 @ 0x533b

temp3.d = [esi + 0x44].d
[esi + 0x44].d = [esi + 0x44].d - 1
if (temp3.d != 1) then 80 @ 0x52b1 else 86 @ 0x52aa

edx = [edi + 0x10].d
[0x10009f18].d = edx
goto 92 @ 0x52fb

if ([edi + 0x10].d u>= ecx) then 92 @ 0x52fb else 62 @ 0x52f2

edx:eax = sx.q(eax)
eax = eax ^ edx
eax = eax - edx
edx:eax = sx.q(eax)
temp0.d = divs.dp.d(edx:eax, edi)
temp1.d = mods.dp.d(edx:eax, edi)
eax = temp0.d
edx = temp1.d
temp4.d = [esi + 0x44].d
[esi + 0x44].d = [esi + 0x44].d - 1
cond:1 = temp4.d != 1
[ebx].d = edx
if (cond:1) then 94 @ 0x5368 else 100 @ 0x535b

goto 107 @ 0x5340

edi = pop
ebx = pop
esi = pop
eax = 0
ebp = pop
<return> jump(pop)

[esi + 0x48].d = ebx
ecx = 0
temp0.d = [esi].d
[esi].d = ecx
ecx = temp0.d
goto 80 @ 0x52b1

ecx = [0x10009f34].d
if (ecx == 0) then 110 @ 0x5309 else 117 @ 0x5307

ecx = [esi + 0x454].d
ebp = ebp + 1
push(ebp)
push(ecx)
call([0x10008030].d), esp += 8
if (eax != 0) then 118 @ 0x5383 else 124 @ 0x537d

[esi + 0x48].d = 0
edx = 0
eax = esi
temp0.d = [eax].d
[eax].d = edx
edx = temp0.d
goto 94 @ 0x5368

ecx = ecx + 4
edi = edi + 1
if ([ecx].d != 0) then 107 @ 0x5340 else 66 @ 0x534b

ecx = [0x10009f20].d
eax = eax + ecx
ecx = ecx - 1
ecx = not.d(ecx)
eax = eax & ecx
[0x10009f34].d = eax
goto 41 @ 0x529c

if (eax u<= ecx) then 41 @ 0x529c else 110 @ 0x5309

edi = pop
eax = ebx
ebx = pop
esi = pop
ebp = pop
<return> jump(pop)

call([0x100080ec].d)
goto 118 @ 0x5383

void __convention("regparm") sub_5390(void* arg1)
push(esi)
esi = eax
temp0.d = esi
esi = esi + 0x54
if (temp0.d == -0x54) then 5 @ 0x53de else 7 @ 0x5398

esi = pop
<return> jump(pop)

push(ebx)
push(edi)
ebx = 0x100
goto 11 @ 0x53a0

edi = [esi].d
if (edi == 0) then 13 @ 0x53d4 else 17 @ 0x53a6

esi = esi + 4
temp1.d = ebx
ebx = ebx - 1
if (temp1.d != 1) then 11 @ 0x53a0 else 19 @ 0x53dc

[edi + 0xc].d = [edi + 0xc].d + 1
if ([edi + 0x14].d == 0) then 22 @ 0x53ba else 28 @ 0x53b0

edi = pop
ebx = pop
goto 5 @ 0x53de

eax = edi
[edi].d = -1
[edi + 4].d = 0
call(sub_3f40)
[esi].d = 0
goto 13 @ 0x53d4

push(zx.d(0))
call(sub_5040)
esp = esp + 4
goto 22 @ 0x53ba

void* __convention("regparm") sub_53e0(int32_t arg1, int32_t arg2, int32_t* arg3, void* arg4 @ edi, int32_t arg5, int32_t arg6)
cond:0 = [esp + 4 {arg5}].d == 0
push(ebx)
push(ebp)
ebp = [esp + 0x10 {arg6}].d
push(esi)
esi = eax
ebx = ecx
if (cond:0) then 8 @ 0x5466 else 9 @ 0x53f2

if (edi != 0) then 11 @ 0x546f else 17 @ 0x5468

call(sub_4500)
if (eax == 0) then 19 @ 0x545c else 25 @ 0x53fb

edx = [edi - 4].d
eax = [0x10009f1c].d
ecx = [0x10009f1c].d
edx = edx & 0xfffffff8
eax = eax ^ [edx + edi - 8].d
if ([eax + 0x24].d == ecx) then 29 @ 0x5495 else 34 @ 0x5489

call(sub_4500)
goto 36 @ 0x54a1

esi = pop
ebx = 0
ebp = pop
eax = ebx
ebx = pop
<return> jump(pop)

ecx = [eax - 4].d
edx = [0x10009f18].d
ecx = ecx & 0xfffffff8
if (edx == 0) then 37 @ 0x5410 else 40 @ 0x540e

push(esi)
push(edi)
call(sub_4bf0)
esp = esp + 8
goto 36 @ 0x54a1

call([0x100080ec].d)
goto 41 @ 0x548f

if (eax == 0) then 41 @ 0x548f else 43 @ 0x54a3

edx = [ebx + 0x10].d
[0x10009f18].d = edx
goto 47 @ 0x5419

if ([ebx + 0x10].d u>= edx) then 47 @ 0x5419 else 37 @ 0x5410

eax = 0
goto 49 @ 0x5491

ecx = [eax - 4].d
edx = [0x10009f34].d
ecx = ecx & 0xfffffff8
if (edx == 0) then 53 @ 0x54b7 else 63 @ 0x54b5

edx = [0x10009f34].d
if (edx == 0) then 64 @ 0x5427 else 71 @ 0x5425

esi = pop
ebp = pop
ebx = pop
<return> jump(pop)

edx = [0x10009f20].d
ecx = ecx + edx
edx = edx - 1
esi = pop
edx = not.d(edx)
ecx = ecx & edx
ebp = pop
[0x10009f34].d = ecx
ebx = pop
<return> jump(pop)

if (ecx u<= edx) then 49 @ 0x5491 else 53 @ 0x54b7

edx = [0x10009f20].d
ecx = ecx + edx
edx = edx - 1
edx = not.d(edx)
ecx = ecx & edx
[0x10009f34].d = ecx
goto 72 @ 0x543c

if (ecx u<= edx) then 72 @ 0x543c else 64 @ 0x5427

cond:1 = ebp u>= esi
ebx = eax
if (cond:1) then 75 @ 0x5444 else 80 @ 0x5442

push(esi)
push(edi)
push(eax)
call(sub_693e)
noreturn
{ Does not return }

esi = ebp
goto 75 @ 0x5444

int32_t __stdcall sub_544c(int32_t arg1, int32_t arg2, int32_t arg3)
push(edi)
call([0x10009094].d)
esp = esp + 0x10
esi = pop
ebp = pop
eax = ebx
ebx = pop
<return> jump(pop)

void* sub_54d0(int32_t* arg1 @ esi, int32_t* arg2 @ edi, void** arg3)
eax = [esi].d
call(sub_5240)
cond:0 = eax != 0
ecx = [esp + 4 {arg3}].d
[ecx].d = eax
if (cond:0) then 6 @ 0x5503 else 9 @ 0x54e1

ecx = [eax].d
[edi].d = ecx
<return> jump(pop)

edx = [esi].d
eax = [edx + 0x454].d
push(zx.d(-1))
push(eax)
call([0x10008030].d), esp += 8
if (eax != 0) then 15 @ 0x54fc else 17 @ 0x54f6

[edi].d = 0
<return> jump(pop)

call([0x100080ec].d)
goto 15 @ 0x54fc

int32_t sub_5510()
push(esi)
push(edi)
esi = 0x10009f38
call(sub_2b00)
eax = esi
call(sub_5390)
if ([0x1000a390].d == 0) then 7 @ 0x554a else 11 @ 0x552c

eax = 0xdeadbeef
ecx = 0x100
edi = 0x10009f8c
if (flag:d) then 14 else 16

edi = 0x1000a390
esi = edi
goto 18 @ 0x5533

edi, ecx = __memfill_u32(edi - (ecx << 2), eax, ecx << 2)
goto 25 @ 0x555b

edi, ecx = __memfill_u32(edi, eax, ecx << 2)
goto 25 @ 0x555b

eax = [edi].d
call(sub_2d40)
esi = esi + 4
[edi].d = 0
cond:1 = [esi].d != 0
edi = esi
if (cond:1) then 18 @ 0x5533 else 7 @ 0x554a

[0x1000a390].d = eax
[0x1000a394].d = eax
eax = [0x1000a38c].d
push(eax)
call([0x10008024].d), esp += 4
cond:0 = eax != 0
edi = pop
esi = pop
if (cond:0) then 34 @ 0x557d else 37 @ 0x5577

temp1.d = [0x10009f7c].d
[0x10009f7c].d = [0x10009f7c].d - 1
if (temp1.d != 1) then 39 @ 0x5599 else 40 @ 0x5586

call([0x100080ec].d)
goto 34 @ 0x557d

<return> jump(pop)

[0x10009f80].d = 0
ecx = 0
edx = 0x10009f38
temp0.d = [edx {0x10009f38}].d
[edx {0x10009f38}].d = ecx
ecx = temp0.d
goto 39 @ 0x5599

int32_t (*)() sub_55a0(int32_t* arg1 @ edi, int32_t arg2)
eax = [0x10009f1c].d
if (eax != 0) then 2 @ 0x55ae else 8 @ 0x55a9

push(ebp)
push(esi)
esi = 0x1000e400
call(sub_2b00)
ebp = 0
if ([edi + 0x50].d != ebp) then 10 @ 0x566a else 14 @ 0x55c5

call(sub_34b0)
goto 2 @ 0x55ae

eax = 1
temp1.d = [0x1000e444].d
[0x1000e444].d = [0x1000e444].d - eax
if (temp1.d != eax) then 21 @ 0x5686 else 24 @ 0x5677

[edi + 0x48].d = ebp
[edi + 0x44].d = ebp
[edi].d = ebp
call([0x1000801c].d)
cond:0 = eax == -1
[edi + 0x454].d = eax
if (cond:0) then 31 @ 0x55f1 else 34 @ 0x55de

esi = pop
ebp = pop
<return> jump(pop)

[0x1000e448].d = ebp
ecx = 0
edx = 0x1000e400
temp0.d = [edx {0x1000e400}].d
[edx {0x1000e400}].d = ecx
ecx = temp0.d
goto 21 @ 0x5686

cond:1 = ebx s>= ebp
esi = [0x100080ec].d
if (cond:1) then 39 @ 0x55fd else 43 @ 0x55fb

esi = [esp + 0xc {arg2}].d
call(sub_3550)
cond:2 = eax != ebp
[edi + 0x458].d = eax
if (cond:2) then 45 @ 0x5653 else 31 @ 0x55f1

eax = edi
call(sub_5390)
eax = [edi + 0x458].d
if (eax == ebp) then 50 @ 0x5619 else 52 @ 0x560e

call(esi)
goto 39 @ 0x55fd

[eax + 0x218 {&data_218}].d = edi
eax = ebx - 1
cond:3 = eax u<= 0
eax = ebx
if (cond:3) then 55 @ 0x5667 else 57 @ 0x5662

eax = [edi + 0x454].d
if (eax == ebp) then 59 @ 0x5636 else 62 @ 0x5623

call(sub_2d40)
[edi + 0x458].d = ebp
goto 50 @ 0x5619

[edi + 0x50].d = eax
goto 10 @ 0x566a

eax = 1
goto 55 @ 0x5667

temp2.d = [0x1000e444].d
[0x1000e444].d = [0x1000e444].d - 1
if (temp2.d != 1) then 65 @ 0x564e else 69 @ 0x563f

push(eax)
call([0x10008024].d), esp += 4
if (eax != 0) then 76 @ 0x5630 else 78 @ 0x562e

esi = pop
eax = 0
ebp = pop
<return> jump(pop)

[0x1000e448].d = ebp
ecx = 0
edx = 0x1000e400
temp0.d = [edx {0x1000e400}].d
[edx {0x1000e400}].d = ecx
ecx = temp0.d
goto 65 @ 0x564e

[edi + 0x454].d = ebp
goto 59 @ 0x5636

call(esi)
goto 76 @ 0x5630

int32_t* __convention("regparm") sub_5690(void* arg1, int32_t* arg2 @ esi, int32_t arg3, int32_t arg4)
push(ebx)
push(ebp)
ebp = [esp + 0xc {arg3}].d
push(edi)
edi = eax
eax = ebp
eax = eax u>> 4
ecx, eflags = _bit_scan_reverse(eax)
edx = ecx
ebx = [edi + (edx << 3) + 0x18].d
[esp + 0x10 {arg3}].d = ecx
ecx = edx + 4
eax = 1
eax = eax << cl
if (eax != ebp) then 15 else 17 @ 0x56bc

ebp = eax
goto 17 @ 0x56bc

if (esi != ebx) then 18 @ 0x56e1 else 28 @ 0x56be

eax = [esp + 0x14 {arg4}].d
[edi + 0xc].d = [edi + 0xc].d + 1
cond:0 = ebx == 0
[esi].d = eax
eax = [edi + 0xc].d
[esi + 4].d = eax
[esi + 8].d = ebp
[esi + 0xc].d = ebx
[esi + 0x10].d = 0
if (cond:0) then 38 @ 0x5707 else 40 @ 0x5702

push(esi)
push(0x100081a0)
call([0x10008080].d)
eax = eax + 0x40
push(eax)
call([0x10008084].d)
esp = esp + 0xc
call([0x100080ec].d)
edx = [esp + 0x10 {arg3}].d
goto 18 @ 0x56e1

[edi + (edx << 3) + 0x1c].d = esi
goto 42 @ 0x570b

[ebx + 0x10].d = esi
goto 42 @ 0x570b

[edi + 0x14].d = [edi + 0x14].d + ebp
cond:1 = [edi + 0x14].d u< 0x80000
[edi + (edx << 3) + 0x18].d = esi
if (cond:1) then 46 @ 0x5720 else 50 @ 0x571b

edi = pop
ebp = pop
ebx = pop
<return> jump(pop)

call(sub_51b0)
goto 46 @ 0x5720

int32_t sub_5730(void* arg1)
push(ebx)
push(ebp)
push(esi)
esi = [esp + 0x10 {arg1}].d
ebp = 0
cond:0 = esi != 0
push(edi)
if (cond:0) then 8 @ 0x5759 else 11 @ 0x573e

cond:1 = [esi + 0x458].d == ebp
eax = esi + 0x458
if (cond:1) then 14 @ 0x5795 else 20 @ 0x5767

cond:2 = [0x10009f88].d != ebp
esi = 0x10009f38
if (cond:2) then 8 @ 0x5759 else 23 @ 0x574b

edi = pop
esi = pop
eax = ebp
ebp = pop
ebx = pop
<return> jump(pop)

ebx = [0x100080ec].d
esi = eax
goto 29 @ 0x5770

push(ebp)
ebx = ebx | 0xffffffff
edi = esi
call(sub_55a0)
esp = esp + 4
goto 8 @ 0x5759

eax = [eax].d
ecx = [0x10009f1c].d
edi = 0
if ([eax + 0x24].d != ecx) then 33 @ 0x5787 else 35 @ 0x577f

call(ebx)
goto 37 @ 0x5789

edi = [eax + 0x1b0].d
goto 37 @ 0x5789

esi = esi + 4
ebp = ebp + edi
cond:3 = [esi].d != 0
eax = esi
if (cond:3) then 29 @ 0x5770 else 14 @ 0x5795

int32_t* sub_57a0(void* arg1)
push(ebx)
push(esi)
esi = [esp + 0xc {arg1}].d
cond:0 = esi != 0
push(edi)
if (cond:0) then 6 @ 0x57c8 else 9 @ 0x57ab

cond:1 = [esi + 0x458].d == 0
eax = esi + 0x458
if (cond:1) then 12 @ 0x5802 else 16 @ 0x57d7

cond:2 = [0x10009f88].d != 0
esi = 0x10009f38
if (cond:2) then 6 @ 0x57c8 else 19 @ 0x57b9

edi = pop
esi = pop
ebx = pop
<return> jump(pop)

edi = [0x100080ec].d
esi = eax
goto 25 @ 0x57e0

push(zx.d(0))
ebx = ebx | 0xffffffff
edi = esi
call(sub_55a0)
esp = esp + 4
goto 6 @ 0x57c8

eax = [eax].d
ecx = [0x10009f1c].d
if ([eax + 0x24].d != ecx) then 28 @ 0x57f6 else 30 @ 0x57ed

call(edi)
goto 33 @ 0x57f8

ebx = eax
call(sub_38e0)
goto 33 @ 0x57f8

esi = esi + 4
cond:3 = [esi].d != 0
eax = esi
if (cond:3) then 25 @ 0x57e0 else 12 @ 0x5802

int32_t sub_5810(void* arg1, int32_t arg2)
push(ecx)
push(ebx)
push(ebp)
push(esi)
esi = [esp + 0x14 {arg1}].d
ebp = 0
cond:0 = esi != 0
push(edi)
[esp + 0x10 {var_4}].d = ebp
if (cond:0) then 10 @ 0x583e else 13 @ 0x5823

cond:1 = [esi + 0x458].d == ebp
eax = esi + 0x458
if (cond:1) then 16 @ 0x58c6 else 23 @ 0x584c

cond:2 = [0x10009f88].d != ebp
esi = 0x10009f38
if (cond:2) then 10 @ 0x583e else 26 @ 0x5830

edi = pop
esi = pop
eax = ebp
ebp = pop
ebx = pop
ecx = pop
<return> jump(pop)

ebx = eax
edi = edi
goto 32 @ 0x5850

push(ebp)
ebx = ebx | 0xffffffff
edi = esi
call(sub_55a0)
esp = esp + 4
goto 10 @ 0x583e

edi = [eax].d
eax = [0x10009f1c].d
ebp = 0
if ([edi + 0x24].d != eax) then 36 @ 0x58a8 else 38 @ 0x5865

call([0x100080ec].d)
goto 39 @ 0x58ae

if (([edi + 0x1b8].b & 2) == 0) then 44 @ 0x5876 else 50 @ 0x5867

[esp + 0x10 {var_4}].d = [esp + 0x10 {var_4}].d + ebp
ebx = ebx + 4
cond:4 = [ebx].d != 0
eax = ebx
if (cond:4) then 32 @ 0x5850 else 53 @ 0x58bc

eax = [esp + 0x1c {arg2}].d
ecx = edi
call(sub_35d0)
cond:3 = ([edi + 0x1b8].b & 2) == 0
ebp = eax
if (cond:3) then 39 @ 0x58ae else 60 @ 0x588c

esi = edi + 0x1cc
call(sub_2b00)
if (eax != 0) then 39 @ 0x58ae else 44 @ 0x5876

eax = [esp + 0x10 {var_4}].d
edi = pop
esi = pop
ebp = pop
ebx = pop
ecx = pop
<return> jump(pop)

temp1.d = [edi + 0x210].d
[edi + 0x210].d = [edi + 0x210].d - 1
cond:5 = temp1.d != 1
eax = edi + 0x1cc
if (cond:5) then 39 @ 0x58ae else 65 @ 0x589b

[eax + 0x48].d = 0
ecx = 0
temp0.d = [eax].d
[eax].d = ecx
ecx = temp0.d
goto 39 @ 0x58ae

int32_t* sub_58d0(int32_t* arg1, void* arg2)
push(ebp)
ebp = esp {__saved_ebp}
esp = esp & 0xfffffff8
esp = esp - 0x54
eax = 0
cond:0 = [ebp + 0xc {arg2}].d != eax
push(ebx)
push(esi)
esi = [ebp + 8 {arg1}].d
[esi].d = 0
[esi + 4].d = eax
[esi + 8].d = eax
[esi + 0xc].d = eax
[esi + 0x10].d = eax
[esi + 0x14].d = eax
[esi + 0x18].d = eax
[esi + 0x1c].d = eax
[esi + 0x20].d = eax
push(edi)
[esi + 0x24].d = eax
if (cond:0) then 21 @ 0x5923 else 24 @ 0x5907

eax = [ebp + 0xc {arg2}].d
eax = eax + 0x458
if ([eax].d == 0) then 28 @ 0x59a5 else 35 @ 0x5930

cond:1 = [0x10009f88].d != eax
edi = 0x10009f38
[ebp + 0xc {arg2}].d = edi
if (cond:1) then 21 @ 0x5923 else 37 @ 0x5917

edi = pop
eax = esi
esi = pop
ebx = pop
esp = ebp
ebp = pop
<return> jump(pop)

ebx = eax
goto 42 @ 0x5932

push(eax)
ebx = ebx | 0xffffffff
call(sub_55a0)
esp = esp + 4
goto 21 @ 0x5923

esi = [eax].d
eax = [0x10009f1c].d
if ([esi + 0x24].d == eax) then 45 @ 0x5944 else 53 @ 0x593e

push(esi)
edi = esp + 0x3c {var_30}
call(sub_3a10)
esi = eax
eax = [ebp + 8 {arg1}].d
ecx = 0xa
edi = esp + 0x14 {var_58}
if (flag:d) then 55 else 57

call([0x100080ec].d)
goto 45 @ 0x5944

edi, esi, ecx = __memcpy_u32(edi - (ecx << 2), esi - (ecx << 2), ecx << 2)
goto 59 @ 0x595e

edi, esi, ecx = __memcpy_u32(edi, esi, ecx << 2)
goto 59 @ 0x595e

ecx = [esp + 0x14 {var_58}].d
[eax].d = [eax].d + ecx
edx = [esp + 0x18 {var_54}].d
[eax + 4].d = [eax + 4].d + edx
ecx = [esp + 0x24 {var_48}].d
[eax + 0x10].d = [eax + 0x10].d + ecx
edx = [esp + 0x28 {var_44}].d
ecx = [esp + 0x30 {var_3c}].d
[eax + 0x14].d = [eax + 0x14].d + edx
[eax + 0x1c].d = [eax + 0x1c].d + ecx
edx = [esp + 0x34 {var_38}].d
ecx = [esp + 0x38 {var_34}].d
[eax + 0x20].d = [eax + 0x20].d + edx
[eax + 0x24].d = [eax + 0x24].d + ecx
ebx = ebx + 4
esp = esp + 4
cond:2 = [ebx].d != 0
eax = ebx
if (cond:2) then 42 @ 0x5932 else 78 @ 0x599b

eax = [ebp + 8 {arg1}].d
edi = pop
esi = pop
ebx = pop
esp = ebp
ebp = pop
<return> jump(pop)

int32_t (*)() sub_59b0()
push(ebx)
push(edi)
push(zx.d(0))
ebx = ebx | 0xffffffff
edi = 0x10009f38
call(sub_55a0)
esp = esp + 4
edi = pop
ebx = pop
<return> jump(pop)

int32_t sub_59d0(void* arg1, int32_t arg2)
push(ebx)
push(esi)
esi = [esp + 0xc {arg1}].d
cond:0 = esi != 0
push(edi)
if (cond:0) then 6 @ 0x59f8 else 13 @ 0x59db

eax = [esi + 0x454].d
push(eax)
call([0x1000800c].d), esp += 4
ebx = eax
temp0.d = ebx
cond:2 = temp0.d s<= 0
if (temp0.d != 0) then 16 @ 0x5a2d else 17 @ 0x5a0f

cond:1 = [0x10009f88].d != 0
esi = 0x10009f38
if (cond:1) then 6 @ 0x59f8 else 18 @ 0x59e9

if (cond:2) then 24 @ 0x5a8f else 28 @ 0x5a2f

if ([esp + 0x14 {arg2}].d == eax) then 24 @ 0x5a8f else 32 @ 0x5a11

push(zx.d(0))
ebx = ebx | 0xffffffff
edi = esi
call(sub_55a0)
esp = esp + 4
goto 6 @ 0x59f8

edi = pop
esi = pop
ebx = pop
<return> jump(pop)

edi = [esi + (ebx << 2) + 0x50].d
push(ebp)
ebp = [esp + 0x18 {arg2}].d
if (ebp == 0) then 37 @ 0x5a58 else 39 @ 0x5a3c

ecx = [esi + 0x454].d
push(zx.d(-1))
push(ecx)
call([0x10008030].d), esp += 8
if (eax != 0) then 24 @ 0x5a8f else 46 @ 0x5a24

[edi + 0xc].d = [edi + 0xc].d + 1
if ([edi + 0x14].d == 0) then 50 @ 0x5a6c else 53 @ 0x5a62

edx = [edi].d
eax = [esi + 0x454].d
edx = neg.d(edx)
push(edx)
push(eax)
call([0x10008030].d), esp += 8
if (eax != 0) then 37 @ 0x5a58 else 57 @ 0x5a52

edi = pop
esi = pop
ebx = pop
jump([0x100080ec].d)

cond:3 = ebp == 0
ebp = pop
if (cond:3) then 24 @ 0x5a8f else 59 @ 0x5a71

push(zx.d(0))
call(sub_5040)
esp = esp + 4
goto 50 @ 0x5a6c

call([0x100080ec].d)
goto 37 @ 0x5a58

[edi].d = -1
[edi + 4].d = 0
eax = [esi + (ebx << 2) + 0x50].d
call(sub_3f40)
[esi + (ebx << 2) + 0x50].d = 0
goto 24 @ 0x5a8f

void* sub_5aa0(void* arg1, int32_t arg2)
eax = [esp + 4 {arg1}].d
if (eax != 0) then 2 @ 0x5ada else 5 @ 0x5aa8

edx = [esp + 8 {arg2}].d
[eax + 0x4c].d = edx
<return> jump(pop)

cond:0 = [0x10009f88].d != eax
push(esi)
esi = 0x10009f38
if (cond:0) then 9 @ 0x5ad1 else 13 @ 0x5ab6

ecx = [esp + 0xc {arg2}].d
[esi + 0x4c {0x10009f84}].d = ecx
esi = pop
<return> jump(pop)

push(ebx)
push(edi)
push(eax)
ebx = ebx | 0xffffffff
edi = esi
call(sub_55a0)
eax = [esp + 0x18 {arg2}].d
esp = esp + 4
edi = pop
ebx = pop
[esi + 0x4c {0x10009f84}].d = eax
esi = pop
<return> jump(pop)

int32_t sub_5af0()
push(zx.d(0))
call(sub_5730)
esp = esp + 4
<return> jump(pop)

int32_t* sub_5b00()
push(zx.d(0))
call(sub_57a0)
ecx = pop
<return> jump(pop)

int32_t sub_5b10(int32_t arg1)
eax = [esp + 4 {arg1}].d
push(eax)
push(zx.d(0))
call(sub_5810)
esp = esp + 8
<return> jump(pop)

int32_t sub_5b20(int32_t arg1)
push(ebp)
ebp = esp {__saved_ebp}
esp = esp & 0xfffffff8
esp = esp - 0x28
push(esi)
push(edi)
eax = esp + 8 {var_30}
push(zx.d(0))
push(eax)
call(sub_58d0)
esi = eax
eax = [ebp + 8 {arg1}].d
esp = esp + 8
ecx = 0xa
edi = eax
if (flag:d) then 16 else 18

edi, esi, ecx = __memcpy_u32(edi - (ecx << 2), esi - (ecx << 2), ecx << 2)
goto 20 @ 0x5b48

edi, esi, ecx = __memcpy_u32(edi, esi, ecx << 2)
goto 20 @ 0x5b48

edi = pop
esi = pop
esp = ebp
ebp = pop
<return> jump(pop)

void sub_5b50(int32_t arg1)
if ([0x10009f88].d != 0) then 1 @ 0x5b79 else 4 @ 0x5b59

ecx = [esp + 4 {arg1}].d
[0x10009f84].d = ecx
<return> jump(pop)

push(ebx)
push(edi)
push(zx.d(0))
ebx = ebx | 0xffffffff
edi = 0x10009f38
call(sub_55a0)
eax = [esp + 0x10 {arg1}].d
esp = esp + 4
edi = pop
[0x10009f84].d = eax
ebx = pop
<return> jump(pop)

int32_t* __convention("regparm") sub_5b90(int32_t* arg1, int32_t* arg2 @ esi, void** arg3, int32_t* arg4)
cond:0 = eax == 0
push(ebp)
ebp = [esp + 8 {arg3}].d
if (cond:0) then 4 @ 0x5ba7 else 5 @ 0x5b9c

if ([esi].d != 0) then 6 @ 0x5bce else 13 @ 0x5ba9

if ([eax].d u>= 0x14) then 4 @ 0x5ba7 else 16 @ 0x5b9e

eax = [esi].d
ecx = [eax + 0x454].d
push(ecx)
call([0x1000800c].d), esp += 4
temp0.d = eax
cond:2 = temp0.d != 0
if (temp0.d s<= 0) then 18 @ 0x5bf4 else 19 @ 0x5be1

cond:1 = [0x10009f88].d != 0
[esi].d = 0x10009f38
if (cond:1) then 6 @ 0x5bce else 27 @ 0x5bb8

[eax].d = 0x14
goto 4 @ 0x5ba7

if (cond:2) then 37 @ 0x5c35 else 44 @ 0x5bf6

edx = [esi].d
eax = [edx + (eax << 2) + 0x50].d
ecx = [esp + 0xc {arg4}].d
[ebp].d = eax
eax = [eax].d
[ecx].d = eax
ebp = pop
<return> jump(pop)

push(ebx)
push(edi)
push(zx.d(0))
ebx = ebx | 0xffffffff
edi = 0x10009f38
call(sub_55a0)
esp = esp + 4
edi = pop
ebx = pop
goto 6 @ 0x5bce

edx = [esp + 0xc {arg4}].d
ecx = ecx | 0xffffffff
ecx = ecx - eax
[ebp].d = 0
[edx].d = ecx
ebp = pop
<return> jump(pop)

eax = [esi].d
call(sub_5240)
cond:3 = eax != 0
[ebp].d = eax
if (cond:3) then 49 @ 0x5c2b else 54 @ 0x5c04

edx = [eax].d
eax = [esp + 0xc {arg4}].d
[eax].d = edx
ebp = pop
<return> jump(pop)

edx = [esi].d
eax = [edx + 0x454].d
push(zx.d(-1))
push(eax)
call([0x10008030].d), esp += 8
if (eax != 0) then 60 @ 0x5c1f else 64 @ 0x5c19

ecx = [esp + 0xc {arg4}].d
[ecx].d = 0
ebp = pop
<return> jump(pop)

call([0x100080ec].d)
goto 60 @ 0x5c1f

int32_t sub_5c50(void* arg1)
push(ebx)
push(esi)
esi = [esp + 0xc {arg1}].d
cond:0 = esi != 0
push(edi)
if (cond:0) then 6 @ 0x5c78 else 13 @ 0x5c5b

eax = [esi + 0x454].d
push(eax)
call([0x1000800c].d), esp += 4
ebx = eax
temp0.d = ebx
cond:2 = temp0.d s<= 0
if (temp0.d != 0) then 16 @ 0x5ca7 else 17 @ 0x5c8b

cond:1 = [0x10009f88].d != 0
esi = 0x10009f38
if (cond:1) then 6 @ 0x5c78 else 22 @ 0x5c69

if (cond:2) then 28 @ 0x5cfb else 32 @ 0x5ca9

ecx = [esi + 0x454].d
push(zx.d(-1))
push(ecx)
call([0x10008030].d), esp += 8
if (eax != 0) then 28 @ 0x5cfb else 40 @ 0x5c9e

push(zx.d(0))
ebx = ebx | 0xffffffff
edi = esi
call(sub_55a0)
esp = esp + 4
goto 6 @ 0x5c78

edi = pop
esi = pop
ebx = pop
<return> jump(pop)

edi = [esi + (ebx << 2) + 0x50].d
edx = [edi].d
eax = [esi + 0x454].d
edx = neg.d(edx)
push(edx)
push(eax)
call([0x10008030].d), esp += 8
if (eax != 0) then 44 @ 0x5cc9 else 46 @ 0x5cc3

edi = pop
esi = pop
ebx = pop
jump([0x100080ec].d)

[edi + 0xc].d = [edi + 0xc].d + 1
if ([edi + 0x14].d == 0) then 48 @ 0x5cdd else 54 @ 0x5cd3

call([0x100080ec].d)
goto 44 @ 0x5cc9

[edi].d = -1
[edi + 4].d = 0
eax = [esi + (ebx << 2) + 0x50].d
call(sub_3f40)
[esi + (ebx << 2) + 0x50].d = 0
goto 28 @ 0x5cfb

push(zx.d(0))
call(sub_5040)
esp = esp + 4
goto 48 @ 0x5cdd

int32_t sub_5d00(int32_t arg1) __noreturn
push(ebp)
ebp = esp {var_4}
esp = esp - 0xc
push(ebx)
push(esi)
esi = [ebp + 0xc {arg1}].d
push(edi)
eax = esi << 2
call(sub_6950)
noreturn
{ Does not return }

void* sub_5e80(void* arg1)
esp = esp - 0xc
push(ebx)
push(ebp)
push(esi)
push(edi)
eax = esp + 0x10 {var_c}
push(eax)
ecx = esp + 0x18 {var_8}
push(ecx)
eax = esp + 0x30 {arg_c}
esi = esp + 0x28 {arg_4}
call(sub_5b90)
eax = [esp + 0x18 {var_c}].d
edx = [esp + 0x28 {arg_4}].d
ebx = [edx + (eax << 2) + 0x458].d
ebp = [esp + 0x2c {arg_8}].d
esi = ebx + 0x1cc
edi = ebp
edi = edi * [esp + 0x30 {arg_c}].d
[esp + 0x2c {arg_8}].d = eax
eax = [esi].d
esp = esp + 8
if (eax == 0) then 23 @ 0x5edc else 29 @ 0x5ecb

ecx = 1
edx = esi
temp0.d = [edx].d
[edx].d = ecx
ecx = temp0.d
if (ecx != 0) then 31 @ 0x5efb else 42 @ 0x5ee9

call([0x10008018].d)
if ([esi + 0x48].d != eax) then 31 @ 0x5efb else 46 @ 0x5ed6

ecx = [esp + 0x14 {var_8}].d
edx = [esp + 0x20 {arg_4}].d
push(edi)
eax = esp + 0x28 {arg_8}
push(eax)
push(ecx)
push(edx)
call(sub_3bc0)
esp = esp + 0x10
ebx = eax
goto 48 @ 0x5f15

call([0x10008018].d)
[esi + 0x48].d = eax
[esi + 0x44].d = 1
goto 48 @ 0x5f15

[esi + 0x44].d = [esi + 0x44].d + 1
goto 48 @ 0x5f15

ecx = [0x10009f1c].d
cond:0 = [ebx + 0x24].d == ecx
eax = [esp + 0x28 {arg_c}].d
[esp + 0x18 {var_4}].d = eax
if (cond:0) then 53 @ 0x5f32 else 62 @ 0x5f28

eax = [esp + 0x2c {arg1}].d
push(zx.d(3))
edx = esp + 0x1c {var_4}
push(edx)
push(ebp)
push(ebx)
call(sub_47c0)
esp = esp + 0x10
goto 65 @ 0x5f47

call([0x100080ec].d)
eax = 0
goto 65 @ 0x5f47

temp1.d = [ebx + 0x210].d
[ebx + 0x210].d = [ebx + 0x210].d - 1
cond:1 = temp1.d != 1
edi = pop
esi = pop
ecx = ebx + 0x1cc
ebp = pop
ebx = pop
if (cond:1) then 74 @ 0x5f65 else 76 @ 0x5f5a

esp = esp + 0xc
<return> jump(pop)

[ecx + 0x48].d = 0
edx = 0
temp0.d = [ecx].d
[ecx].d = edx
edx = temp0.d
goto 74 @ 0x5f65

void* sub_5f70(int32_t arg1)
esp = esp - 0xc
push(ebx)
push(esi)
push(edi)
eax = esp + 0xc {var_c}
push(eax)
ecx = esp + 0x18 {var_4}
push(ecx)
eax = esp + 0x2c {arg_c}
esi = esp + 0x24 {arg_4}
call(sub_5b90)
eax = [esp + 0x14 {var_c}].d
edx = [esp + 0x24 {arg_4}].d
edi = [edx + (eax << 2) + 0x458].d
esi = edi + 0x1cc
[esp + 0x18 {var_8}].d = eax
eax = [esi].d
ebx = [esp + 0x2c {arg_c}].d
esp = esp + 8
if (eax == 0) then 20 @ 0x5fc4 else 26 @ 0x5fb3

ecx = 1
edx = esi
temp0.d = [edx].d
[edx].d = ecx
ecx = temp0.d
if (ecx != 0) then 28 @ 0x5fe3 else 39 @ 0x5fd1

call([0x10008018].d)
if ([esi + 0x48].d != eax) then 28 @ 0x5fe3 else 43 @ 0x5fbe

ecx = [esp + 0x14 {var_4}].d
edx = [esp + 0x1c {arg_4}].d
push(ebx)
eax = esp + 0x14 {var_8}
push(eax)
push(ecx)
push(edx)
call(sub_3bc0)
esp = esp + 0x10
edi = eax
goto 45 @ 0x5ffd

call([0x10008018].d)
[esi + 0x48].d = eax
[esi + 0x44].d = 1
goto 45 @ 0x5ffd

[esi + 0x44].d = [esi + 0x44].d + 1
goto 45 @ 0x5ffd

eax = [esp + 0x20 {arg1}].d
if (eax == 0) then 47 @ 0x602b else 51 @ 0x6005

eax = ebx
ecx = edi
call(sub_4500)
goto 53 @ 0x6036

ecx = [0x10009f1c].d
if ([edi + 0x24].d == ecx) then 54 @ 0x601a else 60 @ 0x6010

if (eax == 0) then 63 @ 0x607b else 65 @ 0x6038

push(eax)
eax = [esp + 0x28 {arg_c}].d
ecx = edi
call(sub_49f0)
esp = esp + 4
goto 53 @ 0x6036

call([0x100080ec].d)
eax = 0
goto 53 @ 0x6036

eax = 0
goto 69 @ 0x607d

ecx = [eax - 4].d
edx = [0x10009f18].d
ecx = ecx & 0xfffffff8
if (edx == 0) then 77 @ 0x604d else 80 @ 0x604b

temp1.d = [edi + 0x210].d
[edi + 0x210].d = [edi + 0x210].d - 1
cond:0 = temp1.d != 1
ecx = edi + 0x1cc
edi = pop
esi = pop
ebx = pop
if (cond:0) then 81 @ 0x609a else 83 @ 0x608f

edx = [edi + 0x10].d
[0x10009f18].d = edx
goto 89 @ 0x6056

if ([edi + 0x10].d u>= edx) then 89 @ 0x6056 else 77 @ 0x604d

esp = esp + 0xc
<return> jump(pop)

[ecx + 0x48].d = 0
edx = 0
temp0.d = [ecx].d
[ecx].d = edx
edx = temp0.d
goto 81 @ 0x609a

edx = [0x10009f34].d
if (edx == 0) then 91 @ 0x6064 else 98 @ 0x6062

edx = [0x10009f20].d
ecx = ecx + edx
edx = edx - 1
edx = not.d(edx)
ecx = ecx & edx
[0x10009f34].d = ecx
goto 69 @ 0x607d

if (ecx u<= edx) then 69 @ 0x607d else 91 @ 0x6064

void sub_60a0(int32_t* arg1)
push(ecx)
push(ebx)
ebx = [esp + 0x10 {arg1}].d
if (ebx == 0) then 4 @ 0x6136 else 7 @ 0x60ae

ebx = pop
ecx = pop
<return> jump(pop)

push(ebp)
push(edi)
edx = ebx
ebp = 1
call(sub_1e60)
if (eax == 0) then 13 @ 0x60cd else 18 @ 0x60c0

push(ebx)
call([0x10009bd8].d)
esp = esp + 4
edi = eax
goto 23 @ 0x60db

edi = [ebx - 4].d
edi = edi & 0xfffffff8
ebp = 0
edi = edi - 8
goto 23 @ 0x60db

if (edi != 0) then 24 @ 0x60fb else 35 @ 0x60dd

push(esi)
eax = esp + 0x10 {__saved_ecx}
push(eax)
ecx = esp + 0x20 {arg1}
push(ecx)
eax = 0
esi = esp + 0x20 {arg_4}
call(sub_5b90)
eax = [esp + 0x24 {arg1}].d
esp = esp + 8
if (eax == 0) then 43 @ 0x613b else 44 @ 0x611c

push(0x10008230)
call([0x10008080].d)
eax = eax + 0x40
push(eax)
call([0x10008084].d)
esp = esp + 8
call([0x100080ec].d)
goto 24 @ 0x60fb

if (ebp == 0) then 46 @ 0x614d else 53 @ 0x613d

edx = edi - 0x14
if (edx u> 0x1ff4) then 43 @ 0x613b else 62 @ 0x6127

esi = pop
edi = pop
ebp = pop
eax = ebx
ebx = pop
esp = esp + 4
<return> tailcall(sub_3f40)

push(ebx)
call([0x10009094].d)
esp = esp + 4
esi = pop
edi = pop
ebp = pop
ebx = pop
ecx = pop
<return> jump(pop)

push(ebp)
push(edi)
esi = ebx
call(sub_5690)
esp = esp + 8
esi = pop
edi = pop
ebp = pop
goto 4 @ 0x6136

void* sub_6160(int32_t arg1, int32_t* arg2)
esp = esp - 8
eax = [esp + 0x10 {arg1}].d
eax = eax * [esp + 0x14 {arg2}].d
push(esi)
push(edi)
ecx = esp + 8 {var_8}
push(ecx)
edx = esp + 0x20 {arg2}
[esp + 0x1c {arg1}].d = eax
push(edx)
eax = esp + 0x20 {arg1}
esi = esp + 0x1c {arg_4}
call(sub_5b90)
edi = [esp + 0x24 {arg2}].d
esp = esp + 8
if (edi == 0) then 16 @ 0x61c9 else 24 @ 0x619c

eax = [esp + 8 {var_8}].d
edx = [esp + 0x14 {arg_4}].d
push(ebx)
ebx = [edx + (eax << 2) + 0x458].d
esi = ebx + 0x1cc
[esp + 0x10 {var_4}].d = eax
eax = [esi].d
if (eax == 0) then 25 @ 0x61fa else 31 @ 0x61e9

if ([esp + 0x18 {arg1}].d u> 0x2000) then 16 @ 0x61c9 else 33 @ 0x619e

ecx = 1
edx = esi
temp0.d = [edx].d
[edx].d = ecx
ecx = temp0.d
if (ecx != 0) then 39 @ 0x6219 else 51 @ 0x6207

call([0x10008018].d)
if ([esi + 0x48].d != eax) then 39 @ 0x6219 else 55 @ 0x61f4

eax = esp + 0x18 {arg1}
push(eax)
call(sub_2c50)
esi = eax
esp = esp + 4
if (esi == 0) then 16 @ 0x61c9 else 57 @ 0x61b1

eax = [esp + 0x1c {arg1}].d
edx = [esp + 0x20 {arg2}].d
push(eax)
eax = [esp + 0x1c {arg_4}].d
ecx = esp + 0x14 {var_4}
push(ecx)
push(edx)
push(eax)
call(sub_3bc0)
esp = esp + 0x10
ebx = eax
goto 63 @ 0x6237

call([0x10008018].d)
[esi + 0x48].d = eax
[esi + 0x44].d = 1
goto 63 @ 0x6237

[esi + 0x44].d = [esi + 0x44].d + 1
goto 63 @ 0x6237

ecx = [esp + 0x18 {arg1}].d
push(ecx)
push(zx.d(0))
push(esi)
call(sub_6938)
noreturn
{ Does not return }

ecx = [0x10009f1c].d
if ([ebx + 0x24].d == ecx) then 65 @ 0x624c else 71 @ 0x6242

edi = [esp + 0x1c {arg1}].d
eax = edi
ecx = ebx
call(sub_4500)
esi = eax
if (esi == 0) then 73 @ 0x6248 else 75 @ 0x6263

call([0x100080ec].d)
goto 73 @ 0x6248

eax = 0
goto 76 @ 0x62b3

if (([esi - 4].b & 3) == 0) then 82 @ 0x6271 else 86 @ 0x6265

temp1.d = [ebx + 0x210].d
[ebx + 0x210].d = [ebx + 0x210].d - 1
cond:0 = temp1.d != 1
ecx = ebx + 0x1cc
ebx = pop
if (cond:0) then 91 @ 0x62ce else 95 @ 0x62c3

eax = [esi - 4].d
ecx = [0x10009f18].d
eax = eax & 0xfffffff8
if (ecx == 0) then 101 @ 0x6286 else 104 @ 0x6284

push(edi)
push(zx.d(0))
push(esi)
call(sub_6938)
noreturn
{ Does not return }

edi = pop
esi = pop
esp = esp + 8
<return> jump(pop)

[ecx + 0x48].d = 0
edx = 0
temp0.d = [ecx].d
[ecx].d = edx
edx = temp0.d
goto 91 @ 0x62ce

edx = [ebx + 0x10].d
[0x10009f18].d = edx
goto 105 @ 0x628f

if ([ebx + 0x10].d u>= ecx) then 105 @ 0x628f else 101 @ 0x6286

ecx = [0x10009f34].d
if (ecx == 0) then 107 @ 0x629d else 114 @ 0x629b

ecx = [0x10009f20].d
eax = eax + ecx
ecx = ecx - 1
ecx = not.d(ecx)
eax = eax & ecx
[0x10009f34].d = eax
goto 115 @ 0x62b1

if (eax u<= ecx) then 115 @ 0x62b1 else 107 @ 0x629d

eax = esi
goto 76 @ 0x62b3

int32_t __stdcall sub_61be(int32_t arg1 @ esi, int32_t arg2, int32_t arg3) __pure
esp = esp + 0xc
edi = pop
eax = esi
esi = pop
esp = esp + 8
<return> jump(pop)

void* sub_62e0()
esp = esp - 0xc
push(esi)
push(edi)
eax = esp + 0xc {var_8}
push(eax)
ecx = esp + 0xc {var_c}
push(ecx)
eax = esp + 0x24 {arg_8}
esi = esp + 0x20 {arg_4}
call(sub_5b90)
edi = [esp + 0x10 {var_c}].d
esp = esp + 8
if (edi == 0) then 13 @ 0x6326 else 23 @ 0x630f

eax = [esp + 0xc {var_8}].d
ecx = [esp + 0x18 {arg_4}].d
edi = [ecx + (eax << 2) + 0x458].d
edx = [edi + 0x1cc].d
cond:0 = edx == 0
esi = edi + 0x1cc
push(ebx)
ebx = [esp + 0x20 {arg_8}].d
[esp + 0x14 {var_4}].d = eax
if (cond:0) then 24 @ 0x635f else 30 @ 0x634e

if ([esp + 0x1c {arg_8}].d u> 0x2000) then 13 @ 0x6326 else 32 @ 0x6311

eax = 1
ecx = esi
temp0.d = [ecx].d
[ecx].d = eax
eax = temp0.d
if (eax != 0) then 37 @ 0x637e else 48 @ 0x636c

call([0x10008018].d)
if ([esi + 0x48].d != eax) then 37 @ 0x637e else 52 @ 0x6359

edx = esp + 0x1c {arg_8}
push(edx)
call(sub_2c50)
esp = esp + 4
if (eax != 0) then 54 @ 0x6405 else 13 @ 0x6326

eax = [esp + 0xc {var_c}].d
ecx = [esp + 0x1c {arg_4}].d
push(ebx)
edx = esp + 0x18 {var_4}
push(edx)
push(eax)
push(ecx)
call(sub_3bc0)
esp = esp + 0x10
edi = eax
goto 58 @ 0x6398

call([0x10008018].d)
[esi + 0x48].d = eax
[esi + 0x44].d = 1
goto 58 @ 0x6398

[esi + 0x44].d = [esi + 0x44].d + 1
goto 58 @ 0x6398

edi = pop
esi = pop
esp = esp + 0xc
<return> jump(pop)

eax = ebx
ecx = edi
call(sub_4500)
cond:1 = eax == 0
ebx = pop
if (cond:1) then 64 @ 0x63e9 else 66 @ 0x63a6

eax = 0
goto 70 @ 0x63eb

ecx = [eax - 4].d
edx = [0x10009f18].d
ecx = ecx & 0xfffffff8
if (edx == 0) then 75 @ 0x63bb else 78 @ 0x63b9

temp1.d = [edi + 0x210].d
[edi + 0x210].d = [edi + 0x210].d - 1
cond:2 = temp1.d != 1
ecx = edi + 0x1cc
if (cond:2) then 54 @ 0x6405 else 79 @ 0x63fa

edx = [edi + 0x10].d
[0x10009f18].d = edx
goto 85 @ 0x63c4

if ([edi + 0x10].d u>= edx) then 85 @ 0x63c4 else 75 @ 0x63bb

[ecx + 0x48].d = 0
edx = 0
temp0.d = [ecx].d
[ecx].d = edx
edx = temp0.d
goto 54 @ 0x6405

edx = [0x10009f34].d
if (edx == 0) then 87 @ 0x63d2 else 94 @ 0x63d0

edx = [0x10009f20].d
ecx = ecx + edx
edx = edx - 1
edx = not.d(edx)
ecx = ecx & edx
[0x10009f34].d = ecx
goto 70 @ 0x63eb

if (ecx u<= edx) then 70 @ 0x63eb else 87 @ 0x63d2

void* sub_6410(int32_t* arg1)
push(ebx)
ebx = [esp + 8 {arg1}].d
push(esi)
push(edi)
esi = ebx
call(sub_2b00)
eax = ebx
call(sub_5390)
cond:0 = [ebx + 0x458].d == 0
esi = ebx + 0x458
if (cond:0) then 11 @ 0x644d else 15 @ 0x6434

edi = edi | 0xffffffff
temp1.d = [ebx + 0x44].d
[ebx + 0x44].d = [ebx + 0x44].d + edi
if (temp1.d != neg.d(edi)) then 17 @ 0x6462 else 21 @ 0x6455

edi = esi
goto 28 @ 0x6436

edx = [ebx + 0x454].d
push(edx)
call([0x10008024].d), esp += 4
if (eax != 0) then 35 @ 0x6479 else 45 @ 0x6473

[ebx + 0x48].d = 0
eax = 0
ecx = ebx
temp0.d = [ecx].d
[ecx].d = eax
eax = temp0.d
goto 17 @ 0x6462

eax = [edi].d
call(sub_2d40)
esi = esi + 4
[edi].d = 0
cond:1 = [esi].d != 0
edi = esi
if (cond:1) then 28 @ 0x6436 else 11 @ 0x644d

push(ebx)
push(zx.d(0))
call(sub_60a0)
esp = esp + 8
esi = 0x1000a3a0
call(sub_2b00)
esi = [0x1000a398].d
eax = [esi + 4].d
ecx = 0
if (eax u<= 0) then 47 @ 0x64ae else 65 @ 0x649d

call([0x100080ec].d)
goto 35 @ 0x6479

eax = eax - ecx
eax = eax + eax
eax = eax + eax
push(eax)
eax = esi + (ecx << 2) + 0xc
push(eax)
ecx = esi + (ecx << 2) + 8
push(ecx)
call([0x100080dc].d)
eax = [0x1000a398].d
esp = esp + 0xc
temp2.d = [eax + 4].d
[eax + 4].d = [eax + 4].d + edi
cond:2 = temp2.d != neg.d(edi)
edi = pop
esi = pop
ebx = pop
if (cond:2) then 67 @ 0x64ea else 70 @ 0x64d5

edx = esi + 8
goto 76 @ 0x64a2

temp3.d = [0x1000a3e4].d
[0x1000a3e4].d = [0x1000a3e4].d - 1
if (temp3.d != 1) then 77 @ 0x6506 else 78 @ 0x64f3

push(eax)
push(zx.d(0))
call(sub_60a0)
esp = esp + 8
[0x1000a398].d = 0
goto 67 @ 0x64ea

if ([edx].d == ebx) then 47 @ 0x64ae else 85 @ 0x64a4

<return> jump(pop)

[0x1000a3e8].d = 0
edx = 0
eax = 0x1000a3a0
temp0.d = [eax {0x1000a3a0}].d
[eax {0x1000a3a0}].d = edx
edx = temp0.d
goto 77 @ 0x6506

ecx = ecx + 1
edx = edx + 4
if (ecx u< eax) then 76 @ 0x64a2 else 47 @ 0x64ae

int32_t sub_6510(int32_t arg1, int32_t arg2, int32_t arg3) __noreturn
eax = [esp + 0xc {arg3}].d
ecx = [esp + 8 {arg2}].d
edx = [esp + 4 {arg1}].d
push(eax)
push(ecx)
push(edx)
push(zx.d(0))
call(sub_5d00)
noreturn
{ Does not return }

int32_t sub_6526() __pure
esp = esp + 0x10
<return> jump(pop)

void* sub_6530(int32_t arg1, int32_t arg2, int32_t arg3)
eax = [esp + 0xc {arg3}].d
ecx = [esp + 8 {arg2}].d
edx = [esp + 4 {arg1}].d
push(eax)
push(ecx)
push(edx)
push(zx.d(0))
call(sub_5e80)
esp = esp + 0x10
<return> jump(pop)

void* sub_6550(int32_t arg1, int32_t arg2)
eax = [esp + 8 {arg2}].d
ecx = [esp + 4 {arg1}].d
push(eax)
push(ecx)
push(zx.d(0))
call(sub_5f70)
esp = esp + 0xc
<return> jump(pop)

int32_t sub_6570(int32_t arg1)
eax = [esp + 4 {arg1}].d
push(eax)
push(zx.d(0))
call(sub_60a0)
esp = esp + 8
<return> jump(pop)

void* sub_6580(int32_t* arg1, int32_t arg2)
eax = [esp + 8 {arg2}].d
ecx = [esp + 4 {arg1}].d
push(eax)
push(ecx)
push(zx.d(0))
call(sub_6160)
esp = esp + 0xc
<return> jump(pop)

void* sub_65a0(int32_t arg1)
eax = [esp + 4 {arg1}].d
push(eax)
push(zx.d(0))
call(sub_62e0)
esp = esp + 8
<return> jump(pop)

void* sub_65b0(int32_t arg1, void** arg2, int32_t arg3)
esp = esp - 8
push(ebp)
ebp = [esp + 0x14 {arg2}].d
if (ebp != 0) then 4 @ 0x65d3 else 9 @ 0x65bc

push(ebx)
edx = ebp
[esp + 0x18 {arg2}].d = 1
call(sub_1e60)
if (eax == 0) then 18 @ 0x65fa else 23 @ 0x65e7

eax = [esp + 0x18 {arg3}].d
ecx = [esp + 0x10 {arg1}].d
push(eax)
push(ecx)
call(sub_62e0)
esp = esp + 8
ebp = pop
esp = esp + 8
<return> jump(pop)

push(ebp)
call([0x10009bd8].d)
esp = esp + 4
ebx = eax
goto 28 @ 0x6608

ebx = [ebp - 4].d
ebx = ebx & 0xfffffff8
[esp + 0x18 {arg2}].d = 0
ebx = ebx - 8
goto 28 @ 0x6608

if (ebx != 0) then 29 @ 0x66bf else 31 @ 0x660e

eax = [esp + 0x1c {arg3}].d
if (eax u> ebx) then 39 @ 0x662c else 51 @ 0x66cb

push(0x100081e8)
call([0x10008080].d)
eax = eax + 0x40
push(eax)
call([0x10008084].d)
esp = esp + 8
call([0x100080ec].d)
goto 39 @ 0x662c

push(esi)
push(edi)
eax = esp + 0x14 {var_4}
push(eax)
ecx = esp + 0x14 {var_8}
push(ecx)
eax = esp + 0x2c {arg3}
esi = esp + 0x24 {arg1}
call(sub_5b90)
edi = [esp + 0x18 {var_8}].d
esp = esp + 8
if (edi == 0) then 54 @ 0x670f else 56 @ 0x6654

edx = ebx
edx = edx - eax
if (edx u>= 0x400) then 39 @ 0x662c else 58 @ 0x66db

eax = [esp + 0x24 {arg3}].d
goto 63 @ 0x6713

eax = [esp + 0x24 {arg3}].d
if (eax == 0) then 63 @ 0x6713 else 79 @ 0x6665

ebx = pop
eax = ebp
ebp = pop
esp = esp + 8
<return> jump(pop)

edx = [esp + 0x20 {arg2}].d
ecx = [esp + 0x1c {arg1}].d
push(ebx)
push(edx)
edx = [esp + 0x1c {var_4}].d
ecx = [ecx + (edx << 2) + 0x458].d
edi = ebp
call(sub_53e0)
esp = esp + 8
edi = eax
edi = pop
esi = pop
ebx = pop
ebp = pop
esp = esp + 8
<return> jump(pop)

if (eax u> 0x2000) then 63 @ 0x6713 else 80 @ 0x666b

edx = esp + 0x24 {arg3}
push(edx)
call(sub_2c50)
edi = eax
esp = esp + 4
if (edi == 0) then 54 @ 0x670f else 86 @ 0x6682

eax = [esp + 0x24 {arg3}].d
if (ebx u>= eax) then 88 @ 0x668c else 93 @ 0x668a

push(eax)
push(ebp)
push(edi)
call(sub_693e)
noreturn
{ Does not return }

eax = ebx
goto 88 @ 0x668c

void sub_6740()
eax = 0
if ([0x1000a398].d == eax) then 2 @ 0x67b1 else 3 @ 0x674a

<return> jump(pop)

push(esi)
esi = 0x1000a3a0
call(sub_2b00)
eax = [0x1000a398].d
eax = [eax + 4].d
eax = (eax << 2) + &data_4
push(eax)
push(zx.d(0))
call(sub_62e0)
esi = eax
esp = esp + 8
if (esi == 0) then 15 @ 0x6792 else 18 @ 0x6775

temp1.d = [0x1000a3e4].d
[0x1000a3e4].d = [0x1000a3e4].d - 1
if (temp1.d != 1) then 27 @ 0x67ae else 30 @ 0x679b

eax = [0x1000a398].d
ecx = [eax + 4].d
edx = (ecx << 2) + &data_4
push(edx)
eax = eax + 8
push(eax)
push(esi)
call(sub_693e)
noreturn
{ Does not return }

eax = esi
esi = pop
goto 2 @ 0x67b1

[0x1000a3e8].d = 0
eax = 0
ecx = 0x1000a3a0
temp0.d = [ecx {0x1000a3a0}].d
[ecx {0x1000a3a0}].d = eax
eax = temp0.d
goto 27 @ 0x67ae

int32_t __stdcall sub_678f(int32_t arg1 @ esi, int32_t arg2)
esp = esp + 0xc
temp1.d = [0x1000a3e4].d
[0x1000a3e4].d = [0x1000a3e4].d - 1
if (temp1.d != 1) then 4 @ 0x67ae else 7 @ 0x679b

eax = esi
esi = pop
<return> jump(pop)

[0x1000a3e8].d = 0
eax = 0
ecx = 0x1000a3a0
temp0.d = [ecx {0x1000a3a0}].d
[ecx {0x1000a3a0}].d = eax
eax = temp0.d
goto 4 @ 0x67ae

void* sub_67c0(int32_t arg1, int32_t arg2)
push(ebx)
push(ebp)
push(esi)
push(edi)
ebp = 0
edi = 0
if ([0x1000a398].d != ebp) then 7 @ 0x6815 else 11 @ 0x67d0

esi = 0x1000a3a0
call(sub_2b00)
eax = [0x1000a398].d
goto 18 @ 0x6824

push(zx.d(0x4c))
push(zx.d(1))
push(ebp)
call(sub_6160)
ebx = eax
esp = esp + 0xc
if (ebx != ebp) then 20 @ 0x67ea else 29 @ 0x67e3

ecx = [eax].d
if ([eax + 4].d != ecx) then 35 @ 0x6873 else 42 @ 0x682b

[0x1000a3e8].d = ebp
[0x1000a3e4].d = ebp
esi = 0x1000a3a0
[0x1000a3a0].d = ebp
call(sub_2b00)
eax = ebx
[0x1000a398].d = eax
[ebx].d = 0x10
goto 18 @ 0x6824

edi = pop
esi = pop
ebp = pop
eax = 0
ebx = pop
<return> jump(pop)

push(0x460)
push(zx.d(1))
push(ebp)
call(sub_6160)
edi = eax
esp = esp + 0xc
if (edi == ebp) then 49 @ 0x68bf else 52 @ 0x6889

esi = (ecx << 2) + &data_4c
push(esi)
push(eax)
push(ebp)
call(sub_65b0)
esp = esp + 0xc
if (eax == ebp) then 49 @ 0x68bf else 58 @ 0x6841

temp1.d = [0x1000a3e4].d
[0x1000a3e4].d = [0x1000a3e4].d - 1
if (temp1.d != 1) then 69 @ 0x68d7 else 75 @ 0x68c8

edx = [esp + 0x14 {arg1}].d
ebx = [esp + 0x18 {arg2}].d
push(edx)
call(sub_55a0)
esp = esp + 4
if (eax != 0) then 82 @ 0x68aa else 88 @ 0x689e

ecx = [eax].d
edx = ecx << 2
edi = esi
edi = edi - edx
push(edi)
[0x1000a398].d = eax
eax = eax + (ecx << 2) + 8
push(ebp)
push(eax)
call(sub_6938)
noreturn
{ Does not return }

eax = edi
edi = pop
esi = pop
ebp = pop
ebx = pop
<return> jump(pop)

[0x1000a3e8].d = ebp
edx = 0
eax = 0x1000a3a0
temp0.d = [eax {0x1000a3a0}].d
[eax {0x1000a3a0}].d = edx
edx = temp0.d
goto 69 @ 0x68d7

eax = [0x1000a398].d
ecx = [eax + 4].d
[eax + (ecx << 2) + 8].d = edi
eax = [0x1000a398].d
[eax + 4].d = [eax + 4].d + 1
goto 49 @ 0x68bf

push(edi)
push(ebp)
call(sub_60a0)
esp = esp + 8
goto 49 @ 0x68bf

void* sub_68e0(void** arg1, int32_t arg2)
eax = [esp + 8 {arg2}].d
ecx = [esp + 4 {arg1}].d
push(eax)
push(ecx)
push(zx.d(0))
call(sub_65b0)
esp = esp + 0xc
<return> jump(pop)

int32_t sub_6900() __pure
eax = 0x2a
<return> jump(pop)

int32_t __convention("regparm") sub_6938(int32_t arg1) __noreturn
eax = adc.d(eax, 0x10008034, flag:c)
push(eax)
<return> tailcall(sub_693e)
{ Does not return }

int32_t sub_693e() __noreturn
ebx = pop
edi = 0
edi = edi ^ 0x1000f0cc
eax = edi
esi = 0x1000f0cc
esi = neg.d(esi)
<return> tailcall(sub_6950)
{ Does not return }

int32_t __convention("regparm") sub_6950(int32_t arg1, int32_t arg2 @ esi, int32_t* arg3 @ edi) __noreturn
eax = eax + esi
push(eax)
push(ebx)
push([edi].d)
edx = pop
edi = edi + 0x25
edi = edi - 0x21
goto 8 @ 0x695d

eax = zx.d([edi + edx - 1].b)
ecx = ebx + edx - 1
[ecx].b = 0
[ecx].b = [ecx].b + al
edx = edx - 1
if (edx != 0) then 8 @ 0x695d else 14 @ 0x6972

esi = pop
[esi + 1 {&data_0+1}].d = esi
call(esi)
al = al
[eax].b = [eax].b + al
breakpoint

void* const __convention("regparm") sub_6980(int32_t arg1)
push(ecx)
ecx = esp + 4 {__return_addr}
temp1.d = ecx {__return_addr}
ecx = ecx - eax
flag:c = temp1.d u< eax
eax = sbb.d(eax, eax, flag:c)
eax = not.d(eax)
ecx = ecx & eax
eax = esp {__saved_ecx}
eax = eax & 0xfffff000
goto 11 @ 0x6996

if (ecx u< eax) then 12 @ 0x69a2 else 15 @ 0x6998

eax = eax - &data_1000
[eax].d & eax
goto 11 @ 0x6996

eax = ecx
ecx = pop
temp0.d = esp {__return_addr}
esp = eax
eax = temp0.d {__return_addr}
eax = [eax {__return_addr}].d
[esp].d = eax
<return> jump(pop)

int32_t sub_6e9b(int32_t arg1 @ ebp, int32_t arg2 @ edi)
jump([edi + ebp].d)

int32_t __convention("regparm") sub_7189(char* arg1, char* arg2, uint8_t* arg3, void* arg4 @ ebp, int32_t* arg5 @ esi, void* const arg6 @ edi, void* arg7, char* arg8, char* arg9, uint8_t* arg10, char* arg11, int32_t arg12, int32_t arg13, int32_t arg14, uint8_t* arg15, int32_t* arg16, char* arg17, void* arg18, uint8_t* arg19)
temp1.b = [esi + 0x6f].b
[esi + 0x6f].b = [esi + 0x6f].b + al
flag:c = temp1.b + al u< temp1.b
flag:z = temp1.b == neg.b(al)
if (flag:c) then 5 @ 0x71fb else 6 @ 0x718e  {"atMessageW"}

if (flag:c) then 15 @ 0x7271 else 24 @ 0x71fd  {"itterm"}

edi = pop
esi = pop
ebp = pop
esp = esp + 4
ebx = pop
edx = pop
ecx = pop
eax = pop
if (flag:z) then 34 @ 0x71de else 35 @ 0x7191  {"essageW"}

esi = [esp + (esi << 1) + 0x65].d * 0x11006d72
bl = bl + [edi + 0x69].b
esi = __outsb(dx, [esi].b, esi, eflags)
esi = [esp + (esi << 1) + 0x65].d * 0x655f6d72
temp2.b = [0x6d615f01].b
[0x6d615f01].b = [0x6d615f01].b + bl
flag:c = temp2.b + bl u< temp2.b
flag:s = temp2.b + bl s< 0
goto 36 @ 0x728b  {"sg_exit"}

[edi + 0x73637705].b = [edi + 0x73637705].b + dl
temp0, eflags = __arpl_memw_gpr16([eax + 0x72].w, bp)
[eax + 0x72].w = temp0.w
temp3.b = [eax].b
[eax].b = [eax].b + al
flag:c = temp3.b + al u< temp3.b
flag:z = temp3.b == neg.b(al)
flag:s = temp3.b + al s< 0
flag:o = add_overflow(temp3.b, al)
if (flag:s) then 37 @ 0x720f else 39 @ 0x720a  {"swprintf_s"}  {"ntf_s"}

if (flag:d) then 40 else 44

if (not(flag:c)) then 48 @ 0x7207 else 53 @ 0x7194  {"ageW"}

if (not(flag:c)) then 80 @ 0x72f4 else 82 @ 0x728d  {"_exit"}  {"_lock"}

esi = __outsb(dx, [esi].b, esi, eflags)
if (flag:z) then 84 @ 0x7278 else 90 @ 0x7212

if (not(flag:c)) then 92 @ 0x7283 else 94 @ 0x720c  {"printf_s"}

[edi].b = [esi].b
edi = edi - 1
esi = esi - 1
goto 95 @ 0x71df

[edi].b = [esi].b
edi = edi + 1
esi = esi + 1
goto 95 @ 0x71df

temp4.b = [eax + 5].b
[eax + 5].b = [eax + 5].b + bh
flag:c = temp4.b + bh u< temp4.b
flag:o = add_overflow(temp4.b, bh)
goto 39 @ 0x720a  {"swprintf_s"}

edi = pop
esi = pop
ebp = pop
esp = esp + 4
ebx = pop
edx = pop
ecx = pop
eax = pop
push(edi)
[eax].b = [eax].b + al
ebx = ebx - 1
ebp = ebp + 1
push(edx)
esi = esi - 1
ebp = ebp + 1
esp = esp - 1
esi = esi ^ [edx].d
temp0, edi = __insb(edi, dx, eflags)
[edi].b = temp0.b
temp0, edi = __insb(edi, dx, eflags)
[edi].b = temp0.b
temp5.b = [eax].b
[eax].b = [eax].b + al
flag:c = temp5.b + al u< temp5.b
__out_immb_al(1, al, eflags)
ebp = ebp - 1
if (not(flag:c)) then 104 @ 0x7221 else 120 @ 0x71ae  {"ageBoxW"}  {"CR80.dll"}

edi = pop
goto 134 @ 0x72f5  {"lock"}

edi = pop
if (flag:s) then 140 @ 0x72fa else 151 @ 0x7291

[edx].d = adc.d([edx].d, eax, flag:c)
edi = pop
ebp = [esi + 0x69].d * 0x72657474
temp0, edi = __insd(edi, dx, eflags)
[edi].d = temp0.d
goto 92 @ 0x7283

edi = pop
goto 152 @ 0x7215

edi = pop
goto 156 @ 0x7284

if (flag:o) then 161 @ 0x7280 else 162 @ 0x720e  {"intf_s"}  {"erm_e"}

[edi + 0x5f].b = [edi + 0x5f].b + bl
ebp = [edi + 0x62].d * 0x6e75665f
temp0, eflags = __arpl_memw_gpr16([eax].w, ax)
[eax].w = temp0.w
ah = ah + ch
temp6.b = al
al = al + 0x66
flag:o = add_overflow(temp6.b, 0x66)
if (flag:o) then 164 @ 0x7263 else 166 @ 0x71f1  {"intf"}  {"_pointer"}

ebx = ebx + 1
push(edx)
[eax].b - dh
temp0, edi = __insb(edi, dx, eflags)
[edi].b = temp0.b
temp0, edi = __insb(edi, dx, eflags)
[edi].b = temp0.b
temp7.b = [edx + 1].b
[edx + 1].b = [edx + 1].b + dh
flag:o = add_overflow(temp7.b, dh)
edi = pop
esi = __outsb(dx, [gsbase + esi].b, esi, eflags)
temp0, eflags = __arpl_memw_gpr16([edi + 0x64].w, bp)
[edi + 0x64].w = temp0.w
edi = pop
goto 177 @ 0x7234  {"pointer"}

edi = pop
esi = pop
ebp = pop
esp = esp + 4
ebx = pop
edx = pop
ecx = pop
eax = pop
temp8.d = edx
edx = edx + 1
flag:s = temp8.d + 1 s< 0
flag:o = add_overflow(temp8.d, 1)
esi = __outsd(dx, [esi].d, esi, eflags)
if (flag:s) then 94 @ 0x720c else 178 @ 0x71b5  {"printf_s"}

temp0, edi = __insb(edi, dx, eflags)
[edi].b = temp0.b
esi = __outsd(dx, [esi].d, esi, eflags)
temp0, eflags = __arpl_memw_gpr16([ebx].w, bp)
[ebx].w = temp0.w
goto 140 @ 0x72fa

temp9.b = [ebx].b
[ebx].b = [ebx].b - al
flag:c = temp9.b u< al
flag:p = unimplemented
flag:z = temp9.b == al
flag:s = temp9.b - al s< 0
flag:o = add_overflow(temp9.b, neg.b(al))
edi = pop
esi = __outsd(dx, [esi].d, esi, eflags)
esi = __outsb(dx, [esi].b, esi, eflags)
if (flag:s) then 193 @ 0x736b else 194 @ 0x7302  {"stemTimeAsFileTime"}

goto 195 @ 0x7293

ah = ah + bl
temp10.b = al
al = al + 0x65
if (temp10.b + 0x65 s< 0) then 156 @ 0x7284 else 203 @ 0x721b

temp11.b = [gsbase + 0x6d615f01].b
[gsbase + 0x6d615f01].b = [gsbase + 0x6d615f01].b + bl
flag:c = temp11.b + bl u< temp11.b
flag:s = temp11.b + bl s< 0
goto 36 @ 0x728b  {"sg_exit"}

if (flag:c) then 204 @ 0x72f0 else 92 @ 0x7283

ebp = [esi + 0x74].d * 0x735f66
goto 152 @ 0x7215

edi = pop
goto 205 @ 0x7264  {"pointer"}

ebp = [esi + 0x74].d * 0x4c50066
edi = pop
esi = pop
ebp = pop
esp = esp + 4
ebx = pop
edx = pop
ecx = pop
eax = pop
__bound_gprv_mema32(ebp, [edi + 0x72].q)
goto 206 @ 0x71fe

if (flag:o) then 213 @ 0x72a5 else 218 @ 0x7236  {"inter"}

[ebp + 0x53].b = [ebp + 0x53].b + dl
ebp = ebp + 1
push(edx)
esi = esi ^ [edx].d
temp0, edi = __insb(edi, dx, eflags)
[edi].b = temp0.b
temp0, edi = __insb(edi, dx, eflags)
[edi].b = temp0.b
[eax].b = [eax].b + al
temp12.b = [0x6d6d656d].b
flag:c = temp12.b u< al
flag:z = temp12.b == al
flag:o = add_overflow(temp12.b, neg.b(al))
esi = __outsd(dx, [esi].d, esi, eflags)
if (flag:z || flag:c) then 235 @ 0x7230 else 238 @ 0x71cb  {"ode_pointer"}

if (not(flag:c)) then 243 @ 0x73e1 else 245 @ 0x736d  {"emTimeAsFileTime"}  {"Process"}

goto 248 @ 0x7304

[ebx].b = [ebx].b + dl
temp13.d = [edi + 0x61].d
[edi + 0x61].d = [edi + 0x61].d + ebx
flag:c = temp13.d + ebx u< temp13.d
flag:z = temp13.d == neg.d(ebx)
flag:s = temp13.d + ebx s< 0
push(zx.d(0x75))
if (not(flag:c)) then 249 @ 0x7311 else 252 @ 0x729d  {"_fdiv"}  {"dler4_common"}

goto 255 @ 0x721d

goto 258 @ 0x72f2

if (flag:o) then 260 @ 0x72d5 else 270 @ 0x7266  {"inter"}

temp0.d = edi
edi = eax
eax = temp0.d
eax = eax + 0x63736377
push(0x78000072)
eax = eax + 0x72707773
goto 162 @ 0x720e  {"intf_s"}

[edi + 0x5f].b = [edi + 0x5f].b + bl
temp14.d = ebx
ebx = ebx + 1
flag:o = add_overflow(temp14.d, 1)
if (flag:o) then 274 @ 0x731b else 285 @ 0x72ab  {"XcptFilter"}

ebp = [esi + 0x74].d * -0x6cff8d9b
temp15.b = bl
temp16.b = [edi + 0x6d].b
bl = bl + [edi + 0x6d].b
flag:c = temp15.b + temp16.b u< temp15.b
flag:z = temp15.b == neg.b(temp16.b)
flag:s = temp15.b + temp16.b s< 0
flag:o = add_overflow(temp15.b, temp16.b)
edi = pop
esi = pop
ebp = pop
esp = esp + 4
ebx = pop
edx = pop
ecx = pop
eax = pop
goto 301 @ 0x7241  {"lloc_crt"}

esi = __outsd(dx, [esi].d, esi, eflags)
edi = pop
goto 177 @ 0x7234  {"pointer"}

ah = ah + dh
temp17.b = al
al = al + 0x66
flag:c = temp17.b u>= 0x9a
if (flag:c) then 218 @ 0x7236 else 306 @ 0x71d1  {"inter"}

push(eax)
if (flag:c) then 316 @ 0x7453 else 317 @ 0x73e4  {"cess"}

temp0, edi = __insd(edi, dx, eflags)
[edi].d = temp0.d
goto 320 @ 0x736f  {"TimeAsFileTime"}

if (not(flag:p)) then 329 @ 0x7307 else 330 @ 0x7306  {"_except_handler4_common"}  {"except_handler4_common"}

temp0, edi = __insb(edi, dx, eflags)
[edi].b = temp0.b
goto 332 @ 0x7313  {"er4_common"}

edi = pop
si = [fsbase + esi].w * 0x6d00
goto 213 @ 0x72a5

[ebp + 0x53].b = [ebp + 0x53].b + cl
push(esi)
goto 104 @ 0x7221  {"CR80.dll"}

[edx].b = [edx].b + 0x5f
goto 134 @ 0x72f5  {"lock"}

esi = __outsb(dx, [esi].b, esi, eflags)
edi = pop
esi = pop
ebp = pop
esp = esp + 4
ebx = pop
edx = pop
ecx = pop
eax = pop
goto 333 @ 0x72d7

ebp = [esi + 0x74].d * 0x10007265
bl = bl + [edi + 0x69].b
esi = __outsb(dx, [esi].b, esi, eflags)
goto 15 @ 0x7271  {"itterm"}

esi = __outsd(dx, [esi].d, esi, eflags)
esi = __outsb(dx, [esi].b, esi, eflags)
temp18.b = [ebx + 1].b
[ebx + 1].b = [ebx + 1].b + dl
flag:c = temp18.b + dl u< temp18.b
edi = pop
temp0, eflags = __arpl_memw_gpr16([edx + 0x74].w, si)
[edx + 0x74].w = temp0.w
edi = pop
__bound_gprv_mema32(esi, [gsbase + ebp + 0x67].q)
if (flag:c) then 358 @ 0x738d else 363 @ 0x732e  {"hook"}  {"change"}

eax = pop
temp0, eflags = __arpl_memw_gpr16([eax + 0x74].w, si)
[eax + 0x74].w = temp0.w
temp19.d = esi
esi = esi + 1
flag:z = temp19.d == -1
flag:s = temp19.d + 1 s< 0
temp20.d = [esp + (esi << 1) + 0x65].d
ebp = [esp + (esi << 1) + 0x65].d * 0x8f0072
flag:c = unimplemented
flag:o = unimplemented
edi = pop
edi = pop
temp0, eflags = __arpl_memw_gpr16([ebp + 0x61].w, bp)
[ebp + 0x61].w = temp0.w
goto 370 @ 0x72be  {"n_type_info_names_internal"}

temp0, edi = __insb(edi, dx, eflags)
[edi].b = temp0.b
temp0, edi = __insb(edi, dx, eflags)
[edi].b = temp0.b
goto 373 @ 0x7243  {"oc_crt"}

[gsbase + eax].b = [gsbase + eax].b + al
temp21.d = ebx
temp22.d = [es.d + edi + 0x6d].d
ebx = ebx + [es.d + edi + 0x6d].d
flag:c = temp21.d + temp22.d u< temp21.d
flag:p = unimplemented
flag:z = temp21.d == neg.d(temp22.d)
flag:s = temp21.d + temp22.d s< 0
flag:o = add_overflow(temp21.d, temp22.d)
if (not(flag:c)) then 373 @ 0x7243 else 377 @ 0x71da  {"oc_crt"}

goto 378 @ 0x7455

temp0, eflags = __arpl_memw_gpr16([ebp + 0x73].w, sp)
[ebp + 0x73].w = temp0.w
goto 383 @ 0x73e9

push(esp)
ebp = [ebp + 0x65].d * 0x69467341
temp0, edi = __insb(edi, dx, eflags)
[edi].b = temp0.b
push(esp)
temp23.d = [ebp + 0x65].d
ebp = [ebp + 0x65].d * 0x49022900
flag:c = unimplemented
goto 396 @ 0x7381  {"nterlockedExchange"}

if (flag:s) then 245 @ 0x736d else 398 @ 0x730a  {"ept_handler4_common"}  {"emTimeAsFileTime"}

edi = pop
goto 329 @ 0x7307  {"except_handler4_common"}

if (flag:c) then 399 @ 0x734a else 400 @ 0x7316  {"_common"}

temp0, edi = __insb(edi, dx, eflags)
[edi].b = temp0.b
[eax].b = [eax].b + al
ebx = ebx + [edi + 0x75].d
esi = __outsb(dx, [esi].b, esi, eflags)
temp0, edi = __insb(edi, dx, eflags)
[edi].b = temp0.b
esi = __outsd(dx, [esi].d, esi, eflags)
temp0, eflags = __arpl_memw_gpr16([ebx].w, bp)
[ebx].w = temp0.w
edx:eax = sx.q(eax)
temp24.b = [edi + 0x5f].b
[edi + 0x5f].b = [edi + 0x5f].b + bl
flag:c = temp24.b + bl u< temp24.b
flag:p = unimplemented
flag:z = temp24.b == neg.b(bl)
flag:s = temp24.b + bl s< 0
flag:o = add_overflow(temp24.b, bl)
temp0, edi = __insb(edi, dx, eflags)
[edi].b = temp0.b
temp0, edi = __insb(edi, dx, eflags)
[edi].b = temp0.b
esi = __outsd(dx, [esi].d, esi, eflags)
esi = __outsb(dx, [esi].b, esi, eflags)
if (flag:s) then 406 @ 0x7359 else 204 @ 0x72f0  {"tProcessId"}

temp0, eflags = __arpl_memw_gpr16([eax + 0x61].w, bp)
[eax + 0x61].w = temp0.w
esi = __outsb(dx, [esi].b, esi, eflags)
[gsbase + bp.d + 3].b = [gsbase + bp.d + 3].b + dl
goto 407 @ 0x7396  {"Sleep"}

push(0x6b6f6f)
temp25.b = [ebx + 0x65755102].b
[ebx + 0x65755102].b = [ebx + 0x65755102].b + ah
flag:c = temp25.b + ah u< temp25.b
flag:z = temp25.b == neg.b(ah)
flag:s = temp25.b + ah s< 0
goto 409 @ 0x7339  {"ryPerformanceCounter"}

esi = __outsb(dx, [esi].b, esi, eflags)
edi = pop
if (flag:z) then 410 @ 0x733b else 412 @ 0x72c2  {"pe_info_names_internal"}  {"PerformanceCounter"}

esi = __outsd(dx, [esi].d, esi, eflags)
temp0, eflags = __arpl_memw_gpr16([edi + 0x63].w, bx)
[edi + 0x63].w = temp0.w
if (flag:c) then 413 @ 0x72bd else 422 @ 0x7249  {"an_type_info_names_internal"}

if (flag:p) then 301 @ 0x7241 else 433 @ 0x71dc  {"lloc_crt"}

[esi].b = [esi].b + dh
temp26.d = eax
eax = eax + 0x636d656d
flag:o = add_overflow(temp26.d, 0x636d656d)
if (flag:o) then 435 @ 0x74d7 else 442 @ 0x745e

[esi + 3].b = [esi + 3].b + ch
esp = esp - 1
esi = __outsd(dx, [esi].d, esi, eflags)
edi = pop
esi = pop
ebp = pop
esp = esp + 4
ebx = pop
edx = pop
ecx = pop
eax = pop
esp = esp - 1
goto 450 @ 0x73f1  {"ibraryA"}

esi = __outsb(dx, [esi].b, esi, eflags)
if (flag:z) then 383 @ 0x73e9 else 452 @ 0x7384  {"rlockedExchange"}

if (flag:o) then 396 @ 0x7381 else 453 @ 0x730d  {"_handler4_common"}  {"nterlockedExchange"}

if (flag:z) then 456 @ 0x73b1 else 457 @ 0x734c  {"xchange"}

edi = pop
temp0, eflags = __arpl_memw_gpr16([edi + 0x6d].w, bp)
[edi + 0x6d].w = temp0.w
temp0, edi = __insd(edi, dx, eflags)
[edi].d = temp0.d
goto 274 @ 0x731b

if (flag:z) then 458 @ 0x73ab else 461 @ 0x735b  {"rocessId"}  {"mpareExchange"}

push(ebx)
goto 462 @ 0x7397  {"leep"}

if (flag:c) then 465 @ 0x73b4 else 410 @ 0x733b  {"PerformanceCounter"}  {"ange"}

push(eax)
if (flag:c) then 476 @ 0x73a5 else 484 @ 0x733f  {"ormanceCounter"}  {"ckedCompareExchange"}

if (flag:o) then 486 @ 0x7329 else 487 @ 0x72c4  {"_info_names_internal"}  {"gger_hook"}

edi = pop
esi = pop
ebp = pop
esp = esp + 4
ebx = pop
edx = pop
ecx = pop
eax = pop
goto 370 @ 0x72be  {"n_type_info_names_internal"}

temp27.b = [ebx + 1].b
[ebx + 1].b = [ebx + 1].b + dh
flag:z = temp27.b == neg.b(dh)
flag:s = temp27.b + dh s< 0
edi = pop
esi = __outsb(dx, [gsbase + esi].b, esi, eflags)
temp0, eflags = __arpl_memw_gpr16([edi + 0x64].w, bp)
[edi + 0x64].w = temp0.w
edi = pop
esi = __outsb(dx, [esi].b, esi, eflags)
if (not(flag:z)) then 487 @ 0x72c4 else 494 @ 0x7258  {"_info_names_internal"}

[eax].b = [eax].b + al
goto 34 @ 0x71de

[eax].b = [eax].b + al
temp28.d = [eax].d
eax = [eax].d * 0
flag:c = unimplemented
[ebx].b = adc.b([ebx].b, ch, flag:c)
[eax + 0x5000005e {0x5000005e}].b = [eax + 0x5000005e {0x5000005e}].b + ah
goto 504 @ 0x74e5

[eax].b = [eax].b + al
[eax].b = [eax].b + al
[eax].b = [eax].b + al
[eax].b = [eax].b + al
[eax].b = [eax].b + al
[eax].b = [eax].b + al
[eax].b = [eax].b + al
undefined

esp = [edx + 0x72].d * 0x41797261
goto 505 @ 0x73f8

if (flag:c) then 514 @ 0x73f2 else 516 @ 0x7386  {"ockedExchange"}  {"braryA"}

edi = pop
push(0x6c646e61)
goto 332 @ 0x7313  {"er4_common"}

if (flag:s) then 522 @ 0x7416 else 525 @ 0x73b3  {"hange"}  {"ceptionFilter"}

goto 527 @ 0x734e

temp0, edi = __insd(edi, dx, eflags)
[edi].d = temp0.d
if (flag:o) then 536 @ 0x740f else 538 @ 0x73ae  {"reExchange"}  {"ndledExceptionFilter"}

if (flag:c) then 539 @ 0x73cc else 540 @ 0x735d  {"cessId"}  {"raryCalls"}

temp0, edi = __insb(edi, dx, eflags)
[edi].b = temp0.b
goto 543 @ 0x739c

edi = pop
esi = pop
ebp = pop
esp = esp + 4
ebx = pop
edx = pop
ecx = pop
eax = pop
esi = __outsb(dx, [esi].b, esi, eflags)
[gsbase + bx.d + si.d].b = [gsbase + bx.d + si.d].b + al
goto 549 @ 0x73ba

temp0, eflags = __arpl_memw_gpr16([ebx + 0x65].w, bp)
[ebx + 0x65].w = temp0.w
temp29.d = ebx
ebx = ebx + 1
flag:s = temp29.d + 1 s< 0
flag:o = add_overflow(temp29.d, 1)
esi = __outsd(dx, [esi].d, esi, eflags)
goto 458 @ 0x73ab  {"mpareExchange"}

esi = __outsd(dx, [esi].d, esi, eflags)
if (flag:c) then 552 @ 0x73af else 557 @ 0x7342  {"anceCounter"}  {"eExchange"}

if (flag:c) then 358 @ 0x738d else 363 @ 0x732e  {"hook"}  {"change"}

edi = pop
temp30.d = [esi + 0x66].d
ebp = [esi + 0x66].d * 0x616e5f6f
flag:c = unimplemented
temp0, edi = __insd(edi, dx, eflags)
[edi].d = temp0.d
if (not(flag:c)) then 570 @ 0x732f else 577 @ 0x72d0  {"internal"}

temp0, edi = __insb(edi, dx, eflags)
[edi].b = temp0.b
temp31.b = [eax + 1].b
[eax + 1].b = [eax + 1].b + ch
flag:o = add_overflow(temp31.b, ch)
edi = pop
temp0, eflags = __arpl_memw_gpr16([gsbase + edi + 0x64].w, bp)
[gsbase + edi + 0x64].w = temp0.w
edi = pop
goto 205 @ 0x7264  {"pointer"}

goto 579 @ 0x74e7

[eax].b = [eax].b + al
[eax].b = [eax].b + al
[eax].b = [eax].b + al
[eax].b = [eax].b + al
[eax].b = [eax].b + al
[eax].b = [eax].b + al
[eax].b = [eax].b + al
edx = edx - 1
goto 595 @ 0x7407

__bound_gprv_mema32(esi, [edx + 0x61].q)
if (flag:c) then 599 @ 0x7470 else 607 @ 0x73f7

esi = __outsd(dx, [esi].d, esi, eflags)
temp0, eflags = __arpl_memw_gpr16([ebx + 0x65].w, bp)
[ebx + 0x65].w = temp0.w
temp32.d = ebp
ebp = ebp + 1
if (temp32.d + 1 s< 0) then 450 @ 0x73f1 else 609 @ 0x738e  {"hange"}  {"ibraryA"}

temp0, eflags = __arpl_memw_gpr16([ebp + 0x70].w, sp)
[ebp + 0x70].w = temp0.w
if (flag:z) then 612 @ 0x7484 else 617 @ 0x741b  {"onFilter"}

push(0x65676e61)
goto 624 @ 0x73b8

ebx = ebx + 1
temp33.d = [edi + 0x65].d
[edi + 0x65].d = [edi + 0x65].d + eax
flag:c = temp33.d + eax u< temp33.d
flag:p = unimplemented
flag:z = temp33.d == neg.d(eax)
flag:s = temp33.d + eax s< 0
flag:o = add_overflow(temp33.d, eax)
if (flag:z) then 462 @ 0x7397 else 626 @ 0x7354  {"urrentProcessId"}  {"leep"}

esi = __outsb(dx, [esi].b, esi, eflags)
goto 627 @ 0x7410  {"dledExceptionFilter"}

if (flag:c) then 630 @ 0x7415 else 631 @ 0x73b0  {"Exchange"}  {"xceptionFilter"}

if (flag:c) then 636 @ 0x742f else 637 @ 0x73ce  {"ryCalls"}  {"rPresent"}

temp0, eflags = __arpl_memw_gpr16([ebp + 0x73].w, sp)
[ebp + 0x73].w = temp0.w
if (not(flag:c)) then 458 @ 0x73ab else 638 @ 0x7362  {"mpareExchange"}

temp34.b = cl
temp35.b = [es.d + ecx + 0x6e].b
cl = cl + [es.d + ecx + 0x6e].b
flag:c = temp34.b + temp35.b u< temp34.b
flag:z = temp34.b == neg.b(temp35.b)
if (flag:z) then 595 @ 0x7407 else 645 @ 0x73a2  {"rlockedCompareExchange"}

eax = [eax].d
esp = esp + 1
goto 646 @ 0x73bd  {"isableThreadLibraryCalls"}

temp36.d = ebp
ebp = ebp + 1
flag:z = temp36.d == -1
flag:s = temp36.d + 1 s< 0
goto 456 @ 0x73b1  {"xchange"}

edi = pop
esi = pop
ebp = pop
esp = esp + 4
ebx = pop
edx = pop
ecx = pop
eax = pop
esi = __outsb(dx, [esi].b, esi, eflags)
temp0, eflags = __arpl_memw_gpr16([ebp + 0x43].w, sp)
[ebp + 0x43].w = temp0.w
esi = __outsd(dx, [esi].d, esi, eflags)
if (not(flag:z)) then 624 @ 0x73b8 else 399 @ 0x734a

esi = __outsd(dx, [esi].d, esi, eflags)
esi = __outsd(dx, [esi].d, esi, eflags)
temp37.d = [eax].d
eax = [eax].d * 0
flag:c = unimplemented
[0x65755102].d = eax
goto 409 @ 0x7339  {"ryPerformanceCounter"}

ebp = [esi + 0x74].d * 0x616e7265
goto 333 @ 0x72d7

[eax + 0x71].b = [eax + 0x71].b + ah
[eax].b = [eax].b + al
al = [-0xffffffff80000070].b
esi = __outsb(dx, [esi].b, esi, eflags)
[eax].b = [eax].b + al
[ebp].b = [ebp].b + ch
al = al + dl
push(0x72e00000)
[eax].b = [eax].b + al
[edi].b = [edi].b ^ ah
[eax + 0x10000067].b = [eax + 0x10000067].b + ah
push(0x5dd00000)
temp38.b = [eax].b
[eax].b = [eax].b + al
flag:o = add_overflow(temp38.b, al)
if (flag:o) then 650 @ 0x7581 else 719 @ 0x7512

temp39.d = edx
temp40.d = [ebx + 0x65].d
edx = edx + [ebx + 0x65].d
if (temp39.d == neg.d(temp40.d)) then 722 @ 0x7461 else 732 @ 0x740c  {"nhandledExceptionFilter"}

[eax].b = [eax].b + al
[eax].b = [eax].b + al
push(zx.d(cs))
eax = eax
[ecx].b = [ecx].b + al
[eax].b = [eax].b + al
[edi].b = [edi].b + ah
goto 735 @ 0x747d

ecx = ecx + 1
goto 505 @ 0x73f8

push(0x65676e61)
[esi + 3].b = [esi + 3].b + dl
goto 407 @ 0x7396  {"Sleep"}

[ebx - 0x73dc0000].b = cl
[eax].b = [eax].b + al
[eax + eax + 0x790000].b = ror.b([eax + eax + 0x790000].b, 0)
[eax + eax].b = [eax + eax].b u>> 0
goto 738 @ 0x7498

esi = __outsd(dx, [esi].d, esi, eflags)
esi = __outsb(dx, [esi].b, esi, eflags)
esi = esi + 1
temp41.d = [esp + (esi << 1) + 0x65].d
ebp = [esp + (esi << 1) + 0x65].d * 0x2390072
flag:c = unimplemented
goto 749 @ 0x7426  {"IsDebuggerPresent"}

[eax].b = [eax].b + al
goto 549 @ 0x73ba

if (not(flag:z)) then 755 @ 0x73c8 else 757 @ 0x7356  {"rentProcessId"}  {"dLibraryCalls"}

temp0, edi = __insb(edi, dx, eflags)
[edi].b = temp0.b
goto 758 @ 0x7412  {"edExceptionFilter"}

if (flag:s) then 763 @ 0x747a else 766 @ 0x7417  {"eptionFilter"}

temp42.d = ebp
ebp = ebp + 1
flag:z = temp42.d == -1
flag:s = temp42.d + 1 s< 0
goto 456 @ 0x73b1  {"xchange"}

if (flag:c) then 767 @ 0x7481 else 774 @ 0x7431  {"resent"}

if (flag:c) then 775 @ 0x7449 else 779 @ 0x73d0  {"Calls"}

dl = dl + cl
temp43.d = [edi + 0x65].d
[edi + 0x65].d = [edi + 0x65].d + eax
flag:c = temp43.d + eax u< temp43.d
flag:z = temp43.d == neg.d(eax)
flag:s = temp43.d + eax s< 0
if (flag:z) then 646 @ 0x73bd else 781 @ 0x736a  {"ystemTimeAsFileTime"}  {"isableThreadLibraryCalls"}

if (flag:c) then 627 @ 0x7410 else 782 @ 0x73a4  {"ockedCompareExchange"}  {"dledExceptionFilter"}

esi = [ebx + 0x61].d * 0x54656c62
push(0x64616572)
esp = esp - 1
goto 784 @ 0x73ca  {"ibraryCalls"}

es = [eax].w
[eax - 0x72].b = [eax - 0x72].b + bh
[eax].b = [eax].b + al
[esi - 0x71740000].d = [esi - 0x71740000].d
[ebx - 0x43ffff72].b = [ebx - 0x43ffff72].b + ah
es = [eax].w
cl = cl + cl
es = [eax].w
ah = ah + dl
es = [eax].w
cl = cl + ch
es = [eax].w
dl = dl + bh
es = [eax].w
[edx].b = [edx].b + cl
[eax].d = pop
[esi].b = [esi].b + dl
[eax].d = pop
[ebx].b = [ebx].b + ah
[eax].d = pop
[edi].b = [edi].b + ch
[eax].d = pop
[ebx].b = [ebx].b + bh
[eax].d = pop
[eax - 0x71].b = [eax - 0x71].b + cl
[eax].b = [eax].b + al
push(ebx)
[eax].d = pop
[edi - 0x71].b = [edi - 0x71].b + bl
[eax].b = [eax].b + al
[eax].b = [eax].b + al
[eax].d = [eax].d + eax
al = al + [eax].b
eax = eax + [eax].d
al = al
eax = eax + 0x7000600
[eax].b = [eax].b + cl
[ecx].b = [ecx].b + cl
[edx].b = [edx].b + cl
[ebx].b = [ebx].b + cl
[eax + eax].b = [eax + eax].b + cl
eax = eax | 0xf000e00
[eax].b = [eax].b + dl
[ecx].b = [ecx].b + dl
[edx].b = [edx].b + dl
[ebx].b = [ebx].b + dl
temp44.b = [eax + eax].b
[eax + eax].b = [eax + eax].b + dl
flag:c = temp44.b + dl u< temp44.b
eax = adc.d(eax, 0x17001600, flag:c)
[eax].b = [eax].b + bl
[ecx].b = [ecx].b + bl
[edx].b = [edx].b + bl
[ebx].b = [ebx].b + bl
temp45.b = [eax + eax].b
[eax + eax].b = [eax + eax].b + bl
flag:c = temp45.b + bl u< temp45.b
eax = sbb.d(eax, 0x1f001e00, flag:c)
[eax].b = [eax].b + ah
[ecx].b = [ecx].b + ah
[edx].b = [edx].b + ah
[ebx].b = [ebx].b + ah
[eax + eax].b = [eax + eax].b + ah
temp46.d = eax
eax = eax & 0x75002600
flag:c = 0
flag:z = (temp46.d & 0x75002600) == 0
flag:o = 0
if (flag:z) then 786 @ 0x7682 else 801 @ 0x7619  {"l.dll"}

[eax].b = [eax].b + al
eax = eax + 1
goto 830 @ 0x7517

[eax].b = [eax].b + al
[eax].b = [eax].b + al
[eax].b = [eax].b + al
[eax].b = [eax].b + al
[eax].b = [eax].b + al
temp47.b = bl
temp48.b = bl
bl = bl + bl
flag:c = temp47.b + temp48.b u< temp47.b
goto 834 @ 0x746d

esi = __outsb(dx, [esi].b, esi, eflags)
push(0x6c646e61)
goto 758 @ 0x7412  {"edExceptionFilter"}

[eax].b = [eax].b + al
[edi].b = [edi].b + ah
goto 767 @ 0x7481

push(eax)
push(ecx)
push(edx)
push(ebx)
push(esp)
push(ebp)
push(esi)
push(edi)
eax = eax - 0x1fa00000
[eax].b = [eax].b + al
undefined

temp49.d = ecx
ecx = ecx - 1
flag:p = unimplemented
flag:s = temp49.d - 1 s< 0
flag:o = add_overflow(temp49.d, -1)
if (not(flag:c)) then 834 @ 0x746d else 835 @ 0x7429  {"ebuggerPresent"}

esp = esp - 1
goto 784 @ 0x73ca  {"ibraryCalls"}

if (flag:c) then 646 @ 0x73bd else 837 @ 0x7358  {"ntProcessId"}  {"isableThreadLibraryCalls"}

temp50.d = ebp
ebp = ebp + 1
flag:s = temp50.d + 1 s< 0
flag:o = add_overflow(temp50.d, 1)
goto 630 @ 0x7415  {"xceptionFilter"}

[eax].b = [eax].b + al
al, eflags = __daa(al, eflags)
goto 735 @ 0x747d

if (flag:o) then 839 @ 0x748e else 842 @ 0x741a  {"ionFilter"}

[eax].b = [eax].b + al
[eax + 0x2400008b].b = [eax + 0x2400008b].b + cl
[eax].w = es
al = al + al
[eax].w = es
[eax].b = [eax].b + al
goto 844 @ 0x7493

if (flag:c) then 738 @ 0x7498 else 848 @ 0x7433  {"sent"}

eax = eax ^ [eax].d
[edx].b = [edx].b + bh
eax = eax + 0x736d656d
goto 849 @ 0x7452

ebx = ebx + 1
goto 850 @ 0x73d1  {"alls"}

if (not(flag:s)) then 861 @ 0x73df else 862 @ 0x736c  {"temTimeAsFileTime"}  {"teProcess"}

esi = __outsd(dx, [esi].d, esi, eflags)
goto 476 @ 0x73a5  {"ckedCompareExchange"}

esp = [edx + 0x72].d * 0x43797261
goto 850 @ 0x73d1  {"alls"}

esi = __outsd(dx, [esi].d, esi, eflags)
temp0, eflags = __arpl_memw_gpr16([eax].w, ax)
[eax].w = temp0.w
esi = __outsb(dx, [esi].b, esi, eflags)
temp0, eflags = __arpl_memw_gpr16([fsbase + edx + 0x65].w, si)
[fsbase + edx + 0x65].w = temp0.w
edi = pop
esi = pop
ebp = pop
esp = esp + 4
ebx = pop
edx = pop
ecx = pop
eax = pop
if (flag:z) then 863 @ 0x76f3 else 870 @ 0x768e  {"pool"}

temp0, edi = __insb(edi, dx, eflags)
[edi].b = temp0.b
temp0, edi = __insb(edi, dx, eflags)
[edi].b = temp0.b
temp0, edi = __insb(edi, dx, eflags)
[edi].b = temp0.b
temp51.b = [edi].b
[edi].b = [edi].b + bh
flag:c = temp51.b + bh u< temp51.b
esi = __outsb(dx, [esi].b, esi, eflags)
ebp = ebp + 1
esi = __outsb(dx, [esi].b, esi, eflags)
edi = pop
esi = pop
ebp = pop
esp = esp + 4
ebx = pop
edx = pop
ecx = pop
eax = pop
__bound_gprv_mema32(ebp, [ebp + 0x44].q)
esp = esp - 1
esp = esp - 1
temp52.d = edi
edi = edi - 1
flag:z = temp52.d == 1
flag:s = temp52.d - 1 s< 0
flag:o = add_overflow(temp52.d, -1)
if (flag:z || flag:c) then 871 @ 0x7693 else 873 @ 0x762e  {"rride@@YAHXZ"}  {"neddestroypool"}

[eax - 0x5fffff8b].b = [eax - 0x5fffff8b].b + dh
push(zx.d(0))
al = al + ah
goto 874 @ 0x7523

if (flag:c) then 880 @ 0x744a else 883 @ 0x746f

__bound_gprv_mema32(esi, [gsbase + ebp + 0x67].q)
if (flag:c) then 767 @ 0x7481 else 774 @ 0x7431  {"resent"}

esi = __outsb(dx, [esi].b, esi, eflags)
goto 406 @ 0x7359  {"tProcessId"}

[eax].b = [eax].b + al
[ecx].b = [ecx].b + bh
goto 844 @ 0x7493

ebp = [edi + 0x6e].d * 0x746c6946
goto 885 @ 0x7424

al = al + al
al = al
[eax + 0x2d].b = [eax + 0x2d].b + ah
goto 888 @ 0x749a

if (not(flag:c)) then 888 @ 0x749a else 891 @ 0x7435

goto 378 @ 0x7455

edi = pop
esi = pop
ebp = pop
esp = esp + 4
ebx = pop
edx = pop
ecx = pop
eax = pop
temp0, edi = __insb(edi, dx, eflags)
[edi].b = temp0.b
goto 893 @ 0x73d3

if (flag:z) then 896 @ 0x7446 else 243 @ 0x73e1  {"Process"}  {"ler3"}

if (flag:z) then 893 @ 0x73d3 else 899 @ 0x736e  {"mTimeAsFileTime"}

temp53.b = [esi + 0x65].b
[esi + 0x65].b = [esi + 0x65].b + ch
flag:z = temp53.b == neg.b(ch)
temp54.d = [fsbase + esi + 0x64].d
ebp = [fsbase + esi + 0x64].d * 0x6e657065
flag:c = unimplemented
goto 902 @ 0x76fe  {"dent_comalloc"}

if (flag:o) then 904 @ 0x76ff else 906 @ 0x7690  {"ent_comalloc"}

esi = __outsb(dx, [esi].b, esi, eflags)
if (not(flag:c)) then 915 @ 0x770e else 918 @ 0x769a  {"roypool"}  {"dmallinfo"}

if (flag:c) then 919 @ 0x76a2 else 921 @ 0x7630  {"ide@@YAHXZ"}  {"neddestroysyspool"}

[eax + 0x6b].b = [eax + 0x6b].b + dl
[eax].b = [eax].b + al
[ecx].b = [ecx].b u>> 1
[edi].b = [edi].b + dl
eax = eax
goto 939 @ 0x752f

[eax].b = [eax].b + al
al - [0x736d656d].b
goto 849 @ 0x7452

esp = esp - 1
goto 599 @ 0x7470

temp55.d = [edx].d
flag:c = temp55.d u< eax
goto 749 @ 0x7426  {"IsDebuggerPresent"}

[eax].b = [eax].b + al
al = [-0xfffffffff000001f].b
goto 950 @ 0x74a1

esi = __outsb(dx, [esi].b, esi, eflags)
goto 953 @ 0x7438

temp0, edi = __insb(edi, dx, eflags)
[edi].b = temp0.b
goto 954 @ 0x73d6

temp0, edi = __insb(edi, dx, eflags)
[edi].b = temp0.b
goto 961 @ 0x7447

temp0, edi = __insd(edi, dx, eflags)
[edi].d = temp0.d
goto 320 @ 0x736f  {"TimeAsFileTime"}

esi = __outsb(dx, [gsbase + esi].b, esi, eflags)
goto 962 @ 0x7701  {"t_comalloc"}

esi = __outsb(dx, [gsbase + esi].b, esi, eflags)
goto 962 @ 0x7701  {"t_comalloc"}

esi = __outsd(dx, [esi].d, esi, eflags)
temp0, edi = __insb(edi, dx, eflags)
[edi].b = temp0.b
temp56.b = [esi + 0x65].b
[esi + 0x65].b = [esi + 0x65].b + ch
flag:c = temp56.b + ch u< temp56.b
flag:z = temp56.b == neg.b(ch)
flag:s = temp56.b + ch s< 0
if (not(flag:c)) then 915 @ 0x770e else 918 @ 0x769a  {"roypool"}  {"dmallinfo"}

temp0, edi = __insd(edi, dx, eflags)
[edi].d = temp0.d
goto 963 @ 0x7710  {"allinfo"}

if (flag:c) then 980 @ 0x770b else 984 @ 0x769c  {"ypool"}

esi = __outsb(dx, [esi].b, esi, eflags)
if (not(flag:c)) then 985 @ 0x771d else 991 @ 0x76a9  {"roysyspool"}  {"lloc"}

esp = [ebp + 0x40].d * 0x48415940
eax = pop
edx = pop
temp57.b = [ebp + 0x70].b
[ebp + 0x70].b = [ebp + 0x70].b + al
flag:c = temp57.b + al u< temp57.b
flag:z = temp57.b == neg.b(al)
flag:s = temp57.b + al s< 0
flag:o = add_overflow(temp57.b, al)
edi = pop
esi = pop
ebp = pop
esp = esp + 4
ebx = pop
edx = pop
ecx = pop
eax = pop
if (flag:z) then 992 @ 0x76a4 else 993 @ 0x7641  {"hInNedmallocDLL"}  {"ddestroysyspool"}

[ebx].b = [ebx].b + dh
eax = eax
[ecx - 0x73].b = [ecx - 0x73].b + cl
[eax].b = [eax].b + al
ebp = pop
eax = eax
[eax - 0x73].b = [eax - 0x73].b + ch
temp58.b = [eax].b
[eax].b = [eax].b + al
flag:c = temp58.b + al u< temp58.b
if (not(flag:c)) then 1014 @ 0x74cf else 1016 @ 0x7542

al
[eax - 0x3fffff8b].b = [eax - 0x3fffff8b].b + al
goto 1019 @ 0x74ab

if (flag:p) then 1021 @ 0x743b else 1022 @ 0x743a  {"_except_handler3"}  {"except_handler3"}

esi = pop
edx = edx + [ebp + 0x72].d
temp0, edi = __insd(edi, dx, eflags)
[edi].d = temp0.d
ebp = [esi + 0x61].d * 0x72506574
esi = __outsd(dx, [esi].d, esi, eflags)
goto 317 @ 0x73e4  {"cess"}

if (flag:c) then 735 @ 0x747d else 880 @ 0x744a

if (flag:z) then 1024 @ 0x7762 else 1027 @ 0x7703  {"comalloc"}  {"c_trim"}

edi = pop
esi = pop
ebp = pop
esp = esp + 4
ebx = pop
edx = pop
ecx = pop
eax = pop
temp0, edi = __insb(edi, dx, eflags)
[edi].b = temp0.b
temp0, edi = __insb(edi, dx, eflags)
[edi].b = temp0.b
temp59.d = [esi + 0x66].d
ebp = [esi + 0x66].d * 0x656e006f
flag:c = unimplemented
flag:o = unimplemented
goto 1048 @ 0x771a  {"dmalloc"}

temp60.b = [esi + 0x65].b
[esi + 0x65].b = [esi + 0x65].b + ch
flag:z = temp60.b == neg.b(ch)
goto 915 @ 0x770e  {"dmallinfo"}

if (not(flag:s)) then 915 @ 0x770e else 1059 @ 0x769e  {"dmallinfo"}

temp0, edi = __insb(edi, dx, eflags)
[edi].b = temp0.b
temp0, edi = __insb(edi, dx, eflags)
[edi].b = temp0.b
esi = __outsd(dx, [esi].d, esi, eflags)
goto 1070 @ 0x7720

if (flag:c) then 1048 @ 0x771a else 1073 @ 0x76ab  {"ysyspool"}  {"dmalloc"}

if (not(flag:c)) then 985 @ 0x771d else 991 @ 0x76a9  {"roysyspool"}  {"lloc"}

push(0x654e6e49)
temp0, edi = __insd(edi, dx, eflags)
[edi].d = temp0.d
edi = pop
esi = pop
ebp = pop
esp = esp + 4
ebx = pop
edx = pop
ecx = pop
eax = pop
temp0, edi = __insb(edi, dx, eflags)
[edi].b = temp0.b
temp0, edi = __insb(edi, dx, eflags)
[edi].b = temp0.b
esi = __outsd(dx, [esi].d, esi, eflags)
temp0, eflags = __arpl_memw_gpr16([esp + (ecx << 1) + 0x4c].w, ax)
[esp + (ecx << 1) + 0x4c].w = temp0.w
temp61.b = [eax + 0x61].b
[eax + 0x61].b = [eax + 0x61].b + dl
if (temp61.b == neg.b(dl)) then 1074 @ 0x76b8 else 1078 @ 0x7655  {"hInNedmallocDLL"}  {"isablethreadcache"}

al = al + dh
goto 1110 @ 0x74d1

temp62.b = [eax].b
[eax].b = [eax].b + al
if (temp62.b s>= neg.b(al)) then 1112 @ 0x74d3 else 1119 @ 0x7546

[eax].b = [eax].b + dl
goto 1124 @ 0x74af

if (flag:s) then 950 @ 0x74a1 else 1128 @ 0x743e  {"ept_handler3"}

edi = pop
goto 1021 @ 0x743b  {"except_handler3"}

temp0, eflags = __arpl_memw_gpr16([edi + 0x74].w, bx)
[edi + 0x74].w = temp0.w
if (flag:c) then 1129 @ 0x77d0 else 1135 @ 0x7767

temp0, eflags = __arpl_memw_gpr16([edi + 0x6d].w, bp)
[edi + 0x6d].w = temp0.w
edi = pop
esi = pop
ebp = pop
esp = esp + 4
ebx = pop
edx = pop
ecx = pop
eax = pop
temp0, edi = __insb(edi, dx, eflags)
[edi].b = temp0.b
temp0, edi = __insb(edi, dx, eflags)
[edi].b = temp0.b
esi = __outsd(dx, [esi].d, esi, eflags)
temp0, eflags = __arpl_memw_gpr16([eax].w, ax)
[eax].w = temp0.w
esi = __outsb(dx, [esi].b, esi, eflags)
temp0, edi = __insd(edi, dx, eflags)
[edi].d = temp0.d
goto 963 @ 0x7710  {"allinfo"}

temp0, edi = __insd(edi, dx, eflags)
[edi].d = temp0.d
edi = pop
esi = pop
ebp = pop
esp = esp + 4
ebx = pop
edx = pop
ecx = pop
eax = pop
goto 985 @ 0x771d  {"lloc"}

esi = __outsd(dx, [esi].d, esi, eflags)
esi = __outsd(dx, [esi].d, esi, eflags)
temp0, edi = __insb(edi, dx, eflags)
[edi].b = temp0.b
temp63.b = [esi + 0x65].b
[esi + 0x65].b = [esi + 0x65].b + ch
flag:c = temp63.b + ch u< temp63.b
flag:z = temp63.b == neg.b(ch)
flag:s = temp63.b + ch s< 0
flag:o = add_overflow(temp63.b, ch)
goto 992 @ 0x76a4  {"ddestroysyspool"}

temp0, eflags = __arpl_memw_gpr16([eax].w, ax)
[eax].w = temp0.w
goto 1158 @ 0x7722  {"nedmalloc_footprint"}

if (not(flag:s)) then 1070 @ 0x7720 else 1179 @ 0x76ad  {"yspool"}

temp64.d = [ebx + 0x61].d
esi = [ebx + 0x61].d * 0x74656c62
flag:c = unimplemented
goto 1180 @ 0x76bf  {"hreadcache"}

push(0x654e6e49)
temp0, edi = __insd(edi, dx, eflags)
[edi].d = temp0.d
edi = pop
esi = pop
ebp = pop
esp = esp + 4
ebx = pop
edx = pop
ecx = pop
eax = pop
temp0, edi = __insb(edi, dx, eflags)
[edi].b = temp0.b
temp0, edi = __insb(edi, dx, eflags)
[edi].b = temp0.b
esi = __outsd(dx, [esi].d, esi, eflags)
temp0, eflags = __arpl_memw_gpr16([esp + (ecx << 1) + 0x4c].w, ax)
[esp + (ecx << 1) + 0x4c].w = temp0.w
temp65.b = [edi + 0x69].b
[edi + 0x69].b = [edi + 0x69].b + dl
flag:z = temp65.b == neg.b(dl)
esi = __outsb(dx, [esi].b, esi, eflags)
push(eax)
edi = pop
esi = pop
ebp = pop
esp = esp + 4
ebx = pop
edx = pop
ecx = pop
eax = pop
if (flag:z) then 1185 @ 0x76cf else 1191 @ 0x766c

push(zx.d(0))
goto 1112 @ 0x74d3

[eax].b = [eax].b + ah
[cs.d + eax].b = [cs.d + eax].b + al
[ebx].b = [ebx].b + ch
[eax].b = [eax].b + dl
eax = [eax].d * 0
al = [0x5000005e].b
goto 504 @ 0x74e5

[eax].b = [eax].b + al
ecx = [ebp - 0x72660000].d
[eax].b = [eax].b + al
al = [esi].b
if (flag:d) then 1202 else 1204

[eax].b = [eax].b + dl
[gsbase + eax].b = [gsbase + eax].b + al
push(eax)
goto 1206 @ 0x74b5

if (flag:o) then 1206 @ 0x74b5 else 1212 @ 0x7441  {"_handler3"}

temp66.b = [esi + 0x65].b
[esi + 0x65].b = [esi + 0x65].b + ch
flag:c = temp66.b + ch u< temp66.b
flag:z = temp66.b == neg.b(ch)
flag:o = add_overflow(temp66.b, ch)
goto 1215 @ 0x77d3  {"dpmalloc"}

temp0, edi = __insd(edi, dx, eflags)
[edi].d = temp0.d
temp67.b = [esi + 0x65].b
[esi + 0x65].b = [esi + 0x65].b + ch
flag:c = temp67.b + ch u< temp67.b
flag:z = temp67.b == neg.b(ch)
flag:o = add_overflow(temp67.b, ch)
temp0, edi = __insd(edi, dx, eflags)
[edi].d = temp0.d
edi = pop
esi = pop
ebp = pop
esp = esp + 4
ebx = pop
edx = pop
ecx = pop
eax = pop
temp0, edi = __insb(edi, dx, eflags)
[edi].b = temp0.b
temp0, edi = __insb(edi, dx, eflags)
[edi].b = temp0.b
esi = __outsd(dx, [esi].d, esi, eflags)
if (flag:o) then 1216 @ 0x77e7 else 1218 @ 0x7773  {"footprint"}

esi = __outsb(dx, [esi].b, esi, eflags)
temp0, edi = __insd(edi, dx, eflags)
[edi].d = temp0.d
edi = pop
esi = pop
ebp = pop
esp = esp + 4
ebx = pop
edx = pop
ecx = pop
eax = pop
temp0, edi = __insb(edi, dx, eflags)
[edi].b = temp0.b
temp0, edi = __insb(edi, dx, eflags)
[edi].b = temp0.b
esi = __outsd(dx, [esi].d, esi, eflags)
temp0, eflags = __arpl_memw_gpr16([edi + 0x66].w, bx)
[edi + 0x66].w = temp0.w
esi = __outsd(dx, [esi].d, esi, eflags)
esi = __outsd(dx, [esi].d, esi, eflags)
if (flag:z) then 1240 @ 0x77a1 else 1242 @ 0x7731  {"rint"}  {"nt_calloc"}

if (not(flag:s)) then 1158 @ 0x7722 else 1243 @ 0x76af  {"pool"}  {"nedmalloc_footprint"}

push(0x64616572)
temp0, eflags = __arpl_memw_gpr16([ecx + 0x63].w, sp)
[ecx + 0x63].w = temp0.w
push(0x656e0065)
if (flag:c) then 1244 @ 0x7735 else 1252 @ 0x76d0

temp68.b = [gsbase + esi + 0x65].b
[gsbase + esi + 0x65].b = [gsbase + esi + 0x65].b + ch
flag:c = temp68.b + ch u< temp68.b
flag:z = temp68.b == neg.b(ch)
flag:o = add_overflow(temp68.b, ch)
goto 1258 @ 0x76d4  {"dgetvalue"}

push(0x6e007265)
__bound_gprv_mema32(ebp, [fsbase + ebx + (ebp << 1) + 0x73].q)
temp69.d = [edx + 0x65].d
edi = [edx + 0x65].d * 0x64656e00
flag:c = unimplemented
flag:o = unimplemented
temp0, eflags = __arpl_memw_gpr16([ecx + 0x6c].w, sp)
[ecx + 0x6c].w = temp0.w
temp0, edi = __insb(edi, dx, eflags)
[edi].b = temp0.b
goto 786 @ 0x7682

esi = esi - 1
goto 1259 @ 0x7551

esi = esi + 1
goto 1259 @ 0x7551

temp0, edi = __insb(edi, dx, eflags)
[edi].b = temp0.b
temp70.b = [eax].b
[eax].b = [eax].b + al
flag:o = add_overflow(temp70.b, al)
if (flag:o) then 939 @ 0x752f else 1284 @ 0x74ba

edi = pop
push(0x6c646e61)
goto 961 @ 0x7447

if (flag:o) then 1288 @ 0x7843 else 1290 @ 0x77d6  {"alloc"}  {"nedpsetvalue"}

esi = __outsw(dx, [esi].w, esi, eflags)
goto 1307 @ 0x77e9  {"otprint"}

temp71.b = [esi + 0x65].b
[esi + 0x65].b = [esi + 0x65].b + ch
flag:z = temp71.b == neg.b(ch)
temp0, edi = __insd(edi, dx, eflags)
[edi].d = temp0.d
temp0, edi = __insd(edi, dx, eflags)
[edi].d = temp0.d
edi = pop
esi = pop
ebp = pop
esp = esp + 4
ebx = pop
edx = pop
ecx = pop
eax = pop
temp0, edi = __insb(edi, dx, eflags)
[edi].b = temp0.b
temp72.d = [edi + 0x6e].d
esp = [edi + 0x6e].d * 0x64656e00
flag:c = unimplemented
flag:o = unimplemented
if (flag:o) then 1309 @ 0x77e8 else 1311 @ 0x7785  {"alloc"}  {"ootprint"}

esi = __outsb(dx, [esi].b, esi, eflags)
goto 1328 @ 0x77a2  {"t_calloc"}

if (flag:c) then 1329 @ 0x779c else 1330 @ 0x7733  {"pendent_calloc"}

if (flag:o) then 1070 @ 0x7720 else 1332 @ 0x76b1

temp73.b = [esi + 0x65].b
[esi + 0x65].b = [esi + 0x65].b + ch
flag:c = temp73.b + ch u< temp73.b
flag:z = temp73.b == neg.b(ch)
flag:o = add_overflow(temp73.b, ch)
temp0, edi = __insd(edi, dx, eflags)
[edi].d = temp0.d
goto 1340 @ 0x773a  {"alloc_internals"}

temp74.b = [gsbase + esi + 0x65].b
[gsbase + esi + 0x65].b = [gsbase + esi + 0x65].b + ch
flag:c = temp74.b + ch u< temp74.b
flag:z = temp74.b == neg.b(ch)
flag:o = add_overflow(temp74.b, ch)
goto 1258 @ 0x76d4  {"dgetvalue"}

if (flag:z) then 1357 @ 0x774f else 1365 @ 0x76d9  {"alue"}  {"lloc_stats"}

eax = eax
dl = dl + al
eax = eax
dl = dl + cl
eax = eax
dh = dh + dl
eax = eax
ah = ah + ch
eax = eax
[esi + (ecx << 2)].b = [esi + (ecx << 2)].b + al
temp75.b = [eax].b
[eax].b = [eax].b + al
flag:c = temp75.b + al u< temp75.b
[esi - 0x71e60000].b = adc.b([esi - 0x71e60000].b, cl, flag:c)
[eax].b = [eax].b + al
es = [cs.d + eax].w
[edx - 0x72].b = [edx - 0x72].b + al
[eax].b = [eax].b + al
push(edx)
es = [eax].w
[ecx - 0x72].b = [ecx - 0x72].b + ah
[eax].b = [eax].b + al
temp0, edi = __insb(edi, dx, eflags)
[edi].b = temp0.b
goto 650 @ 0x7581

[eax].b = [eax].b + al
[eax + eax].b = [eax + eax].b & bh
[eax].b = [eax].b + dh
goto 1376 @ 0x74c3

esi = __outsb(dx, [esi].b, esi, eflags)
if (flag:o) then 1378 else 1379 @ 0x7848  {"etvalue"}

edi = pop
esi = pop
ebp = pop
esp = esp + 4
ebx = pop
edx = pop
ecx = pop
eax = pop
temp0, edi = __insb(edi, dx, eflags)
[edi].b = temp0.b
temp0, edi = __insb(edi, dx, eflags)
[edi].b = temp0.b
esi = __outsd(dx, [esi].d, esi, eflags)
temp0, eflags = __arpl_memw_gpr16([eax].w, ax)
[eax].w = temp0.w
esi = __outsb(dx, [esi].b, esi, eflags)
if (flag:o) then 1380 @ 0x784e else 1385 @ 0x77e1  {"alloc_footprint"}

esi = __outsd(dx, [esi].d, esi, eflags)
if (flag:z) then 1401 @ 0x785c else 1402 @ 0x77ec  {"rint"}  {"edsetvalue"}

esi = __outsd(dx, [esi].d, esi, eflags)
goto 1307 @ 0x77e9  {"otprint"}

edi = pop
esi = pop
ebp = pop
esp = esp + 4
ebx = pop
edx = pop
ecx = pop
eax = pop
temp0, edi = __insb(edi, dx, eflags)
[edi].b = temp0.b
temp0, edi = __insb(edi, dx, eflags)
[edi].b = temp0.b
esi = __outsd(dx, [esi].d, esi, eflags)
temp0, eflags = __arpl_memw_gpr16([eax].w, ax)
[eax].w = temp0.w
esi = __outsb(dx, [esi].b, esi, eflags)
if (flag:o) then 1403 @ 0x77f6 else 1412 @ 0x7790  {"alloc_stats"}

if (flag:z) then 1413 @ 0x7803 else 1414 @ 0x77a4  {"calloc"}  {"edpmalloc_trim"}

if (flag:o) then 1413 @ 0x7803 else 1420 @ 0x779e  {"ndent_calloc"}  {"edpmalloc_trim"}

esi = __outsb(dx, [esi].b, esi, eflags)
goto 1423 @ 0x7736  {"nedmalloc_internals"}

esi = __outsd(dx, [esi].d, esi, eflags)
temp0, edi = __insb(edi, dx, eflags)
[edi].b = temp0.b
[esi + 0x65].b = [esi + 0x65].b + ch
temp76.d = [fsbase + ebx + 0x61].d
esi = [fsbase + ebx + 0x61].d * 0x74656c62
flag:c = unimplemented
goto 1180 @ 0x76bf  {"hreadcache"}

edi = pop
esi = pop
ebp = pop
esp = esp + 4
ebx = pop
edx = pop
ecx = pop
eax = pop
temp0, edi = __insb(edi, dx, eflags)
[edi].b = temp0.b
temp0, edi = __insb(edi, dx, eflags)
[edi].b = temp0.b
esi = __outsd(dx, [esi].d, esi, eflags)
temp0, eflags = __arpl_memw_gpr16([edi + 0x69].w, bx)
[edi + 0x69].w = temp0.w
esi = __outsb(dx, [esi].b, esi, eflags)
goto 1427 @ 0x7742  {"ternals"}

temp0, edi = __insb(edi, dx, eflags)
[edi].b = temp0.b
temp0, edi = __insb(edi, dx, eflags)
[edi].b = temp0.b
esi = __outsd(dx, [esi].d, esi, eflags)
temp0, eflags = __arpl_memw_gpr16([edi + 0x73].w, bx)
[edi + 0x73].w = temp0.w
if (flag:z) then 1428 @ 0x77b8 else 1430 @ 0x7757  {"nt_comalloc"}

edi = pop
esi = pop
ebp = pop
esp = esp + 4
ebx = pop
edx = pop
ecx = pop
eax = pop
temp0, edi = __insb(edi, dx, eflags)
[edi].b = temp0.b
if (not(flag:z)) then 1427 @ 0x7742 else 1431 @ 0x76dd  {"ternals"}

[eax].b = [eax].b + dl
goto 1439 @ 0x74c7

jump(&data_78bb)

if (flag:z) then 1443 else 1444 @ 0x784b  {"alue"}

temp77.b = [gsbase + esi + 0x65].b
[gsbase + esi + 0x65].b = [gsbase + esi + 0x65].b + ch
flag:c = temp77.b + ch u< temp77.b
flag:z = temp77.b == neg.b(ch)
goto 1455 @ 0x7852  {"drealloc"}

edi = pop
esi = pop
ebp = pop
esp = esp + 4
ebx = pop
edx = pop
ecx = pop
eax = pop
temp0, edi = __insb(edi, dx, eflags)
[edi].b = temp0.b
temp0, edi = __insb(edi, dx, eflags)
[edi].b = temp0.b
esi = __outsd(dx, [esi].d, esi, eflags)
temp0, eflags = __arpl_memw_gpr16([edi + 0x66].w, bx)
[edi + 0x66].w = temp0.w
goto 1309 @ 0x77e8  {"ootprint"}

if (not(flag:c)) then 1456 else 1457 @ 0x7860  {"tvalue"}

if (flag:c) then 1458 @ 0x7857 else 1465 @ 0x77ee

edi = pop
esi = pop
ebp = pop
esp = esp + 4
ebx = pop
edx = pop
ecx = pop
eax = pop
goto 1467 @ 0x77f7  {"lloc_stats"}

if (flag:c) then 1467 @ 0x77f7 else 1475 @ 0x7792  {"lloc_stats"}

if (flag:o) then 1481 @ 0x7874 else 1484 @ 0x7807  {"alloc_trim"}  {"cache"}

temp0, eflags = __arpl_memw_gpr16([ecx + 0x6c].w, sp)
[ecx + 0x6c].w = temp0.w
temp0, edi = __insb(edi, dx, eflags)
[edi].b = temp0.b
esi = __outsd(dx, [esi].d, esi, eflags)
goto 1500 @ 0x77a9

esi = __outsb(dx, [esi].b, esi, eflags)
esi = __outsb(dx, [gsbase + esi].b, esi, eflags)
goto 1328 @ 0x77a2  {"t_calloc"}

esi = __outsb(dx, [esi].b, esi, eflags)
temp0, edi = __insd(edi, dx, eflags)
[edi].d = temp0.d
goto 1340 @ 0x773a  {"alloc_internals"}

if (flag:z) then 1500 @ 0x77a9 else 1504 @ 0x7744  {"rnals"}

esi = __outsb(dx, [esi].b, esi, eflags)
goto 1505 @ 0x77b9  {"t_comalloc"}

if (flag:z) then 1506 @ 0x77cc else 1511 @ 0x7759  {"info"}

temp78.b = [esi + 0x65].b
[esi + 0x65].b = [esi + 0x65].b + ch
flag:z = temp78.b == neg.b(ch)
temp79.d = [fsbase + esi + 0x64].d
ebp = [fsbase + esi + 0x64].d * 0x6e657065
flag:o = unimplemented
esi = __outsb(dx, [gsbase + esi].b, esi, eflags)
if (flag:z) then 1530 @ 0x774c else 1533 @ 0x76ed  {"calloc"}  {"dmalloc_stats"}

[eax].b = [eax].b + ah
eax = [eax].d * 0
al = [-0xfffffffff0000075].b
goto 1110 @ 0x74d1

jump(&data_78c1)

edi = pop
esi = pop
ebp = pop
esp = esp + 4
ebx = pop
edx = pop
ecx = pop
eax = pop
temp0, edi = __insb(edi, dx, eflags)
[edi].b = temp0.b
if (not(flag:z)) then 1545 else 1546 @ 0x784f

if (flag:c) then 1551 else 1552 @ 0x7855  {"alloc"}

jump(&data_78c5)

if (flag:z) then 1563 else 1564 @ 0x7862  {"alue"}

temp0, edi = __insb(edi, dx, eflags)
[edi].b = temp0.b
esi = __outsd(dx, [esi].d, esi, eflags)
temp0, eflags = __arpl_memw_gpr16([eax].w, ax)
[eax].w = temp0.w
esi = __outsb(dx, [esi].b, esi, eflags)
goto 1401 @ 0x785c  {"edsetvalue"}

esi = __outsb(dx, [esi].b, esi, eflags)
goto 1573 @ 0x77f1  {"nedpmalloc_stats"}

temp0, edi = __insb(edi, dx, eflags)
[edi].b = temp0.b
temp0, edi = __insb(edi, dx, eflags)
[edi].b = temp0.b
esi = __outsd(dx, [esi].d, esi, eflags)
temp0, eflags = __arpl_memw_gpr16([edi + 0x73].w, bx)
[edi + 0x73].w = temp0.w
if (flag:z) then 1457 @ 0x7860 else 1575 @ 0x77ff  {"tvalue"}

temp80.b = [gsbase + esi + 0x65].b
[gsbase + esi + 0x65].b = [gsbase + esi + 0x65].b + ch
flag:c = temp80.b + ch u< temp80.b
flag:z = temp80.b == neg.b(ch)
flag:o = add_overflow(temp80.b, ch)
if (flag:o) then 1576 @ 0x7802 else 1578 @ 0x7799  {"ndependent_calloc"}  {"nedpmalloc_trim"}

temp0, eflags = __arpl_memw_gpr16([ecx + 0x63].w, sp)
[ecx + 0x63].w = temp0.w
goto 1580 @ 0x7877

edi = pop
esi = pop
ebp = pop
esp = esp + 4
ebx = pop
edx = pop
ecx = pop
eax = pop
temp0, edi = __insb(edi, dx, eflags)
[edi].b = temp0.b
temp0, edi = __insb(edi, dx, eflags)
[edi].b = temp0.b
esi = __outsd(dx, [esi].d, esi, eflags)
temp0, eflags = __arpl_memw_gpr16([edi + 0x74].w, bx)
[edi + 0x74].w = temp0.w
if (flag:c) then 1655 else 1656 @ 0x7810

temp0, eflags = __arpl_memw_gpr16([eax].w, ax)
[eax].w = temp0.w
esi = __outsb(dx, [esi].b, esi, eflags)
if (flag:o) then 1662 @ 0x7819 else 1665 @ 0x77b0  {"ndependent_comalloc"}  {"lopt"}

if (flag:c) then 1667 @ 0x77b4 else 1669 @ 0x7746  {"endent_comalloc"}

if (flag:z) then 1680 @ 0x781a else 1682 @ 0x77bb  {"comalloc"}

temp81.d = [esi + 0x66].d
ebp = [esi + 0x66].d * 0x656e006f
flag:c = unimplemented
flag:o = unimplemented
goto 1215 @ 0x77d3  {"dpmalloc"}

temp82.b = [esi + 0x65].b
[esi + 0x65].b = [esi + 0x65].b + ch
flag:c = temp82.b + ch u< temp82.b
temp0, edi = __insd(edi, dx, eflags)
[edi].d = temp0.d
edi = pop
esi = pop
ebp = pop
esp = esp + 4
ebx = pop
edx = pop
ecx = pop
eax = pop
temp0, edi = __insb(edi, dx, eflags)
[edi].b = temp0.b
temp0, edi = __insb(edi, dx, eflags)
[edi].b = temp0.b
esi = __outsd(dx, [esi].d, esi, eflags)
goto 1024 @ 0x7762  {"c_trim"}

temp0, edi = __insd(edi, dx, eflags)
[edi].d = temp0.d
goto 1701 @ 0x774e  {"alloc_stats"}

temp0, eflags = __arpl_memw_gpr16([ecx + 0x6c].w, sp)
[ecx + 0x6c].w = temp0.w
temp0, edi = __insb(edi, dx, eflags)
[edi].b = temp0.b
esi = __outsd(dx, [esi].d, esi, eflags)
temp0, eflags = __arpl_memw_gpr16([eax].w, ax)
[eax].w = temp0.w
esi = __outsb(dx, [esi].b, esi, eflags)
temp83.d = [fsbase + esi + 0x64].d
ebp = [fsbase + esi + 0x64].d * 0x6e657065
flag:c = unimplemented
goto 902 @ 0x76fe  {"dent_comalloc"}

jump(&data_78b4)

temp84.b = [esi + 0x65].b
[esi + 0x65].b = [esi + 0x65].b + ch
flag:c = temp84.b + ch u< temp84.b
flag:z = temp84.b == neg.b(ch)
goto 1455 @ 0x7852  {"drealloc"}

jump(&data_78ba)

edi = pop
esi = pop
ebp = pop
esp = esp + 4
ebx = pop
edx = pop
ecx = pop
eax = pop
temp0, edi = __insb(edi, dx, eflags)
[edi].b = temp0.b
goto 1458 @ 0x7857

jump(&data_78d8)

edi = pop
esi = pop
ebp = pop
esp = esp + 4
ebx = pop
edx = pop
ecx = pop
eax = pop
goto 1710 @ 0x7863

esi = __outsb(dx, [esi].b, esi, eflags)
if (flag:o) then 1710 @ 0x7863 else 1403 @ 0x77f6  {"alloc_stats"}

if (flag:z) then 1481 @ 0x7874 else 1713 @ 0x7801  {"cache"}

esi = __outsb(dx, [esi].b, esi, eflags)
goto 1413 @ 0x7803  {"edpmalloc_trim"}

esi = __outsb(dx, [esi].b, esi, eflags)
if (flag:o) then 1413 @ 0x7803 else 1420 @ 0x779e  {"ndent_calloc"}  {"edpmalloc_trim"}

push(0x65)
[eax].b = [eax].b + al
[eax].b = [eax].b + al
[eax].b = [eax].b + al
[eax].b = [eax].b + al
[eax].b = [eax].b + al
[eax].b = [eax].b + al
[eax].b = [eax].b + al
[eax].b = [eax].b + al
[eax].b = [eax].b + al
[eax].b = [eax].b + al
[eax].b = [eax].b + al
[eax].b = [eax].b + al
[eax].b = [eax].b + al
[eax].b = [eax].b + al
[eax].b = [eax].b + al
[eax].b = [eax].b + al
[eax].b = [eax].b + al
[eax].b = [eax].b + al
[eax].b = [eax].b + al
[eax].b = [eax].b + al
[eax].b = [eax].b + al
[eax].b = [eax].b + al
[eax].b = [eax].b + al
[eax].b = [eax].b + al
[eax].b = [eax].b + al
[eax].b = [eax].b + al
[eax].b = [eax].b + al
[eax].b = [eax].b + al
[eax].b = [eax].b + al
[eax].b = [eax].b + al
[eax].b = [eax].b + al
[eax].b = [eax].b + al
[eax].b = [eax].b + al
[eax].b = [eax].b + al
[eax].b = [eax].b + al
[eax].b = [eax].b + al
[eax].b = [eax].b + al
[eax].b = [eax].b + al
[eax].b = [eax].b + al
[eax].b = [eax].b + al
[eax].b = [eax].b + al
[eax].b = [eax].b + al
[eax].b = [eax].b + al
[eax].b = [eax].b + al
[eax].b = [eax].b + al
[eax].b = [eax].b + al
[eax].b = [eax].b + al
[eax].b = [eax].b + al
[eax].b = [eax].b + al
[eax].b = [eax].b + al
[eax].b = [eax].b + al
[eax].b = [eax].b + al
[eax].b = [eax].b + al
[eax].b = [eax].b + al
[eax].b = [eax].b + al
[eax].b = [eax].b + al
[eax].b = [eax].b + al
[eax].b = [eax].b + al
[eax].b = [eax].b + al
[eax].b = [eax].b + al
[eax].b = [eax].b + al
[eax].b = [eax].b + al
[eax].b = [eax].b + al
[eax].b = [eax].b + al
[eax].b = [eax].b + al
[eax].b = [eax].b + al
[eax].b = [eax].b + al
[eax].b = [eax].b + al
[eax].b = [eax].b + al
[eax].b = [eax].b + al
esi = esi - 1
__out_immb_al(0x40, al, eflags)
ebx = 0x44bf19b1
undefined

jump(&data_7879)

temp0, edi = __insd(edi, dx, eflags)
[edi].d = temp0.d
temp85.b = [esi + 0x65].b
[esi + 0x65].b = [esi + 0x65].b + ch
flag:o = add_overflow(temp85.b, ch)
if (flag:o) then 1718 else 1719 @ 0x7817  {"allopt"}

temp0, edi = __insb(edi, dx, eflags)
[edi].b = temp0.b
goto 1680 @ 0x781a

esi = __outsb(dx, [esi].b, esi, eflags)
if (flag:o) then 1680 @ 0x781a else 1730 @ 0x77b5  {"ndent_comalloc"}

esi = __outsb(dx, [gsbase + esi].b, esi, eflags)
goto 1732 @ 0x77b6  {"dent_comalloc"}

edi = pop
esi = pop
ebp = pop
esp = esp + 4
ebx = pop
edx = pop
ecx = pop
eax = pop
temp0, edi = __insb(edi, dx, eflags)
[edi].b = temp0.b
goto 1734 @ 0x774a  {"nedmalloc_stats"}

esi = __outsd(dx, [esi].d, esi, eflags)
if (flag:o) then 1738 else 1739 @ 0x781d

temp0, eflags = __arpl_memw_gpr16([edi + 0x6d].w, bp)
[edi + 0x6d].w = temp0.w
edi = pop
esi = pop
ebp = pop
esp = esp + 4
ebx = pop
edx = pop
ecx = pop
eax = pop
temp0, edi = __insb(edi, dx, eflags)
[edi].b = temp0.b
temp0, edi = __insb(edi, dx, eflags)
[edi].b = temp0.b
esi = __outsd(dx, [esi].d, esi, eflags)
temp0, eflags = __arpl_memw_gpr16([eax].w, ax)
[eax].w = temp0.w
esi = __outsb(dx, [esi].b, esi, eflags)
if (flag:o) then 1744 @ 0x7836 else 1749 @ 0x77c9  {"allinfo"}

edi = pop
esi = pop
ebp = pop
esp = esp + 4
ebx = pop
edx = pop
ecx = pop
eax = pop
goto 1357 @ 0x774f  {"lloc_stats"}

temp0, edi = __insb(edi, dx, eflags)
[edi].b = temp0.b
if (not(flag:z)) then 1762 else 1763 @ 0x7866

temp86.b = [esi + 0x65].b
[esi + 0x65].b = [esi + 0x65].b + ch
flag:c = temp86.b + ch u< temp86.b
flag:o = add_overflow(temp86.b, ch)
if (flag:o) then 1481 @ 0x7874 else 1484 @ 0x7807  {"alloc_trim"}  {"cache"}

jump(&data_7884)

edi = pop
esi = pop
ebp = pop
esp = esp + 4
ebx = pop
edx = pop
ecx = pop
eax = pop
temp0, edi = __insb(edi, dx, eflags)
[edi].b = temp0.b
goto 1662 @ 0x7819  {"lopt"}

esi = __outsb(dx, [esi].b, esi, eflags)
goto 1732 @ 0x77b6  {"dent_comalloc"}

esi = __outsb(dx, [gsbase + esi].b, esi, eflags)
goto 1505 @ 0x77b9  {"t_comalloc"}

esi = __outsb(dx, [esi].b, esi, eflags)
temp0, edi = __insd(edi, dx, eflags)
[edi].d = temp0.d
goto 1701 @ 0x774e  {"alloc_stats"}

jump(&data_7891)

temp87.b = [esi + 0x65].b
[esi + 0x65].b = [esi + 0x65].b + ch
flag:z = temp87.b == neg.b(ch)
flag:o = add_overflow(temp87.b, ch)
if (flag:o) then 1766 else 1767 @ 0x7823  {"emalign"}

temp88.b = [esi + 0x65].b
[esi + 0x65].b = [esi + 0x65].b + ch
flag:z = temp88.b == neg.b(ch)
flag:o = add_overflow(temp88.b, ch)
if (flag:o) then 1783 else 1784 @ 0x783c  {"ealloc"}

edi = pop
esi = pop
ebp = pop
esp = esp + 4
ebx = pop
edx = pop
ecx = pop
eax = pop
temp0, edi = __insb(edi, dx, eflags)
[edi].b = temp0.b
temp0, edi = __insb(edi, dx, eflags)
[edi].b = temp0.b
goto 1506 @ 0x77cc  {"info"}

jump(&data_78cb)

temp89.b = [esi + 0x65].b
[esi + 0x65].b = [esi + 0x65].b + ch
if (temp89.b == neg.b(ch)) then 1800 else 1801 @ 0x786c  {"imthreadcache"}

jump(&data_7890)

temp0, edi = __insd(edi, dx, eflags)
[edi].d = temp0.d
edi = pop
esi = pop
ebp = pop
esp = esp + 4
ebx = pop
edx = pop
ecx = pop
eax = pop
temp0, edi = __insb(edi, dx, eflags)
[edi].b = temp0.b
temp90.d = [edi + 0x6e].d
esp = [edi + 0x6e].d * 0x64656e00
flag:o = unimplemented
if (flag:o) then 1805 else 1806 @ 0x7830  {"ollist"}

jump(&data_78ae)

edi = pop
esi = pop
ebp = pop
esp = esp + 4
ebx = pop
edx = pop
ecx = pop
eax = pop
temp0, edi = __insb(edi, dx, eflags)
[edi].b = temp0.b
temp0, edi = __insb(edi, dx, eflags)
[edi].b = temp0.b
esi = __outsd(dx, [esi].d, esi, eflags)
temp0, eflags = __arpl_memw_gpr16([eax].w, ax)
[eax].w = temp0.w
goto 1288 @ 0x7843  {"nedpsetvalue"}

jump(&data_78de)

ebp = [ebp + 0x74].d * 0x61657268
temp0, eflags = __arpl_memw_gpr16([fsbase + ecx + 0x63].w, sp)
[fsbase + ecx + 0x63].w = temp0.w
goto 1580 @ 0x7877

jump(&data_789f)

esi = __outsd(dx, [esi].d, esi, eflags)
temp0, edi = __insb(edi, dx, eflags)
[edi].b = temp0.b
temp0, edi = __insb(edi, dx, eflags)
[edi].b = temp0.b
temp91.d = [ebx + 0x74].d
esi = [ebx + 0x74].d * 0x64656e00
flag:o = unimplemented
if (flag:o) then 1815 else 1784 @ 0x783c  {"ealloc"}

jump(&data_78ae)

int32_t __convention("regparm") sub_7917(char* arg1, int32_t arg2, char* arg3 @ ebp, long double arg4 @ st0)
[ebx + (eax << 2) + &data_1000].d = [ebx + (eax << 2) + &data_1000].d - 1
[eax].b = [eax].b + al
[eax].b = [eax].b + al
temp0.b = [eax].b
[eax].b = [eax].b + al
if (temp0.b s< neg.b(al)) then 6 else 7 @ 0x7926

jump(&data_78a9)

[eax].b = [eax].b + dl
[eax].b = [eax].b + al
[eax].b = [eax].b + al
[eax].b = [eax].b + al
temp1.b = [eax].b
[eax].b = [eax].b + al
flag:o = add_overflow(temp1.b, al)
if (flag:o) then 15 else 16 @ 0x7932

jump(&data_78b5)

[eax].b = [eax].b + dl
[eax].b = [eax].b + al
[eax].b = [eax].b + al
[eax].b = [eax].b + al
[eax].b = [eax].b + al
push(eax)
push(ecx)
push(edx)
push(ebx)
push(esp)
push(ebp)
push(esi)
push(edi)
[eax].d = [eax].d + 0x10
[eax].b = [eax].b + al
[eax].b = [eax].b + al
[eax].b = [eax].b + al
[eax].b = [eax].b + al
push(esp)
[eax].d = [eax].d + 0x10
[eax].b = [eax].b + al
[eax].b = [eax].b + al
[eax].b = [eax].b + al
[eax].b = [eax].b + al
esp = esp + 1
[eax].d = [eax].d + 0x10
[eax].b = [eax].b + al
[eax].b = [eax].b + al
[eax].b = [eax].b + al
[eax].b = [eax].b + al
[ebx + &data_1000 {&data_1000}].b - al
[eax].b = [eax].b + al
[eax].b = [eax].b + al
[eax].b = [eax].b + al
[ebx + &data_1000 {&data_1000}].b = [ebx + &data_1000 {&data_1000}].b - al
[eax].b = [eax].b + al
[eax].b = [eax].b + al
[eax].b = [eax].b + al
[eax].b = [eax].b + al
[eax].b = [eax].b + al
[eax].b = [eax].b + al
[eax].b = [eax].b + al
[eax].b = [eax].b + al
temp2.b = [eax].b
[eax].b = [eax].b + al
flag:c = temp2.b + al u< temp2.b
[ebx + &data_1000 {&data_1000}].b = sbb.b([ebx + &data_1000 {&data_1000}].b, al, flag:c)
[eax].b = [eax].b + al
[eax].b = [eax].b + al
[eax].b = [eax].b + al
[eax].b = [eax].b + al
[eax].b = [eax].b + al
[eax].b = [eax].b + al
[eax].b = [eax].b + al
[eax].b = [eax].b + al
[eax].b = [eax].b + al
al = al | 0x10
temp3.b = [eax].b
[eax].b = [eax].b + dl
flag:c = temp3.b + dl u< temp3.b
[ebx + &data_1000 {&data_1000}].b = adc.b([ebx + &data_1000 {&data_1000}].b, al, flag:c)
[eax].b = [eax].b + al
[eax].b = [eax].b + al
[eax].b = [eax].b + al
[eax].b = [eax].b + al
[eax].b = [eax].b + al
[eax].b = [eax].b + al
[eax].b = [eax].b + al
[eax].b = [eax].b + al
[eax].b = [eax].b + al
[eax].b = [eax].b + al
[eax].b = [eax].b + al
[eax].b = [eax].b + al
[eax].b = [eax].b + al
[eax].b = [eax].b + al
[eax].b = [eax].b + al
[eax].b = [eax].b + al
[eax].b = [eax].b + al
[eax].b = [eax].b + al
[eax].b = [eax].b + al
[eax].b = [eax].b + al
[eax].b = [eax].b + al
[eax].b = [eax].b + al
[eax].b = [eax].b + al
[eax].b = [eax].b + al
[eax].b = [eax].b + al
[eax].b = [eax].b + al
[eax].b = [eax].b + al
[eax].b = [eax].b + al
[eax].b = [eax].b + al
[eax].b = [eax].b + al
[eax].b = [eax].b + al
[eax].b = [eax].b + al
[eax].b = [eax].b + al
[eax].b = [eax].b + al
[eax].b = [eax].b + al
[eax].b = [eax].b + al
[eax].b = [eax].b + al
[eax].b = [eax].b + al
[eax].b = [eax].b + al
[eax].b = [eax].b + al
[eax].b = [eax].b + al
[eax].b = [eax].b + al
[eax].b = [eax].b + al
[eax].b = [eax].b + al
[eax].b = [eax].b + al
[eax].b = [eax].b + al
[eax].b = [eax].b + al
[eax].b = [eax].b + al
[eax].b = [eax].b + al
[eax].b = [eax].b + al
[eax].b = [eax].b + al
[eax].b = [eax].b + al
[eax].b = [eax].b + al
[eax].b = [eax].b + al
[eax].b = [eax].b + al
[eax].b = [eax].b + al
[eax].b = [eax].b + al
[eax].b = [eax].b + al
[eax].b = [eax].b + al
[eax].b = [eax].b + al
[eax].b = [eax].b + al
[eax].b = [eax].b + al
[eax].b = [eax].b + al
[eax].b = [eax].b + al
[eax].b = [eax].b + al
[eax].b = [eax].b + al
[eax].b = [eax].b + al
[eax].b = [eax].b + al
[eax].b = [eax].b + al
[eax].b = [eax].b + al
[eax].b = [eax].b + al
[eax].b = [eax].b + al
[eax].b = [eax].b + al
[eax].b = [eax].b + al
[eax].b = [eax].b + al
[eax].b = [eax].b + al
[eax].b = [eax].b + al
[eax].b = [eax].b + al
[eax].b = [eax].b + al
[eax].b = [eax].b + al
[eax].b = [eax].b + al
[eax].b = [eax].b + al
[eax].b = [eax].b + al
[eax].b = [eax].b + al
[eax].b = [eax].b + al
[eax].b = [eax].b + al
[eax].b = [eax].b + al
[eax].b = [eax].b + al
[eax].b = [eax].b + al
[eax].b = [eax].b + al
[eax].b = [eax].b + al
[eax].b = [eax].b + al
[eax].b = [eax].b + al
[eax].b = [eax].b + al
[eax].b = [eax].b + al
[eax].b = [eax].b + al
[eax].b = [eax].b + al
[eax].b = [eax].b + al
[eax].b = [eax].b + al
[eax].b = [eax].b + al
[eax].b = [eax].b + al
[eax].b = [eax].b + al
[eax].b = [eax].b + al
[eax].b = [eax].b + al
[eax].b = [eax].b + al
[eax].b = [eax].b + al
[eax].b = [eax].b + al
[eax].b = [eax].b + al
[eax].b = [eax].b + al
[eax].b = [eax].b + al
[eax].b = [eax].b + al
[eax].b = [eax].b + al
[eax].b = [eax].b + al
[eax].b = [eax].b + al
[eax].b = [eax].b + al
[eax].b = [eax].b + al
[eax].b = [eax].b + al
[eax].b = [eax].b + al
[eax].b = [eax].b + al
[eax].b = [eax].b + al
[eax].b = [eax].b + al
[eax].b = [eax].b + al
[eax].b = [eax].b + al
[eax].b = [eax].b + al
[eax].b = [eax].b + al
[eax].b = [eax].b + al
[eax].b = [eax].b + al
[eax].b = [eax].b + al
[eax].b = [eax].b + al
[eax].b = [eax].b + al
[eax].b = [eax].b + al
[eax].b = [eax].b + al
[eax].b = [eax].b + al
[eax].b = [eax].b + al
temp4.b = [eax].b
[eax].b = [eax].b + al
flag:c = temp4.b + al u< temp4.b
[eax - 0x7cfbf000].b = adc.b([eax - 0x7cfbf000].b, dl, flag:c)
[eax].b = [eax].b + dl
al = [-0xfffffffffc100075].b
[eax].b = [eax].b + 0x10
[eax].b = [eax].b + al
[eax].b = [eax].b + al
[eax].b = [eax].b + al
[eax].b = [eax].b + al
[eax].b = [eax].b + al
[eax].b = [eax].b + al
[eax].b = [eax].b + al
[eax].b = [eax].b + al
[eax].b = [eax].b + al
[eax].b = [eax].b + al
[eax].b = [eax].b + al
[eax].b = [eax].b + al
[eax].b = [eax].b + al
[eax].b = [eax].b + al
[eax].b = [eax].b + al
[eax].b = [eax].b + al
[eax].b = [eax].b + al
[eax].b = [eax].b + al
[eax].b = [eax].b + al
[eax].b = [eax].b + al
[eax].b = [eax].b + al
[eax].b = [eax].b + al
[eax].b = [eax].b + al
[eax].b = [eax].b + al
[eax].b = [eax].b + al
[eax].b = [eax].b + al
[eax].b = [eax].b + al
[eax].b = [eax].b + al
[eax].b = [eax].b + al
[eax].b = [eax].b + al
[eax].b = [eax].b + al
[eax].b = [eax].b + al
[eax].b = [eax].b + al
[eax].b = [eax].b + al
[eax].b = [eax].b + al
[eax].b = [eax].b + al
[eax].b = [eax].b + al
[eax].b = [eax].b + al
[eax].b = [eax].b + al
[eax].b = [eax].b + al
[eax].b = [eax].b + al
[eax].b = [eax].b + al
[eax].b = [eax].b + al
[eax].b = [eax].b + al
[eax].b = [eax].b + al
[eax].b = [eax].b + al
[eax].b = [eax].b + al
[eax].b = [eax].b + al
[eax].b = [eax].b + al
[eax].b = [eax].b + al
[eax].b = [eax].b + al
[eax].b = [eax].b + al
[eax].b = [eax].b + al
[eax].b = [eax].b + al
[eax].b = [eax].b + al
[eax].b = [eax].b + al
[eax].b = [eax].b + al
[eax].b = [eax].b + al
[eax].b = [eax].b + al
[eax].b = [eax].b + al
[eax].b = [eax].b + al
[eax].b = [eax].b + al
[eax].b = [eax].b + al
[eax].b = [eax].b + al
[eax].b = [eax].b + al
[eax].b = [eax].b + al
[eax].b = [eax].b + al
[eax].b = [eax].b + al
[eax].b = [eax].b + al
[eax].b = [eax].b + al
[eax].b = [eax].b + al
[eax].b = [eax].b + al
[eax].b = [eax].b + al
[eax].b = [eax].b + al
[eax].b = [eax].b + al
[eax].b = [eax].b + al
[eax].b = [eax].b + al
[eax].b = [eax].b + al
[eax].b = [eax].b + al
[eax].b = [eax].b + al
[eax].b = [eax].b + al
[eax].b = [eax].b + al
[eax].b = [eax].b + al
[eax].b = [eax].b + al
[eax].b = [eax].b + al
[eax].b = [eax].b + al
[eax].b = [eax].b + al
[eax].b = [eax].b + al
[eax].b = [eax].b + al
[eax].b = [eax].b + al
[eax].b = [eax].b + al
[eax].b = [eax].b + al
[eax].b = [eax].b + al
[eax].b = [eax].b + al
[eax].b = [eax].b + al
[eax].b = [eax].b + al
[eax].b = [eax].b + al
[eax].b = [eax].b + al
[eax].b = [eax].b + al
[eax].b = [eax].b + al
[eax].b = [eax].b + al
[eax].b = [eax].b + al
[eax].b = [eax].b + al
[eax].b = [eax].b + al
[eax].b = [eax].b + al
[eax].b = [eax].b + al
[eax].b = [eax].b + al
[eax].b = [eax].b + al
[eax].b = [eax].b + al
[eax].b = [eax].b + al
[eax].b = [eax].b + al
[eax].b = [eax].b + al
[eax].b = [eax].b + al
[eax].b = [eax].b + al
[eax].b = [eax].b + al
[eax].b = [eax].b + al
[eax].b = [eax].b + al
[eax].b = [eax].b + al
[eax].b = [eax].b + al
[eax].b = [eax].b + al
[eax].b = [eax].b + al
[eax].b = [eax].b + al
[eax].b = [eax].b + al
[eax].b = [eax].b + al
[eax].b = [eax].b + al
[eax].b = [eax].b + al
[eax].b = [eax].b + al
[eax].b = [eax].b + al
[eax].b = [eax].b + al
[eax].b = [eax].b + al
[eax].b = [eax].b + al
[eax].b = [eax].b + al
[eax].b = [eax].b + al
[eax].b = [eax].b + al
[eax].b = [eax].b + al
temp5.b = [eax].b
[eax].b = [eax].b + al
flag:c = temp5.b + al u< temp5.b
[eax - 0x7d0ff000].b = adc.b([eax - 0x7d0ff000].b, dl, flag:c)
[eax].b = [eax].b + dl
[ebp].b = [ebp].b ^ 0x10
call(0x107c67)
[eax].b = [eax].b + al
[eax].b = [eax].b + al
[eax].b = [eax].b + al
[eax].b = [eax].b + al
[eax].b = [eax].b + al
[eax].b = [eax].b + al
[eax].b = [eax].b + al
[eax].b = [eax].b + al
[eax].b = [eax].b + al
[eax].b = [eax].b + al
[eax].b = [eax].b + al
[eax].b = [eax].b + al
[eax].b = [eax].b + al
[eax].b = [eax].b + al
[eax].b = [eax].b + al
[eax].b = [eax].b + al
[eax].b = [eax].b + al
[eax].b = [eax].b + al
[eax].b = [eax].b + al
[eax].b = [eax].b + al
[eax].b = [eax].b + al
[eax].b = [eax].b + al
[eax].b = [eax].b + al
[eax].b = [eax].b + al
[eax].b = [eax].b + al
[eax].b = [eax].b + al
[eax].b = [eax].b + al
[eax].b = [eax].b + al
[eax].b = [eax].b + al
[eax].b = [eax].b + al
[eax].b = [eax].b + al
[eax].b = [eax].b + al
[eax].b = [eax].b + al
[eax].b = [eax].b + al
[eax].b = [eax].b + al
[eax].b = [eax].b + al
[eax].b = [eax].b + al
[eax].b = [eax].b + al
[eax].b = [eax].b + al
[eax].b = [eax].b + al
[eax].b = [eax].b + al
[eax].b = [eax].b + al
[eax].b = [eax].b + al
[eax].b = [eax].b + al
[eax].b = [eax].b + al
[eax].b = [eax].b + al
[eax].b = [eax].b + al
[eax].b = [eax].b + al
[eax].b = [eax].b + al
[eax].b = [eax].b + al
[eax].b = [eax].b + al
[eax].b = [eax].b + al
[eax].b = [eax].b + al
[eax].b = [eax].b + al
[eax].b = [eax].b + al
[eax].b = [eax].b + al
[eax].b = [eax].b + al
[eax].b = [eax].b + al
[eax].b = [eax].b + al
[eax].b = [eax].b + al
[eax].b = [eax].b + al
[eax].b = [eax].b + al
[eax].b = [eax].b + al
[eax].b = [eax].b + al
[eax].b = [eax].b + al
[eax].b = [eax].b + al
[eax].b = [eax].b + al
[eax].b = [eax].b + al
[eax].b = [eax].b + al
[eax].b = [eax].b + al
[eax].b = [eax].b + al
[eax].b = [eax].b + al
[eax].b = [eax].b + al
[eax].b = [eax].b + al
[eax].b = [eax].b + al
[eax].b = [eax].b + al
[eax].b = [eax].b + al
[eax].b = [eax].b + al
[eax].b = [eax].b + al
[eax].b = [eax].b + al
[eax].b = [eax].b + al
[eax].b = [eax].b + al
[eax].b = [eax].b + al
[eax].b = [eax].b + al
[eax].b = [eax].b + al
[eax].b = [eax].b + al
[eax].b = [eax].b + al
[eax].b = [eax].b + al
[eax].b = [eax].b + al
[eax].b = [eax].b + al
[eax].b = [eax].b + al
[eax].b = [eax].b + al
[eax].b = [eax].b + al
[eax].b = [eax].b + al
[eax].b = [eax].b + al
[eax].b = [eax].b + al
[eax].b = [eax].b + al
[eax].b = [eax].b + al
[eax].b = [eax].b + al
[eax].b = [eax].b + al
[eax].b = [eax].b + al
[eax].b = [eax].b + al
[eax].b = [eax].b + al
[eax].b = [eax].b + al
[eax].b = [eax].b + al
[eax].b = [eax].b + al
[eax].b = [eax].b + al
[eax].b = [eax].b + al
[eax].b = [eax].b + al
[eax].b = [eax].b + al
[eax].b = [eax].b + al
[eax].b = [eax].b + al
[eax].b = [eax].b + al
[eax].b = [eax].b + al
[eax].b = [eax].b + al
[eax].b = [eax].b + al
[eax].b = [eax].b + al
[eax].b = [eax].b + al
[eax].b = [eax].b + al
[eax].b = [eax].b + al
[eax].b = [eax].b + al
[eax].b = [eax].b + al
[eax].b = [eax].b + al
[eax].b = [eax].b + al
[eax].b = [eax].b + al
[eax].b = [eax].b + al
[eax].b = [eax].b + al
[eax].b = [eax].b + al
[eax].b = [eax].b + al
[eax].b = [eax].b + al
[eax].b = [eax].b + al
[eax].b = [eax].b + al
[eax].b = [eax].b + al
[eax].b = [eax].b + al
[eax].b = [eax].b + al
[eax].b = [eax].b + dl
[eax].b = [eax].b + dl
st0 = st0 f+ fconvert.t([edx + 0x78e01000].q)
[eax].b = [eax].b + dl
al, ah, eflags = __aam_immb(0x82, al)
[eax].b = [eax].b + dl
[eax].b = [eax].b + al
[eax].b = [eax].b + al
[eax].b = [eax].b + al
[eax].b = [eax].b + al
[eax].b = [eax].b + al
[eax].b = [eax].b + al
[eax].b = [eax].b + al
[eax].b = [eax].b + al
[eax].b = [eax].b + al
[eax].b = [eax].b + al
[eax].b = [eax].b + al
[eax].b = [eax].b + al
[eax].b = [eax].b + al
[eax].b = [eax].b + al
[eax].b = [eax].b + al
[eax].b = [eax].b + al
[eax].b = [eax].b + al
[eax].b = [eax].b + al
[eax].b = [eax].b + al
[eax].b = [eax].b + al
[eax].b = [eax].b + al
[eax].b = [eax].b + al
[eax].b = [eax].b + al
[eax].b = [eax].b + al
[eax].b = [eax].b + al
[eax].b = [eax].b + al
[eax].b = [eax].b + al
[eax].b = [eax].b + al
[eax].b = [eax].b + al
[eax].b = [eax].b + al
[eax].b = [eax].b + al
[eax].b = [eax].b + al
[eax].b = [eax].b + al
[eax].b = [eax].b + al
[eax].b = [eax].b + al
[eax].b = [eax].b + al
[eax].b = [eax].b + al
[eax].b = [eax].b + al
[eax].b = [eax].b + al
[eax].b = [eax].b + al
[eax].b = [eax].b + al
[eax].b = [eax].b + al
[eax].b = [eax].b + al
[eax].b = [eax].b + al
[eax].b = [eax].b + al
[eax].b = [eax].b + al
[eax].b = [eax].b + al
[eax].b = [eax].b + al
[eax].b = [eax].b + al
[eax].b = [eax].b + al
[eax].b = [eax].b + al
[eax].b = [eax].b + al
[eax].b = [eax].b + al
[eax].b = [eax].b + al
[eax].b = [eax].b + al
[eax].b = [eax].b + al
[eax].b = [eax].b + al
[eax].b = [eax].b + al
[eax].b = [eax].b + al
[eax].b = [eax].b + al
[eax].b = [eax].b + al
[eax].b = [eax].b + al
[eax].b = [eax].b + al
[eax].b = [eax].b + al
[eax].b = [eax].b + al
[eax].b = [eax].b + al
[eax].b = [eax].b + al
[eax].b = [eax].b + al
[eax].b = [eax].b + al
[eax].b = [eax].b + al
[eax].b = [eax].b + al
[eax].b = [eax].b + al
[eax].b = [eax].b + al
[eax].b = [eax].b + al
[eax].b = [eax].b + al
[eax].b = [eax].b + al
[eax].b = [eax].b + al
[eax].b = [eax].b + al
[eax].b = [eax].b + al
[eax].b = [eax].b + al
[eax].b = [eax].b + al
[eax].b = [eax].b + al
[eax].b = [eax].b + al
[eax].b = [eax].b + al
[eax].b = [eax].b + al
[eax].b = [eax].b + al
[eax].b = [eax].b + al
[eax].b = [eax].b + al
[eax].b = [eax].b + al
[eax].b = [eax].b + al
[eax].b = [eax].b + al
[eax].b = [eax].b + al
[eax].b = [eax].b + al
[eax].b = [eax].b + al
[eax].b = [eax].b + al
[eax].b = [eax].b + al
[eax].b = [eax].b + al
[eax].b = [eax].b + al
[eax].b = [eax].b + al
[eax].b = [eax].b + al
[eax].b = [eax].b + al
[eax].b = [eax].b + al
[eax].b = [eax].b + al
[eax].b = [eax].b + al
[eax].b = [eax].b + al
[eax].b = [eax].b + al
[eax].b = [eax].b + al
[eax].b = [eax].b + al
[eax].b = [eax].b + al
[eax].b = [eax].b + al
[eax].b = [eax].b + al
[eax].b = [eax].b + al
[eax].b = [eax].b + al
[eax].b = [eax].b + al
[eax].b = [eax].b + al
[eax].b = [eax].b + al
[eax].b = [eax].b + al
[eax].b = [eax].b + al
[eax].b = [eax].b + al
[eax].b = [eax].b + al
[eax].b = [eax].b + al
[eax].b = [eax].b + al
[eax].b = [eax].b + al
[eax].b = [eax].b + al
[eax].b = [eax].b + al
[eax].b = [eax].b + al
[eax].b = [eax].b + al
[eax].b = [eax].b + al
[eax].b = [eax].b + al
[eax].b = [eax].b + al
[eax].b = [eax].b + al
[eax].b = [eax].b + al
[eax].b = [eax].b + al
[eax].b = [eax].b + al
[eax].b = [eax].b + al
temp6.b = [eax].b
[eax].b = [eax].b + al
flag:c = temp6.b + al u< temp6.b
[eax - 0x7d33f000].b = adc.b([eax - 0x7d33f000].b, dl, flag:c)
temp7.b = [eax].b
[eax].b = [eax].b + dl
flag:o = add_overflow(temp7.b, dl)
if (flag:o) then 644 else 645 @ 0x7e1e

jump(&data_7e93)

[eax].b = [eax].b + dl
eax, es = __les_gprz_memp([edx + &data_1000].6)
[eax].b = [eax].b + al
[eax].b = [eax].b + al
[eax].b = [eax].b + al
[eax].b = [eax].b + al
[eax].b = [eax].b + al
[eax].b = [eax].b + al
[eax].b = [eax].b + al
[eax].b = [eax].b + al
[eax].b = [eax].b + al
[eax].b = [eax].b + al
[eax].b = [eax].b + al
[eax].b = [eax].b + al
[eax].b = [eax].b + al
[eax].b = [eax].b + al
[eax].b = [eax].b + al
[eax].b = [eax].b + al
[eax].b = [eax].b + al
[eax].b = [eax].b + al
[eax].b = [eax].b + al
[eax].b = [eax].b + al
[eax].b = [eax].b + al
[eax].b = [eax].b + al
[eax].b = [eax].b + al
[eax].b = [eax].b + al
[eax].b = [eax].b + al
[eax].b = [eax].b + al
[eax].b = [eax].b + al
[eax].b = [eax].b + al
[eax].b = [eax].b + al
[eax].b = [eax].b + al
[eax].b = [eax].b + al
[eax].b = [eax].b + al
[eax].b = [eax].b + al
[eax].b = [eax].b + al
[eax].b = [eax].b + al
[eax].b = [eax].b + al
[eax].b = [eax].b + al
[eax].b = [eax].b + al
[eax].b = [eax].b + al
[eax].b = [eax].b + al
[eax].b = [eax].b + al
[eax].b = [eax].b + al
[eax].b = [eax].b + al
[eax].b = [eax].b + al
[eax].b = [eax].b + al
[eax].b = [eax].b + al
[eax].b = [eax].b + al
[eax].b = [eax].b + al
[eax].b = [eax].b + al
[eax].b = [eax].b + al
[eax].b = [eax].b + al
[eax].b = [eax].b + al
[eax].b = [eax].b + al
[eax].b = [eax].b + al
[eax].b = [eax].b + al
[eax].b = [eax].b + al
[eax].b = [eax].b + al
[eax].b = [eax].b + al
[eax].b = [eax].b + al
[eax].b = [eax].b + al
[eax].b = [eax].b + al
[eax].b = [eax].b + al
[eax].b = [eax].b + al
[eax].b = [eax].b + al
[eax].b = [eax].b + al
[eax].b = [eax].b + al
[eax].b = [eax].b + al
[eax].b = [eax].b + al
[eax].b = [eax].b + al
[eax].b = [eax].b + al
[eax].b = [eax].b + al
[eax].b = [eax].b + al
[eax].b = [eax].b + al
[eax].b = [eax].b + al
[eax].b = [eax].b + al
[eax].b = [eax].b + al
[eax].b = [eax].b + al
[eax].b = [eax].b + al
[eax].b = [eax].b + al
[eax].b = [eax].b + al
[eax].b = [eax].b + al
[eax].b = [eax].b + al
[eax].b = [eax].b + al
[eax].b = [eax].b + al
[eax].b = [eax].b + al
[eax].b = [eax].b + al
[eax].b = [eax].b + al
[eax].b = [eax].b + al
[eax].b = [eax].b + al
[eax].b = [eax].b + al
[eax].b = [eax].b + al
[eax].b = [eax].b + al
[eax].b = [eax].b + al
[eax].b = [eax].b + al
[eax].b = [eax].b + al
[eax].b = [eax].b + al
[eax].b = [eax].b + al
[eax].b = [eax].b + al
[eax].b = [eax].b + al
[eax].b = [eax].b + al
[eax].b = [eax].b + al
[eax].b = [eax].b + al
[eax].b = [eax].b + al
[eax].b = [eax].b + al
[eax].b = [eax].b + al
[eax].b = [eax].b + al
[eax].b = [eax].b + al
[eax].b = [eax].b + al
[eax].b = [eax].b + al
[eax].b = [eax].b + al
[eax].b = [eax].b + al
[eax].b = [eax].b + al
[eax].b = [eax].b + al
[eax].b = [eax].b + al
[eax].b = [eax].b + al
[eax].b = [eax].b + al
[eax].b = [eax].b + al
[eax].b = [eax].b + al
[eax].b = [eax].b + al
[eax].b = [eax].b + al
[eax].b = [eax].b + al
[eax].b = [eax].b + al
[eax].b = [eax].b + al
[eax].b = [eax].b + al
[eax].b = [eax].b + al
[eax].b = [eax].b + al
[eax].b = [eax].b + al
[eax].b = [eax].b + al
[eax].b = [eax].b + al
[eax].b = [eax].b + al
[eax].b = [eax].b + al
[eax].b = [eax].b + al
[eax].b = [eax].b + al
[eax].b = [eax].b + al
temp8.b = [eax].b
[eax].b = [eax].b + al
flag:c = temp8.b + al u< temp8.b
[eax - 0x7d47f000].b = adc.b([eax - 0x7d47f000].b, dl, flag:c)
[eax].b = [eax].b + dl
undefined

uint32_t __convention("regparm") sub_85ef(int32_t arg1, int32_t arg2, int32_t arg3 @ ebp, int32_t arg4 @ esi, int32_t arg5 @ edi)
edx = edx & 0xfffffff0
ecx = 0
eax = 0
goto 4 @ 0x85f6

push(ecx)
ecx = 0x10
goto 7 @ 0x85fc

eax = zx.d([esi + ecx - 1].b)
al = [ebx + eax].b
[ebp + ecx + 0x62f].b = al
ecx = ecx - 1
if (ecx != 0) then 7 @ 0x85fc else 12 @ 0x860d

ecx = 0x10
goto 14 @ 0x8612

al = [ebp + ecx + 0x62f].b
[edi + ecx - 1].b = al
ecx = ecx - 1
if (ecx != 0) then 14 @ 0x8612 else 18 @ 0x861f

ecx = pop
ebx = ebx + 0x10
edi = edi + 0x10
ecx = ecx + 0x10
if (ecx != edx) then 4 @ 0x85f6 else 23 @ 0x862d

<return> jump(pop)

int32_t __convention("regparm") sub_8790(char* arg1, char* arg2, int32_t* arg3, void* arg4 @ ebp, int32_t* arg5 @ esi, int32_t* arg6 @ edi)
temp0.b = dl
dl = dl + ah
flag:c = temp0.b + ah u< temp0.b
flag:p = unimplemented
flag:a = unimplemented
flag:z = temp0.b == neg.b(ah)
flag:s = temp0.b + ah s< 0
flag:o = add_overflow(temp0.b, ah)
push(flagbit.d(flag:o, 0xb) | flagbit.d(flag:d, 0xa) | flagbit.d(flag:s, 7) | flagbit.d(flag:z, 6) | flagbit.d(flag:a, 4) | flagbit.d(flag:p, 2) | flagbit.d(flag:c, 0))
[esi].d = eax
[ebx {sub_0}].b = sbb.b([ebx {sub_0}].b, 3, flag:c)
[edx + 0x73].b = [edx + 0x73].b + ch
[edi + ecx].d = [edi + ecx].d + eax
[edx].b = [edx].b + ch
[ebp - 0x7bfdff24].b = [ebp - 0x7bfdff24].b + bh
[eax + 5].b = [eax + 5].b + al
al = al + [ebx {sub_0}].b
push(zx.d(0x68))
ebp = ebp + 1
[edx - 0x73].d & ebp
push(zx.d(0))
[eax].b = [eax].b + al
[eax].b = [eax].b + al
[eax + (edx << 1) + 0xf008b04].d = [eax + (edx << 1) + 0xf008b04].d - 1
edi = eax
bh = bh + bh
[ebp + 0x8bd000].d & esi
[ebp + 0x516a2000].b = [ebp + 0x516a2000].b + cl
ecx = [ecx].d
[eax].b = [eax].b + al
push(eax)
eax = [esi].d
[ebx - 0x74f9db43 {0x8b0624bd}].b = [ebx - 0x74f9db43 {0x8b0624bd}].b + al
[ebp + 0xcc32004].b = [ebp + 0xcc32004].b + cl
[ebp + 0x41cb0030].d = [ebp + 0x41cb0030].d + ebx
push(&data_87ee)
temp1.b = [eax].b
[eax].b = [eax].b + al
flag:c = temp1.b + al u< temp1.b
[-0xfffffffff4ba8b06].b = adc.b([-0xfffffffff4ba8b06].b, al, flag:c)
[ebp + 0x24ff009d].b = [ebp + 0x24ff009d].b + dh
[eax].d = [eax].d - 1
[0xfd5044].b = [0xfd5044].b + al
edx = [ebx + 0x6a {&data_6a}].d
ecx = ebx - 0x72f9f000
[edi + (ebx << 2)].b = [edi + (ebx << 2)].b + al
[ebp + 0x9d536a].b = [ebp + 0x9d536a].b ^ al
temp2.b = [eax - 0x75].b
[eax - 0x75].b = [eax - 0x75].b + dl
flag:c = temp2.b + dl u< temp2.b
esp = esp - 1
[esi - 0x7b].b = rrc.b([esi - 0x7b].b, 1, flag:c)
if ([ecx {0x8d061000}].d == 0x24) then 53 @ 0x882e else 62 @ 0x8822

bh = bh s>> 1
eax, es = __les_gprz_memp([eax].6)
al = al - 0x4d
[ebp + (eax << 2) + 4].d = [ebp + (eax << 2) + 4].d
[eax].d & eax
eax = eax | 0xf6c76400
dl & ah
[eax].b = [eax].b + al
undefined

jump([eax + (eax << 3)].d)

int32_t __convention("regparm") sub_8c6c(void* arg1, void** arg2, char* arg3, void* arg4 @ ebp)
push(ecx)
ecx = esp + 8 {arg_4}
ecx = ecx - eax
ecx = ecx & 0xf
temp1.d = eax
eax = eax + ecx
flag:c = temp1.d + ecx u< temp1.d
ecx = sbb.d(ecx, ecx, flag:c)
eax = eax | ecx
ecx = pop
goto 11 @ 0x8c9c

temp2.b = [ecx].b
flag:c = bh u< temp2.b
[eax + 0x79].b = adc.b([eax + 0x79].b, al, flag:c)
[eax].b = [eax].b + dl
temp3.d = eax
eax = eax + 1
if (temp3.d s>= -1) then 18 @ 0x8ca8 else 22 @ 0x8ca7

[eax].b = [eax].b + al
edx = pop
[eax + 0x3ffff00].b = [eax + 0x3ffff00].b + dl
goto 27 @ 0x8cb1

[eax].b = [eax].b + al
[edx].b = [edx].b + bl
bh = bh + bh
[ebx {sub_0}].d = [ebx {sub_0}].d + 1
goto 27 @ 0x8cb1

[ebp + 4].b = [ebp + 4].b + cl
[eax].b = [eax].b + al
[eax].b = [eax].b + al
[eax].b = [eax].b + al
[eax].b = [eax].b + al
[eax].b = [eax].b + al
[eax].b = [eax].b + al
[eax].b = [eax].b + al
eax = 0x40
[eax {&data_40}].b = [eax {&data_40}].b + al
[eax {&data_40}].b = [eax {&data_40}].b + al
[eax {&data_40}].b = [eax {&data_40}].b + al
[eax {&data_40}].b = [eax {&data_40}].b + al
[eax {&data_40}].b = [eax {&data_40}].b + al
[eax {&data_40}].b = [eax {&data_40}].b + al
[eax {&data_40}].b = [eax {&data_40}].b + al
[eax {&data_40}].b = [eax {&data_40}].b + al
[eax {&data_40}].b = [eax {&data_40}].b + al
[eax {&data_40}].b = [eax {&data_40}].b + al
[eax {&data_40}].b = [eax {&data_40}].b + al
[eax {&data_40}].b = [eax {&data_40}].b + al
push(ebp)
ebp = esp
[eax {&data_40}].b = [eax {&data_40}].b + al
[eax {&data_40}].b = [eax {&data_40}].b + al
[ecx].b = [ecx].b + al
push(esp)
ds = pop.w
ah = 0xba
[ecx].d = [ecx].d | esp
undefined

void* __stdcall sub_181a9(void arg1 @ invalid, uint16_t arg2 @ x87control, uint16_t arg3 @ x87status, uint16_t arg4 @ x87tag, void arg5 @ x87pop, uint32_t arg6[0x2] @ st0, int64_t arg7 @ st4, int64_t arg8 @ st6, void* arg9, void* arg10, int32_t arg11, int16_t* arg12, int32_t arg13, int32_t arg14)
edi = pop
esi = pop
ebp = pop
esp = esp + 4
ebx = pop
edx = pop
ecx = pop
eax = pop
temp3.b = [eax].b
cond:20 = flag:c
[eax].b = sbb.b(temp3.b, -0x5b, cond:20)
flag:c = unimplemented
[edx + 0x69289e43].d = rlc.d([edx + 0x69289e43].d, 1, flag:c)
flag:c = al u< -0x71
x87.push{x87c1z}(float.t([ebx + (ebx << 3)].q))
ecx = ecx - 1
ecx = adc.d(ecx, [edx].d, flag:c)
temp4.b = al
al = al | 0xde
flag:c = 0
flag:z = (temp4.b | 0xde) == 0
if (not(flag:z)) then 22 @ 0x18209 else 28 @ 0x181bf

[edx + 0x84185a1].d - ebp
[edi + 0xb70b483].d = [edi + 0xb70b483].d | 0xd7b30537
temp0.d = esp {arg_20}
esp = eax
eax = temp0.d {arg_20}
if (ecx == 0) then 57 @ 0x1827b else 64 @ 0x1821c  {"55555555555555555555555555555555"}

temp5.b = bl
cond:21 = flag:c
bl = rrc.b(temp5.b, 1, cond:21)
flag:c = (temp5.b & 1) != 0
flag:p = unimplemented
flag:a = unimplemented
flag:z = rrc.b(temp5.b, 1, cond:21) == 0
flag:s = rrc.b(temp5.b, 1, cond:21) s< 0
flag:o = unimplemented
[edi + 0x25].b = cl
cl = 0x87
push(flagbit.d(flag:o, 0xb) | flagbit.d(flag:d, 0xa) | flagbit.d(flag:s, 7) | flagbit.d(flag:z, 6) | flagbit.d(flag:a, 4) | flagbit.d(flag:p, 2) | flagbit.d(flag:c, 0))
flag:c = 1
temp0.d = ebx
ebx = eax
eax = temp0.d
ecx = ecx + 1
ss = pop.w
temp6.d = eax
eax = eax - -0x2ff35859
flag:c = temp6.d u< -0x2ff35859
al = [ebx + al.d].b
temp0.d = [cs.d + edx + 0x3b].d
[cs.d + edx + 0x3b].d = edx
edx = temp0.d
call(0x302ab5)
esi = esi + 1
[ebp - 0xa81b4c3].b = rrc.b([ebp - 0xa81b4c3].b, 0xfb, flag:c)
goto 68 @ 0x181e8

eax = eax ^ 0x35353535
eax = eax ^ 0x35353535
eax = eax ^ 0x35353535
eax = eax ^ 0x35353535
eax = eax ^ 0x35353535
eax = eax ^ 0x35353535
goto 69 @ 0x18299  {"555555555555555y{yyyyyyyyyyyyyyy"}

ax = muls.dp.b(al, [esi - 0xa].b)
al = al | 0x29
edx:eax = mulu.dp.d(eax, [ecx].d)
goto 80 @ 0x181db

undefined

eax = eax ^ 0x35353535
eax = eax ^ 0x35353535
temp7.d = eax
eax = eax ^ 0x35353535
flag:c = 0
flag:p = unimplemented
flag:a = undefined
flag:z = (temp7.d ^ 0x35353535) == 0
flag:s = (temp7.d ^ 0x35353535) s< 0
flag:o = 0
if (not(flag:s)) then 91 @ 0x18325 else 92 @ 0x182aa

[cs.d + ebp - 0x3fc9b986].b = [cs.d + ebp - 0x3fc9b986].b + bl
temp0.d = pop
flag:c = test_bit(temp0.d, 0)
flag:p = test_bit(temp0.d, 2)
flag:a = test_bit(temp0.d, 4)
flag:z = test_bit(temp0.d, 6)
flag:s = test_bit(temp0.d, 7)
flag:d = test_bit(temp0.d, 0xa)
flag:o = test_bit(temp0.d, 0xb)
eax - -0x40a81b5
goto 68 @ 0x181e8

if (not(flag:s)) then 93 @ 0x18320 else 95 @ 0x18327

if (not(flag:s)) then 91 @ 0x18325 else 96 @ 0x182ac

eip = __int1()
goto 97 @ 0x18321

if (not(flag:s)) then 98 @ 0x183a2 else 100 @ 0x18329

if (not(flag:s)) then 95 @ 0x18327 else 101 @ 0x182ae

if (not(flag:s)) then 102 @ 0x18390 else 104 @ 0x18323

ch = 0xac
goto 105 @ 0x183a4

if (not(flag:s)) then 105 @ 0x183a4 else 107 @ 0x1832b

if (not(flag:s)) then 100 @ 0x18329 else 108 @ 0x182b0

call(0x6ba717f2)
goto 109 @ 0x18397

if (not(flag:s)) then 113 @ 0x1839e else 91 @ 0x18325

[ebx].d - ebx
goto 117 @ 0x183a6

if (not(flag:s)) then 117 @ 0x183a6 else 126 @ 0x1832d

if (not(flag:s)) then 107 @ 0x1832b else 127 @ 0x182b2

temp0.d = esp
esp = eax
eax = temp0.d
goto 128 @ 0x18398

temp0.d = esp
esp = eax
eax = temp0.d
goto 132 @ 0x1839f

temp8.b = al
al = al - -0x6d
flag:c = temp8.b u< -0x6d
flag:p = unimplemented
flag:a = unimplemented
flag:z = temp8.b == -0x6d
flag:s = temp8.b - -0x6d s< 0
flag:o = add_overflow(temp8.b, 0x6d)
goto 133 @ 0x183a8

if (flag:p) then 133 @ 0x183a8 else 134 @ 0x1832f

if (not(flag:s)) then 126 @ 0x1832d else 143 @ 0x182b4

temp0.b = [esi - 0x77746a65].b
[esi - 0x77746a65].b = al
al = temp0.b
goto 113 @ 0x1839e

if (flag:d) then 144 else 147

if (not(flag:s)) then 150 @ 0x18337 else 151 @ 0x183aa

temp9.d = [ecx + 0x79].d
[ecx + 0x79].d = [ecx + 0x79].d | edi
flag:c = 0
flag:p = unimplemented
flag:a = undefined
flag:z = (temp9.d | edi) == 0
flag:s = (temp9.d | edi) s< 0
flag:o = 0
goto 155 @ 0x18332

if (not(flag:s)) then 134 @ 0x1832f else 156 @ 0x182b6

[edi].d = eax
edi = edi - 4
goto 157 @ 0x183a0

[edi].d = eax
edi = edi + 4
goto 157 @ 0x183a0

if (flag:s == flag:o) then 159 @ 0x183b2 else 161 @ 0x18339

temp0.d = ebx
ebx = eax
eax = temp0.d
goto 162 @ 0x183ab

if (not(flag:s)) then 156 @ 0x182b6 else 166 @ 0x18334

if (not(flag:s)) then 167 @ 0x18331 else 168 @ 0x182b8

al - [edi].b
if (flag:d) then 169 else 171

al = [esi].b
if (flag:d) then 173 else 175

if (not(flag:s)) then 177 @ 0x183b9 else 179 @ 0x1833b

temp0.d = ebp
ebp = eax
eax = temp0.d
goto 180 @ 0x183ac

if (not(flag:s)) then 184 @ 0x183af else 188 @ 0x18336

if (not(flag:s)) then 180 @ 0x183ac else 189 @ 0x18333

if (not(flag:s)) then 189 @ 0x18333 else 197 @ 0x182ba

edi = edi - 1
goto 198 @ 0x183a1

edi = edi + 1
goto 198 @ 0x183a1

esi = esi - 1
goto 200

esi = esi + 1
goto 200

dl = 0xc2
undefined

if (not(flag:s)) then 177 @ 0x183b9 else 201 @ 0x1833d

temp0.b = [edi + 0x79ac9792].b
[edi + 0x79ac9792].b = al
al = temp0.b
goto 159 @ 0x183b2

temp0.d = edi
edi = eax
eax = temp0.d
goto 202 @ 0x183b0

if (not(flag:s)) then 204 @ 0x183b5 else 207 @ 0x18338

temp10.b = [ecx + 0x79].b
flag:c = temp10.b u< 0x79
flag:p = unimplemented
flag:a = unimplemented
flag:z = temp10.b == 0x79
flag:s = temp10.b - 0x79 s< 0
flag:o = add_overflow(temp10.b, -0x79)
goto 150 @ 0x18337

if (not(flag:s)) then 208 @ 0x18335 else 209 @ 0x182bc

al, eflags = __daa(al, eflags)
goto 98 @ 0x183a2

goto 210 @ 0x183b3

if (not(flag:s)) then 211 @ 0x183b8 else 213 @ 0x1833f

al = [esi].b
if (flag:d) then 214 else 216

call(-0xffffffffb2aefd6c)
bh = 0xb8
goto 218 @ 0x183be

if (not(flag:s)) then 210 @ 0x183b3 else 220 @ 0x1833a

if (not(flag:s)) then 202 @ 0x183b0 else 150 @ 0x18337

if (not(flag:s)) then 150 @ 0x18337 else 221 @ 0x182be

if (not(flag:s)) then 117 @ 0x183a6 else 204 @ 0x183b5

eax = [esi].d
if (flag:d) then 222 else 224

if (not(flag:s)) then 226 @ 0x182ce else 227 @ 0x18341

esi = esi - 1
goto 228 @ 0x183b1

esi = esi + 1
goto 228 @ 0x183b1

eax = __in_oeax_immb(0x6c, eflags)
goto 229 @ 0x183c0

if (flag:z || flag:s != flag:o) then 204 @ 0x183b5 else 231 @ 0x1833c

if (not(flag:s)) then 69 @ 0x18299 else 232 @ 0x182c0  {"555555555555555y{yyyyyyyyyyyyyyy"}

esi = esi - 4
goto 234

esi = esi + 4
goto 234

if (not(flag:s)) then 235 @ 0x18349 else 237 @ 0x182d0

if (not(flag:s)) then 238 @ 0x182c4 else 239 @ 0x18343

if (not(flag:s)) then 240 @ 0x1835f else 210 @ 0x183b3

ds = pop.w
goto 241 @ 0x183c1

if (flag:s != flag:o) then 242 @ 0x183b7 else 243 @ 0x1833e

edx:eax = sx.q(eax)
if (not(flag:s)) then 213 @ 0x1833f else 244 @ 0x182c3

goto 177 @ 0x183b9

edx:eax = sx.q(eax)
goto 248 @ 0x1834a

if (not(flag:s)) then 249 @ 0x1834b else 250 @ 0x182d2

if (not(flag:s)) then 251 @ 0x182bf else 254 @ 0x182c6

if (not(flag:s)) then 218 @ 0x183be else 256 @ 0x18345

if (not(flag:s)) then 257 @ 0x1831a else 258 @ 0x18361

if (flag:s) then 98 @ 0x183a2 else 259 @ 0x183c3

if (not(flag:s)) then 261 @ 0x18366 else 177 @ 0x183b9

if (not(flag:s)) then 177 @ 0x183b9 else 262 @ 0x18340

temp0.d = [ecx - 7].d
[ecx - 7].d = edi
edi = temp0.d
goto 254 @ 0x182c6

if (not(flag:s)) then 264 @ 0x183c5 else 265 @ 0x1834c

if (not(flag:s)) then 266 @ 0x183c6 else 267 @ 0x1834d

if (not(flag:s)) then 267 @ 0x1834d else 268 @ 0x182d4

[ecx + 0x79877c79].d = fconvert.s(x87.pop)
flag:c = 1
goto 254 @ 0x182c6

flag:c = 1
if (not(flag:s)) then 269 @ 0x18342 else 277 @ 0x182c9

if (not(flag:s)) then 229 @ 0x183c0 else 278 @ 0x18347

if (flag:p) then 279 @ 0x18395 else 281 @ 0x1831c

if (not(flag:s)) then 282 @ 0x183dc else 284 @ 0x18363

edi = pop
if (flag:s) then 285 @ 0x1843e else 266 @ 0x183c6

if (not(flag:s)) then 286 @ 0x183e1 else 287 @ 0x18368

edi = ecx - 0x7f
goto 239 @ 0x18343

if (flag:s) then 288 @ 0x1843f else 289 @ 0x183c7

if (not(flag:s)) then 289 @ 0x183c7 else 293 @ 0x1834e

if (flag:s) then 294 @ 0x183a7 else 298 @ 0x183c8

if (not(flag:s)) then 298 @ 0x183c8 else 300 @ 0x1834f

if (not(flag:s)) then 300 @ 0x1834f else 301 @ 0x182d6

temp11.d = [ecx + 0x79].d
flag:c = temp11.d u< 0x79797979
flag:p = unimplemented
flag:a = unimplemented
flag:z = temp11.d == 0x79797979
flag:s = temp11.d - 0x79797979 s< 0
flag:o = add_overflow(temp11.d, -0x79797979)
goto 235 @ 0x18349

if (flag:p) then 302 @ 0x18344 else 303 @ 0x182cb

if (not(flag:s)) then 304 @ 0x183c2 else 235 @ 0x18349

edx = edx - 1
goto 306 @ 0x18396

if (not(flag:s)) then 109 @ 0x18397 else 310 @ 0x1831e

bh = bh << 1
goto 311 @ 0x183de

if (not(flag:s)) then 311 @ 0x183de else 313 @ 0x18365

if (flag:s) then 314 @ 0x184b8 else 316 @ 0x18440

if (flag:s) then 317 @ 0x183e9 else 318 @ 0x183e3

if (not(flag:s)) then 318 @ 0x183e3 else 319 @ 0x1836a

if (flag:s) then 320 @ 0x184b1 else 324 @ 0x18441

st0 f- st1
__free_slot(st0)
top = top + 1
goto 325 @ 0x183c9

if (not(flag:s)) then 327 @ 0x183ca else 332 @ 0x18350

temp0.d = ebx
ebx = eax
eax = temp0.d
goto 133 @ 0x183a8

eip = __int1()
goto 325 @ 0x183c9

if (flag:p) then 334 @ 0x182da else 335 @ 0x18351

if (not(flag:s)) then 335 @ 0x18351 else 336 @ 0x182d8

if (not(flag:s)) then 337 @ 0x183bf else 340 @ 0x18346

if (not(flag:s)) then 340 @ 0x18346 else 341 @ 0x182cd

[edi + 0x78].w = int.w(x87.pop)
goto 264 @ 0x183c5

temp0.d = esp
esp = eax
eax = temp0.d
goto 128 @ 0x18398

if (not(flag:s)) then 342 @ 0x18399 else 93 @ 0x18320

es = pop.w
goto 346 @ 0x183df

if (not(flag:s)) then 350 @ 0x183e0 else 354 @ 0x18367

eax = [0x2a543f94].d
goto 355 @ 0x184bd

if (flag:o) then 363 @ 0x184ba else 365 @ 0x18442

if (flag:d) then 366 else 370

if (flag:s) then 374 @ 0x1845e else 378 @ 0x183e6

if (not(flag:s)) then 379 @ 0x183e5 else 380 @ 0x1836c

push(0x7828dbac)
esp = ebp
ebp = pop
goto 381 @ 0x184b7

if (flag:s) then 383 @ 0x184bb else 391 @ 0x18443

[esi].b - [edi].b
if (flag:d) then 392 else 395

[edi].d - esp
ebp = ebp + 1
temp12.b = [edi].b
flag:s = al - temp12.b s< 0
if (flag:d) then 398 else 400

[ecx - 0x5f].d = edi
goto 402 @ 0x18353

if (not(flag:s)) then 404 @ 0x18355 else 405 @ 0x182dc

if (not(flag:s)) then 406 @ 0x182f4 else 402 @ 0x18353

if (not(flag:s)) then 402 @ 0x18353 else 334 @ 0x182da

temp0, edi = __insb(edi, dx, eflags)
[edi].b = temp0.b
goto 229 @ 0x183c0

if (not(flag:s)) then 241 @ 0x183c1 else 407 @ 0x18348

if (not(flag:s)) then 407 @ 0x18348 else 408 @ 0x182cf

temp0.b = [ebx - 0x6b77746b].b
[ebx - 0x6b77746b].b = bl
bl = temp0.b
goto 132 @ 0x1839f

temp13.d = [0x782e0678].d
[0x782e0678].d = [0x782e0678].d ^ ebp
flag:s = (temp13.d ^ ebp) s< 0
goto 379 @ 0x183e5

temp14.d = eax
eax = eax - 0x782e0678
flag:s = temp14.d - 0x782e0678 s< 0
goto 379 @ 0x183e5

if (not(flag:s)) then 409 @ 0x183e2 else 411 @ 0x18369

temp15.d = esi
esi = esi + 1
flag:p = unimplemented
flag:a = unimplemented
flag:z = temp15.d == -1
flag:s = temp15.d + 1 s< 0
flag:o = add_overflow(temp15.d, 1)
goto 412 @ 0x184be

al, ah, eflags = __aas(al, ah, eflags)
goto 383 @ 0x184bb

if (flag:s) then 363 @ 0x184ba else 414 @ 0x18444

[edi].d = [esi].d
edi = edi - 4
esi = esi - 4
goto 415

[edi].d = [esi].d
edi = edi + 4
esi = esi + 4
goto 415

temp16.b = [eax + 3].b
flag:c = temp16.b u< ch
flag:s = temp16.b - ch s< 0
if (flag:s) then 416 @ 0x18405 else 417 @ 0x18463

if (flag:s) then 426 @ 0x183f0 else 428 @ 0x183e8

if (flag:s) then 430 @ 0x1845f else 432 @ 0x183e7

if (not(flag:s)) then 432 @ 0x183e7 else 434 @ 0x1836e

dh = 0xa1
goto 435 @ 0x184b9

push(esp)
temp17.b = al
temp18.b = [esi - 0x61].b
al = al - [esi - 0x61].b
flag:c = temp17.b u< temp18.b
flag:s = temp17.b - temp18.b s< 0
flag:o = add_overflow(temp17.b, neg.b(temp18.b))
goto 439 @ 0x184bf

if (flag:z || flag:c) then 355 @ 0x184bd else 441 @ 0x18445

esi = esi - 1
edi = edi - 1
goto 442

esi = esi + 1
edi = edi + 1
goto 442

edi = edi - 1
goto 443

edi = edi + 1
goto 443

edx:eax = sx.q(eax)
goto 444 @ 0x18354

if (not(flag:s)) then 445 @ 0x183d0 else 446 @ 0x18357

if (not(flag:s)) then 446 @ 0x18357 else 447 @ 0x182de

if (not(flag:s)) then 448 @ 0x1836f else 449 @ 0x182f6

if (not(flag:s)) then 450 @ 0x182e3 else 248 @ 0x1834a

if (not(flag:s)) then 248 @ 0x1834a else 451 @ 0x182d1

push(zx.d(es))
goto 318 @ 0x183e3

if (not(flag:s)) then 452 @ 0x183e4 else 453 @ 0x1836b

ah = flagbit.b(flag:s, 7) | flagbit.b(flag:z, 6) | flagbit.b(flag:a, 4) | flagbit.b(flag:p, 2) | flagbit.b(flag:c, 0)
goto 439 @ 0x184bf

if (flag:s) then 412 @ 0x184be else 454 @ 0x18446

goto 455 @ 0x183ea

if (flag:s) then 459 @ 0x1847f else 461 @ 0x18407

edi = pop
esi = pop
ebp = pop
esp = esp + 4
ebx = pop
edx = pop
ecx = pop
eax = pop
goto 475 @ 0x18464

eax = [esi].d
if (flag:d) then 476 else 478

ah = [ebp - 0x78796e6c].b
goto 480 @ 0x183ee

push(0x61a27803)
goto 475 @ 0x18464

[edx - 0x796e6b5b].b = [edx - 0x796e6b5b].b | cl
goto 482 @ 0x183ed

if (not(flag:s)) then 317 @ 0x183e9 else 486 @ 0x18370

temp0.d = esp
esp = eax
eax = temp0.d
goto 363 @ 0x184ba

call(-0xfffffffffd70fd2d)
if (flag:s) then 487 @ 0x1853e else 489 @ 0x184c6

if (flag:s) then 439 @ 0x184bf else 490 @ 0x18447

goto 327 @ 0x183ca

goto 491 @ 0x183cf

if (not(flag:s)) then 491 @ 0x183cf else 493 @ 0x18356

undefined

if (not(flag:s)) then 494 @ 0x183d2 else 497 @ 0x18359

if (not(flag:s)) then 497 @ 0x18359 else 498 @ 0x182e0

if (not(flag:s)) then 455 @ 0x183ea else 500 @ 0x18371

if (not(flag:s)) then 501 @ 0x18375 else 502 @ 0x182f8

if (not(flag:s)) then 503 @ 0x1835e else 504 @ 0x182e5

if (not(flag:s)) then 265 @ 0x1834c else 505 @ 0x182d3

if (flag:s) then 374 @ 0x1845e else 378 @ 0x183e6

if (not(flag:s)) then 378 @ 0x183e6 else 506 @ 0x1836d

if (flag:s) then 507 @ 0x184c0 else 509 @ 0x18448

temp0.d = esp
esp = eax
eax = temp0.d
goto 513 @ 0x183eb

edx = pop
goto 517 @ 0x18480

temp19.b = ah
temp20.b = [ecx + 0x1d].b
ah = ah | [ecx + 0x1d].b
flag:c = 0
temp21.d = eax
eax = eax + 1
flag:s = temp21.d + 1 s< 0
flag:o = add_overflow(temp21.d, 1)
push(ebp)
__bound_gprv_mema32(ebx, [-0xfffffffffc78aca7].q)
temp0.d = esi
esi = eax
eax = temp0.d
if (flag:s) then 518 @ 0x1848e else 519 @ 0x18416

if (flag:s) then 520 @ 0x184de else 528 @ 0x18466

esi = esi - 4
goto 529

esi = esi + 4
goto 529

cl = 0xc3
goto 426 @ 0x183f0

temp0.d = [ecx - 0x5376523d].d
[ecx - 0x5376523d].d = esi
esi = temp0.d
goto 530 @ 0x183f3

if (not(flag:s)) then 513 @ 0x183eb else 533 @ 0x18372

eip = __int1()
goto 534 @ 0x1853f

if (flag:s) then 536 @ 0x1847a else 544 @ 0x184c8

if (flag:s) then 546 @ 0x18492 else 547 @ 0x18449

ecx, es = __les_gprz_memp([esi + 0x78a48278].6)
if (flag:s) then 549 @ 0x1844f else 553 @ 0x183d7

if (not(flag:s)) then 555 @ 0x183d1 else 556 @ 0x18358

[eax + (edi << 1) + 0x2ef7878].b = [eax + (edi << 1) + 0x2ef7878].b & 4
st0 = st0 f+ float.t([eax].w)
goto 282 @ 0x183dc

if (not(flag:s)) then 557 @ 0x183d4 else 558 @ 0x1835b

cl = 0x79
if (flag:p) then 559 @ 0x1835d else 560 @ 0x182e4

if (not(flag:s)) then 561 @ 0x183ec else 566 @ 0x18373

if (not(flag:s)) then 426 @ 0x183f0 else 567 @ 0x18377

if (not(flag:s)) then 566 @ 0x18373 else 568 @ 0x182fa

if (not(flag:s)) then 569 @ 0x183d9 else 571 @ 0x18360

if (not(flag:s)) then 498 @ 0x182e0 else 573 @ 0x182e7

if (not(flag:s)) then 293 @ 0x1834e else 574 @ 0x182d5

if (not(flag:s)) then 428 @ 0x183e8 else 448 @ 0x1836f

edi = [eax + 0x6f].d * 0x787878fd
goto 575 @ 0x184c7

temp22.d = ecx
ecx = ecx - 1
flag:s = temp22.d - 1 s< 0
goto 547 @ 0x18449

temp0.d = ecx
ecx = eax
eax = temp0.d
goto 561 @ 0x183ec

if (not(flag:c)) then 578 @ 0x184fa else 580 @ 0x18482

if (al == [eax + 0x78].b) then 584 else 587

if (flag:s) then 590 @ 0x18465 else 591 @ 0x18418

cond:10 = al - 0x69 s< 0
cond:14 = al - 0x69 s< 0
ah = 0x78
temp0.d = esi
esi = eax
eax = temp0.d
ebp = pop
if (cond:10) then 596 @ 0x1855e else 603 @ 0x184e6

if (flag:s) then 604 @ 0x1849d else 606 @ 0x18468

goto 607 @ 0x183f1

ds = [edx].w
ss = pop.w
<return> jump(pop)

if (not(flag:s)) then 482 @ 0x183ed else 609 @ 0x18374

al, ah, eflags = __aas(al, ah, eflags)
if (flag:o) then 610 @ 0x185ba else 611 @ 0x18542

temp23.b = al
cond:22 = flag:c
al = adc.b(temp23.b, 0x78, cond:22)
flag:c = adc.b(temp23.b, 0x78, cond:22) u< temp23.b || (cond:22 && adc.b(temp23.b, 0x78, cond:22) == temp23.b)
flag:s = adc.b(temp23.b, 0x78, cond:22) s< 0
flag:o = unimplemented
flag:c = flag:c ^ 1
goto 616 @ 0x1847d

mm6 = _m_psubb(mm6, mm4)
goto 617 @ 0x184cb

if (flag:s) then 622 @ 0x18502 else 624 @ 0x18494

push(esp)
if (flag:s) then 625 @ 0x184a6 else 626 @ 0x1844c

temp0.d = ebx
ebx = eax
eax = temp0.d
goto 629 @ 0x18450

__out_dx_oeax(dx, eax, eflags)
goto 631 @ 0x183d8

if (flag:s) then 404 @ 0x18355 else 633 @ 0x183d3

if (not(flag:s)) then 633 @ 0x183d3 else 634 @ 0x1835a

if (flag:s) then 635 @ 0x1844e else 639 @ 0x183d6

if (flag:s == flag:o) then 639 @ 0x183d6 else 559 @ 0x1835d

if (not(flag:s)) then 631 @ 0x183d8 else 240 @ 0x1835f

if (not(flag:s)) then 240 @ 0x1835f else 640 @ 0x182e6

temp0.b = [edi - 0x76523c4f].b
[edi - 0x76523c4f].b = al
al = temp0.b
al = [esi].b
if (flag:d) then 642 else 644

if (not(flag:s)) then 480 @ 0x183ee else 501 @ 0x18375

if (not(flag:s)) then 646 @ 0x18300 else 648 @ 0x18379

if (not(flag:s)) then 648 @ 0x18379 else 653 @ 0x182fc

al = al - 0x22
goto 654 @ 0x183db

ecx = 0x79797979
goto 313 @ 0x18365

if (not(flag:s)) then 656 @ 0x18362 else 657 @ 0x182e9

if (not(flag:s)) then 332 @ 0x18350 else 658 @ 0x182d7

dl = 0xf
flag:c = 0
trap(0xd)
{ Does not return }

[edi].d - edi
goto 659 @ 0x184fc

temp24.d = [edx + 0x78].d
edx = [edx + 0x78].d * 0x78
flag:c = unimplemented
if (flag:s) then 435 @ 0x184b9 else 666 @ 0x18488

[eax + 0x78].b = bh
flag:z = 1
goto 674

al = [eax + 0x78].b
flag:z = 0
goto 674

if (flag:s) then 675 @ 0x184df else 677 @ 0x18467

bl = sbb.b(bl, [esi].b, flag:c)
edi = 0x36f1ad16
temp25.d = eax
eax = eax + 1
if (temp25.d + 1 s< 0) then 683 @ 0x183f8 else 691 @ 0x18423

temp26.d = ecx
ecx = ecx + 1
flag:s = temp26.d + 1 s< 0
ebx = ebp * 0x78
flag:c = unimplemented
dh = 0x6e
if (flag:s) then 703 @ 0x185de else 721 @ 0x18566

if (cond:14) then 722 @ 0x1851c else 724 @ 0x184e8

al - [edi].b
if (flag:d) then 725 else 727

if (flag:d) then 729 else 733

[esi + (ecx << 2) - 0x733ce8e6].d = ebp
goto 683 @ 0x183f8

if (not(flag:s)) then 737 @ 0x183ef else 738 @ 0x18376

undefined

temp27.d = [esi].d
[esi].d = [esi].d ^ edi
flag:s = (temp27.d ^ edi) s< 0
flag:o = 0
if (flag:s) then 739 @ 0x185be else 744 @ 0x18546

if (flag:s) then 439 @ 0x184bf else 459 @ 0x1847f

temp28.b = al
al = al - -0x1b
flag:s = temp28.b - -0x1b s< 0
push(zx.d(ds))
goto 745 @ 0x184ce

__bound_gprv_mema32(ecx, [ecx].q)
goto 749 @ 0x18504

if (flag:s) then 750 @ 0x1850e else 755 @ 0x18496

if (flag:s) then 756 @ 0x184d8 else 764 @ 0x184a8

esi = __outsd(dx, [esi].d, esi, eflags)
edi = edi - 1
goto 635 @ 0x1844e

esi = __outsd(dx, [esi].d, esi, eflags)
if (flag:s) then 617 @ 0x184cb else 771 @ 0x18453

al = al + [esi + (ebx << 3)].b
goto 654 @ 0x183db

if (flag:d) then 772 else 776

if (not(flag:s)) then 569 @ 0x183d9 else 780 @ 0x1835c

temp29.b = al
al = al ^ 0x93
flag:s = (temp29.b ^ 0x93) s< 0
goto 629 @ 0x18450

if (flag:s) then 289 @ 0x183c7 else 631 @ 0x183d8

flag:c = 1
goto 573 @ 0x182e7

esi = esi - 1
goto 781

esi = esi + 1
goto 781

ecx = ecx - 1
if (flag:z || ecx != 0) then 782 @ 0x1837b else 787 @ 0x18302

[esi - 0x7176766b].b = dl
temp0.d = edi
edi = eax
eax = temp0.d
goto 797 @ 0x18380

if (flag:s != flag:o) then 567 @ 0x18377 else 798 @ 0x182fe

al = al + dl
goto 799 @ 0x183dd

if (not(flag:s)) then 799 @ 0x183dd else 802 @ 0x18364

if (not(flag:s)) then 802 @ 0x18364 else 803 @ 0x182eb

if (not(flag:s)) then 804 @ 0x18352 else 806 @ 0x182d9

ebp = ebp - [edx].d
flag:s = (esp & ebx) s< 0
temp30.d = [eax + 0x62].d
edi = [eax + 0x62].d * 0x78787809
flag:c = unimplemented
esi = 0xdb88c814
goto 807 @ 0x1850c

temp31.d = [ecx].d
cond:23 = flag:c
[ecx].d = sbb.d(temp31.d, esi, cond:23)
flag:c = unimplemented
flag:z = sbb.d(temp31.d, esi, cond:23) == 0
flag:s = sbb.d(temp31.d, esi, cond:23) s< 0
flag:o = unimplemented
if (flag:z) then 749 @ 0x18504 else 808 @ 0x1848c

goto 546 @ 0x18492

esi = [eax + (edi << 1) + 0x78785d96].d * 0x6ccd3478
goto 810 @ 0x184ea

eax = eax ^ 0x9393a9a4
temp0.b = [esi + 0x2eac5fd8].b
[esi + 0x2eac5fd8].b = al
al = temp0.b
al = [esi].b
if (flag:d) then 821 else 823

[-0xffffffffd6d1170e].w = int.w(st0)
temp32.b = bl
temp33.b = [ecx + 0x78].b
bl = bl & [ecx + 0x78].b
flag:c = 0
flag:s = (temp32.b & temp33.b) s< 0
flag:o = 0
if (flag:s) then 825 @ 0x18456 else 826 @ 0x18403

edi = [eax + 0x78].d * 0x78
flag:c = test_bit(ah, 0)
flag:p = test_bit(ah, 2)
flag:a = test_bit(ah, 4)
flag:z = test_bit(ah, 6)
flag:s = test_bit(ah, 7)
temp34.b = [edi].b
flag:c = al u< temp34.b
flag:z = al == temp34.b
flag:s = al - temp34.b s< 0
flag:o = add_overflow(al, neg.b(temp34.b))
if (flag:d) then 827 else 829

temp35.d = ebp
ebp = ebp + 1
flag:p = unimplemented
flag:a = unimplemented
flag:z = temp35.d == -1
flag:s = temp35.d + 1 s< 0
flag:o = add_overflow(temp35.d, 1)
temp0, edi = __insb(edi, dx, eflags)
[edi].b = temp0.b
edi = pop
esi = pop
ebp = pop
esp = esp + 4
ebx = pop
edx = pop
ecx = pop
eax = pop
if (flag:s) then 831 @ 0x185da else 832 @ 0x185e3  {"u WPS"}

if (flag:s) then 833 @ 0x185b5 else 834 @ 0x18568  {" WPS"}

flag:s = (al & 0xa7) s< 0
goto 852 @ 0x1851e

undefined

edi = edi - 1
goto 854 @ 0x1849e

edi = edi + 1
goto 854 @ 0x1849e

[edi].b = [esi].b
edi = edi - 1
esi = esi - 1
goto 858 @ 0x18469

[edi].b = [esi].b
edi = edi + 1
esi = esi + 1
goto 858 @ 0x18469

<return> jump(pop)

if (not(flag:s)) then 607 @ 0x183f1 else 864 @ 0x18378

temp36.d = [edi + 3].d
ebp = [edi + 3].d * 0x78
flag:c = unimplemented
st0 = st0 f* fconvert.t([eax + 0x78].q)
if (flag:s) then 869 @ 0x1863f else 870 @ 0x185c7

if (flag:s) then 487 @ 0x1853e else 882 @ 0x18548

__out_dx_al(dx, al, eflags)
flag:c = 0
push(ebx)
if (flag:s) then 578 @ 0x184fa else 888 @ 0x184d3

if (flag:s) then 889 @ 0x1857e else 891 @ 0x18506

__out_dx_oeax(dx, eax, eflags)
temp37.b = [esi].b
[esi].b = [esi].b | bl
flag:s = (temp37.b | bl) s< 0
if (flag:s) then 892 @ 0x184f6 else 896 @ 0x18513

if (flag:s) then 575 @ 0x184c7 else 897 @ 0x18498

temp38.b = [eax].b
cond:24 = flag:c
[eax].b = adc.b(temp38.b, ch, cond:24)
flag:c = adc.b(temp38.b, ch, cond:24) u< temp38.b || (cond:24 && adc.b(temp38.b, ch, cond:24) == temp38.b)
temp39.d = eax
eax = sbb.d(temp39.d, 0x3ca614ae, flag:c)
flag:s = sbb.d(temp39.d, 0x3ca614ae, flag:c) s< 0
goto 675 @ 0x184df

al = [-0xffffffff869393af].b
temp0.b = ch
ch = ah
ah = temp0.b
esi = __outsd(dx, [esi].d, esi, eflags)
al = [esi].b
if (flag:d) then 900 else 902

jump(0x3379fcd0)

[edi].b = [esi].b
edi = edi - 1
esi = esi - 1
goto 904

[edi].b = [esi].b
edi = edi + 1
esi = esi + 1
goto 904

if (not(flag:s)) then 553 @ 0x183d7 else 503 @ 0x1835e

goto 530 @ 0x183f3

temp0.d = ebp
ebp = eax
eax = temp0.d
[ecx + 0x5ca5978e].d = ecx
goto 905 @ 0x18382

temp40.d = [ecx + 0x79].d
cond:25 = flag:c
[ecx + 0x79].d = sbb.d(temp40.d, edi, cond:25)
flag:c = unimplemented
flag:p = unimplemented
flag:a = unimplemented
flag:z = sbb.d(temp40.d, edi, cond:25) == 0
flag:s = sbb.d(temp40.d, edi, cond:25) s< 0
flag:o = unimplemented
if (not(flag:s)) then 797 @ 0x18380 else 906 @ 0x18307

if (flag:d) then 907 else 911

if (not(flag:s)) then 648 @ 0x18379 else 646 @ 0x18300

temp41.d = [edi].d
flag:s = (temp41.d & 0x6782d31) s< 0
goto 318 @ 0x183e3

if (not(flag:s)) then 346 @ 0x183df else 261 @ 0x18366

if (not(flag:s)) then 261 @ 0x18366 else 915 @ 0x182ed

eax = [0x79797999].d
goto 446 @ 0x18357

if (not(flag:s)) then 444 @ 0x18354 else 916 @ 0x182db

if (not(flag:s)) then 917 @ 0x184dc else 750 @ 0x1850e

esi = __outsd(dx, [esi].d, esi, eflags)
goto 919 @ 0x1848d

temp0.d = ebx
ebx = eax
eax = temp0.d
temp0.d = ebx
ebx = eax
eax = temp0.d
temp0.b = [esi + 0x78ac8fab].b
[esi + 0x78ac8fab].b = al
al = temp0.b
al = [esi].b
if (flag:d) then 920 else 922

esi = esi - 1
goto 924

esi = esi + 1
goto 924

if (flag:s) then 925 @ 0x1848b else 926 @ 0x18458

if (flag:s) then 616 @ 0x1847d else 416 @ 0x18405

edi = edi - 1
goto 932 @ 0x1842a

edi = edi + 1
goto 932 @ 0x1842a

goto 943 @ 0x18625

if (not(flag:z)) then 944 @ 0x1865d else 946 @ 0x185e5

undefined

eax = 0x86939364
temp0.b = al
al = cl
cl = temp0.b
dh = 0xac
temp42.d = eax
cond:26 = flag:c
eax = adc.d(temp42.d, 0x7828bdac, cond:26)
flag:c = adc.d(temp42.d, 0x7828bdac, cond:26) u< temp42.d || (cond:26 && adc.d(temp42.d, 0x7828bdac, cond:26) == temp42.d)
esp = ebp
ebp = pop
al = 0x30
temp43.d = esi
esi = esi + 1
flag:p = unimplemented
flag:z = temp43.d == -1
flag:s = temp43.d + 1 s< 0
if (not(flag:c)) then 947 @ 0x185ee else 950 @ 0x1857d

push(zx.d(-0x48))
goto 955 @ 0x18521

temp44.b = [ecx - 0x31].b
flag:c = ch u< temp44.b
flag:s = ch - temp44.b s< 0
if (flag:s) then 956 @ 0x18437 else 957 @ 0x184a3

eax & 0x86869393
st0 f- fconvert.t([edi - 0x54].d)
__free_slot(st0)
top = top + 1
al = [esi].b
if (flag:d) then 959 else 961

temp0.d = [eax - 0x76766a6a].d
[eax - 0x76766a6a].d = ecx
ecx = temp0.d
ss = [edi - 0x6455a35b].w
goto 963 @ 0x18384

goto 966 @ 0x18649

ebp = ebp - 1
__out_immb_oeax(0xcf, eax, eflags)
push(edi)
eax = eax + 1
push(eax)
[eax - 0x34].b = adc.b([eax - 0x34].b, cl, flag:c)
temp45.d = edi
temp46.d = [eax + 0x6d].d
edi = edi ^ [eax + 0x6d].d
flag:s = (temp45.d ^ temp46.d) s< 0
flag:o = 0
goto 972 @ 0x185d3

temp47.b = al
al = al & ch
flag:c = 0
al = adc.b(al, 0x3a, flag:c)
flag:c = 0
goto 974 @ 0x1854d

if (flag:s) then 974 @ 0x1854d else 976 @ 0x184d5

ebx = pop
if (not(flag:o)) then 977 @ 0x185f9 else 978 @ 0x18581

if (flag:s) then 489 @ 0x184c6 else 979 @ 0x18508

esp = ebp
ebp = pop
al = [esi].b
if (flag:d) then 986 else 988

if (flag:s) then 990 @ 0x1858d else 993 @ 0x18515

ah = ah | [ecx + edx].b
esp = 0x693aae32
undefined

esi = esi - 1
goto 994

esi = esi + 1
goto 994

goto 557 @ 0x183d4

if (flag:d) then 995 else 998

if (not(flag:s)) then 905 @ 0x18382 else 1001 @ 0x18309

[edi].d = [esi].d
edi = edi - 4
esi = esi - 4
goto 1002 @ 0x18381

[edi].d = [esi].d
edi = edi + 4
esi = esi + 4
goto 1002 @ 0x18381

if (flag:p) then 287 @ 0x18368 else 1004 @ 0x182ef

if (not(flag:s)) then 493 @ 0x18356 else 1007 @ 0x182dd

al = adc.b(al, -0x5a, flag:c)
goto 520 @ 0x184de

if (al == [eax + 0x78].b) then 1008 else 1011

esi = esi - 1
goto 1014 @ 0x184f3

esi = esi + 1
goto 1014 @ 0x184f3

goto 1016 @ 0x18473

if (flag:s) then 659 @ 0x184fc else 919 @ 0x1848d

push(zx.d(cs))
ecx = ecx & esp
al = __in_al_immb(0xed, eflags)
esp = ebp
ebp = pop
goto 374 @ 0x1845e

temp0.d = ebx
ebx = eax
eax = temp0.d
temp0.d = ebx
ebx = eax
eax = temp0.d
temp0.b = [esi - 0x2f52c82b].b
[esi - 0x2f52c82b].b = al
al = temp0.b
al = [esi].b
if (flag:d) then 1025 else 1027

if (flag:s) then 1029 @ 0x1869f else 1039 @ 0x18627

push(ecx)
goto 1041 @ 0x1865e

if (flag:s) then 1049 @ 0x1865f else 1052 @ 0x185e7

dl = 0xc1
al = [esi].b
if (flag:d) then 1058 else 1060

temp48.d = esp
esp = esp - 1
flag:s = temp48.d - 1 s< 0
flag:o = add_overflow(temp48.d, -1)
goto 889 @ 0x1857e

if (flag:s) then 745 @ 0x184ce else 1062 @ 0x18523

if (flag:d) then 1063 else 1067

esp = pop
if (flag:s) then 852 @ 0x1851e else 625 @ 0x184a6

esi = esi - 1
goto 1071

esi = esi + 1
goto 1071

esi = 0x8790246a
ecx = ebx + (ecx << 2) - 0x4b627b7c
goto 102 @ 0x18390

esi = esi + 1
temp49.d = ebx
ebx = ebx + edi
flag:s = temp49.d + edi s< 0
al, ah, eflags = __aad_immb(0xdc, al, ah)
goto 1072 @ 0x1864e

eax = __in_oeax_dx(dx, eflags)
if (flag:s) then 1072 @ 0x1864e else 1075 @ 0x185d6

al = al & 0x18
undefined

if (flag:s) then 1076 @ 0x1854f else 1077 @ 0x184d7

if (not(flag:o)) then 1082 @ 0x185db else 1098 @ 0x185fb

if (flag:s) then 721 @ 0x18566 else 1100 @ 0x18583

temp50.b = al
cond:27 = flag:c
al = adc.b(temp50.b, -0x38, cond:27)
flag:c = adc.b(temp50.b, -0x38, cond:27) u< temp50.b || (cond:27 && adc.b(temp50.b, -0x38, cond:27) == temp50.b)
flag:s = adc.b(temp50.b, -0x38, cond:27) s< 0
bl = bl
goto 807 @ 0x1850c

esi = esi - 1
goto 1104

esi = esi + 1
goto 1104

push(ecx)
ecx = ecx - 1
goto 1105 @ 0x1858f

if (flag:s) then 1105 @ 0x1858f else 1114 @ 0x18517

goto 320 @ 0x184b1

[edi].b = al
edi = edi - 1
goto 1121 @ 0x18383

[edi].b = al
edi = edi + 1
goto 1121 @ 0x18383

if (flag:p) then 963 @ 0x18384 else 1122 @ 0x1830b

esp = pop
goto 905 @ 0x18382

esp = ebp
ebp = pop
if (not(flag:s)) then 453 @ 0x1836b else 1123 @ 0x182f2

if (not(flag:s)) then 556 @ 0x18358 else 1124 @ 0x182df

[eax + 0x78].b = bh
flag:z = 1
goto 1125

al = [eax + 0x78].b
flag:z = 0
goto 1125

esp = 0xacc97828
goto 1126 @ 0x184f8

unimplemented  {enter sub_7189+0x69f, 0xc9}
al = 0x20
temp51.d = eax
eax = eax ^ 0x78f57814
flag:c = 0
temp52.d = eax
eax = eax + 1
flag:s = temp52.d + 1 s< 0
goto 459 @ 0x1847f

esi = esi - 1
goto 1127 @ 0x18433

esi = esi + 1
goto 1127 @ 0x18433

temp53.b = bh
temp54.b = [eax + 0x78].b
bh = bh & [eax + 0x78].b
flag:c = 0
flag:p = unimplemented
flag:a = undefined
flag:z = (temp53.b & temp54.b) == 0
flag:s = (temp53.b & temp54.b) s< 0
flag:o = 0
goto 1128 @ 0x186a2

ebp = pop
goto 1129 @ 0x18628

temp55.d = edx
edx = edx + 1
flag:p = unimplemented
flag:a = unimplemented
flag:z = temp55.d == -1
flag:s = temp55.d + 1 s< 0
flag:o = add_overflow(temp55.d, 1)
goto 1049 @ 0x1865f

temp0, edi = __insd(edi, dx, eflags)
[edi].d = temp0.d
if (not(flag:z)) then 1130 @ 0x186da else 1132 @ 0x18662

edx = pop
cl = 0xa9
temp0.d = ebx
ebx = eax
eax = temp0.d
goto 1133 @ 0x185eb

esi = esi - 1
goto 1141 @ 0x185f1

esi = esi + 1
goto 1141 @ 0x185f1

if (flag:s) then 1142 @ 0x1859e else 1147 @ 0x18526

[edi].d = [esi].d
edi = edi - 4
esi = esi - 4
goto 1148 @ 0x18438

[edi].d = [esi].d
edi = edi + 4
esi = esi + 4
goto 1148 @ 0x18438

goto 1016 @ 0x18473

push(edx)
ax, eflags = __arpl_gpr16_gpr16(ax, si)
if (flag:s) then 1149 @ 0x18639 else 1153 @ 0x18653

if (flag:s) then 1162 @ 0x1862e else 1164 @ 0x185d8

undefined

al = al - 0x10
temp56.b = [0x3ca614ae].b
[0x3ca614ae].b = [0x3ca614ae].b - bl
flag:s = temp56.b - bl s< 0
goto 675 @ 0x184df

ecx = ecx - 1
al = [ebx + al.d].b
temp57.d = eax
eax = eax ^ 0x78616c45
flag:c = 0
flag:p = unimplemented
flag:a = undefined
flag:z = (temp57.d ^ 0x78616c45) == 0
flag:s = (temp57.d ^ 0x78616c45) s< 0
flag:o = 0
temp2.d = [ebp + 0x78].d
temp0.d = divu.dp.d(edx:eax, temp2.d)
temp1.d = modu.dp.d(edx:eax, temp2.d)
eax = temp0.d
edx = temp1.d
goto 946 @ 0x185e5

al = al - 1
goto 1167 @ 0x185fd

edi = [eax + 0x78].d * 0x78
edx = edx - 1
esi = esi | ecx
if (esi u< 0) then 1133 @ 0x185eb else 1180 @ 0x1858c

goto 1126 @ 0x184f8

temp58.b = [eax + 0x78].b
[eax + 0x78].b = [eax + 0x78].b s>> 1
flag:c = unimplemented
flag:p = unimplemented
flag:a = unimplemented
flag:z = temp58.b s>> 1 == 0
flag:s = temp58.b s>> 1 s< 0
flag:o = unimplemented
if (flag:s) then 1189 @ 0x185f7 else 1192 @ 0x18594

al = al & 0x20
temp59.b = bl
temp60.b = [0x3ea7a8b5].b
bl = bl - [0x3ea7a8b5].b
flag:s = temp59.b - temp60.b s< 0
push(zx.d(-0x48))
goto 955 @ 0x18521

goto 963 @ 0x18384

if (not(flag:s)) then 1193 @ 0x18386 else 1195 @ 0x1830d

if (not(flag:s)) then 1196 @ 0x18276 else 406 @ 0x182f4  {"55555555555555555555555555555555"}

if (not(flag:s)) then 1198 @ 0x18292 else 1211 @ 0x182e1  {"5555555555555555555555y{yyyyyyyy"}

goto 546 @ 0x18492

if (flag:d) then 1212 else 1215

if (flag:d) then 1218 else 1221

if (flag:s) then 1224 @ 0x18712 else 1225 @ 0x186a4

if (not(flag:s)) then 1226 @ 0x185d1 else 1227 @ 0x1862a

ds = pop.w
goto 1231 @ 0x186db

if (flag:z || flag:c) then 1234 @ 0x186d9 else 1238 @ 0x18664

temp0.d = ebx
ebx = eax
eax = temp0.d
temp0.b = [esi + 0x7bacc1b2].b
[esi + 0x7bacc1b2].b = al
al = temp0.b
al = [esi].b
if (flag:d) then 1239 else 1241

if (not(flag:p)) then 1243 @ 0x1859f else 1248 @ 0x185f3

temp61.d = edx
edx = edx + 1
flag:z = temp61.d == -1
flag:s = temp61.d + 1 s< 0
goto 1243 @ 0x1859f

if (flag:s) then 1251 @ 0x18569 else 1262 @ 0x18528

if (flag:s) then 1274 @ 0x184b2 else 1276 @ 0x1843a

flag:c = 1
esi = esi | edi
eax = __in_oeax_dx(dx, eflags)
undefined

temp62.b = al
al = al & 0x78
flag:c = 0
flag:p = unimplemented
flag:a = undefined
flag:z = (temp62.b & 0x78) == 0
flag:s = (temp62.b & 0x78) s< 0
flag:o = 0
if (flag:s) then 1283 @ 0x186cf else 1284 @ 0x18657

ecx = 0xae79aecd
goto 1291 @ 0x18633

esp = esp + 1
ebp = ebp ^ ebx
goto 1082 @ 0x185db

temp63.d = eax
eax = eax - -0x178708de
flag:c = temp63.d u< -0x178708de
temp64.b = [eax + 0x78].b
cond:28 = flag:c
[eax + 0x78].b = adc.b(temp64.b, bh, cond:28)
flag:c = adc.b(temp64.b, bh, cond:28) u< temp64.b || (cond:28 && adc.b(temp64.b, bh, cond:28) == temp64.b)
flag:p = unimplemented
flag:a = unimplemented
flag:z = adc.b(temp64.b, bh, cond:28) == 0
flag:s = adc.b(temp64.b, bh, cond:28) s< 0
flag:o = unimplemented
if (flag:s) then 943 @ 0x18625 else 1292 @ 0x18608

push(eax)
push(ecx)
push(edx)
push(ebx)
push(esp)
push(ebp)
push(esi)
push(edi)
goto 990 @ 0x1858d

temp0.d = pop
esp = esp + &data_7176  {"GetCurrentProcess"}
<return> jump(temp0.d)

if (flag:s) then 1294 @ 0x1860e else 1297 @ 0x18596

al = al & 0x90
goto 1298 @ 0x18388

if (not(flag:s)) then 1298 @ 0x18388 else 1302 @ 0x1830f

eax = eax ^ 0x35353535
goto 57 @ 0x1827b  {"55555555555555555555555555555555"}

eax = eax ^ 0x35353535
eax = eax ^ 0x35353535
eax = eax ^ 0x35353535
eax = eax ^ 0x35353535
temp65.d = eax
eax = eax ^ 0x797b7935
flag:c = 0
flag:p = unimplemented
flag:a = undefined
flag:z = (temp65.d ^ 0x797b7935) == 0
flag:s = (temp65.d ^ 0x797b7935) s< 0
flag:o = 0
if (not(flag:s)) then 1303 @ 0x18326 else 1305 @ 0x182ad

if (not(flag:s)) then 559 @ 0x1835d else 450 @ 0x182e3

[edi].d = eax
edi = edi - 4
goto 1306 @ 0x184f9

[edi].d = eax
edi = edi + 4
goto 1306 @ 0x184f9

[edi].d = eax
edi = edi - 4
goto 1307 @ 0x18434

[edi].d = eax
edi = edi + 4
goto 1307 @ 0x18434

if (not(flag:z) && not(flag:c)) then 1309 @ 0x1878b else 1310 @ 0x18714

if (flag:s) then 1311 @ 0x186ff else 1312 @ 0x186a6

if (flag:s) then 1313 @ 0x18640 else 972 @ 0x185d3

temp0.d = esp
esp = eax
eax = temp0.d
goto 1323 @ 0x1862b

ds = pop.w
esp = 0x70c0a4bc
if (not(flag:z) && not(flag:c)) then 1331 @ 0x18753 else 1333 @ 0x186e3  {"Wxxx$yy"""}

temp0.d = ebx
ebx = eax
eax = temp0.d
goto 1130 @ 0x186da

if (flag:s) then 1335 @ 0x186de else 1336 @ 0x18666

esi = esi - 1
goto 1337

esi = esi + 1
goto 1337

temp66.d = [eax + (edi << 1)].d
ebx = [eax + (edi << 1)].d * -0x41
flag:c = unimplemented
flag:o = unimplemented
if (not(flag:c)) then 1338 @ 0x1861d else 1340 @ 0x185a5

[eax].b = [eax].b u>> cl
ecx = ror.d(ecx, cl)
goto 1189 @ 0x185f7

temp0.d = ebx
ebx = eax
eax = temp0.d
temp0.d = ebx
ebx = eax
eax = temp0.d
temp0.b = [esi + 0x15acb6c8].b
[esi + 0x15acb6c8].b = al
al = temp0.b
al = [esi].b
if (flag:d) then 1341 else 1343

eax = __in_oeax_immb(0x6f, eflags)
temp0.d = ebx
ebx = eax
eax = temp0.d
temp0.d = ebx
ebx = eax
eax = temp0.d
temp0.b = [esi + 0x5eac9fb6].b
[esi + 0x5eac9fb6].b = al
al = temp0.b
al = [esi].b
if (flag:d) then 1345 else 1347

al = [esi].b
if (flag:d) then 1349 else 1351

temp67.d = eax
eax = eax + 0x783bc84d
flag:c = temp67.d u>= 0x87c437b3
flag:z = temp67.d == -0x783bc84d
flag:s = temp67.d + 0x783bc84d s< 0
flag:o = add_overflow(temp67.d, 0x783bc84d)
goto 288 @ 0x1843f

if (flag:z || flag:c) then 1353 @ 0x18748 else 1355 @ 0x186d1

temp68.d = [ebp + 0x33].d
cond:29 = flag:c
[ebp + 0x33].d = sbb.d(temp68.d, ecx, cond:29)
flag:c = unimplemented
temp0, eflags = __arpl_memw_gpr16([ecx + 0x53].w, sp)
[ecx + 0x53].w = temp0.w
goto 944 @ 0x1865d

if (not(flag:s)) then 1356 @ 0x18658 else 1363 @ 0x18635

st5, x87status = __fstpnce_x87_st0(st0, x87pop)
if (not(flag:c)) then 1364 @ 0x18670 else 1366 @ 0x1860c

flag:c = 0
flag:c = 1
if (flag:s) then 1369 @ 0x1861e else 1375 @ 0x18613

if (flag:s) then 1378 @ 0x185a9 else 1390 @ 0x18598

temp0.d = [ebp - 0x7b7b7474].d
[ebp - 0x7b7b7474].d = ecx
ecx = temp0.d
goto 1395 @ 0x1838e

if (not(flag:s)) then 1404 @ 0x1838a else 1406 @ 0x18311

flag:c = 1
goto 95 @ 0x18327

if (not(flag:s)) then 1407 @ 0x18328 else 1408 @ 0x182af

if (not(flag:s)) then 1409 @ 0x18534 else 1411 @ 0x184fb

al, eflags = __daa(al, eflags)
if (not(flag:z)) then 1413 @ 0x183ff else 956 @ 0x18437

if (not(flag:s)) then 1415 @ 0x18806 else 1416 @ 0x1878d

if (flag:s) then 1417 @ 0x1878e else 1418 @ 0x18716

if (flag:s) then 1419 @ 0x18779 else 1420 @ 0x18701  {"yyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyy"}

if (flag:s) then 1421 @ 0x186d4 else 1422 @ 0x186a8

temp69.b = [eax + 0x34].b
[eax + 0x34].b = [eax + 0x34].b | bh
flag:c = 0
flag:p = unimplemented
flag:a = undefined
flag:z = (temp69.b | bh) == 0
flag:s = (temp69.b | bh) s< 0
flag:o = 0
al = __in_al_dx(dx, eflags)
if (flag:s) then 1423 @ 0x186be else 1424 @ 0x18646

temp0.d = ebx
ebx = eax
eax = temp0.d
[esi + 0x79aecdb9].b = al
temp70.b = [edi].b
flag:s = al - temp70.b s< 0
flag:o = add_overflow(al, neg.b(temp70.b))
if (flag:d) then 1425 else 1427

push(edi)
if (flag:s) then 1429 @ 0x187ce else 1430 @ 0x18756  {"x$yy"""}

ecx = pop
goto 1431 @ 0x186e4

if (flag:d) then 1432 else 1436

if (flag:s) then 1440 @ 0x186c7 else 1441 @ 0x18668

goto 1248 @ 0x185f3

esp = esp - 1
goto 1369 @ 0x1861e

if (flag:s) then 1442 @ 0x1861f else 1445 @ 0x185a7

esi = esi - 1
goto 1452 @ 0x18573

esi = esi + 1
goto 1452 @ 0x18573

esi = esi - 1
goto 1460 @ 0x18533

esi = esi + 1
goto 1460 @ 0x18533

esi = esi - 1
goto 1462 @ 0x184b3

esi = esi + 1
goto 1462 @ 0x184b3

ebp = ebp + edi
goto 1464 @ 0x1874a

if (flag:s) then 1464 @ 0x1874a else 1469 @ 0x186d3

ebp = ebp - 1
temp71.d = esp
temp72.d = [ebx + 0x61].d
esp = esp ^ [ebx + 0x61].d
flag:c = 0
push(ebx)
goto 944 @ 0x1865d

if (flag:s != flag:o) then 1167 @ 0x185fd else 1470 @ 0x18637

dh = 0x79
goto 1471 @ 0x18672

push(zx.d(cs))
flag:c = 1
goto 1294 @ 0x1860e

temp73.d = esi
esi = esi + 1
flag:z = temp73.d == -1
flag:s = temp73.d + 1 s< 0
flag:o = add_overflow(temp73.d, 1)
goto 1442 @ 0x1861f

temp0, x87status = __fnstcw_memmem16(x87control)
[eax + 0x78].w = temp0.w
if (flag:s) then 1480 @ 0x18656 else 1481 @ 0x18618

eflags = __cli(eflags)
temp0.d = ebx
ebx = eax
eax = temp0.d
temp0.d = ebx
ebx = eax
eax = temp0.d
temp0.b = [esi - 0x58532e32].b
[esi - 0x58532e32].b = al
al = temp0.b
al = [esi].b
if (flag:d) then 1490 else 1492

temp74.b = [0x42f1ba05].b
[0x42f1ba05].b = [0x42f1ba05].b ^ dl
flag:z = (temp74.b ^ dl) == 0
flag:s = (temp74.b ^ dl) s< 0
goto 1243 @ 0x1859f

temp0.d = pop
flag:c = test_bit(temp0.d, 0)
flag:p = test_bit(temp0.d, 2)
flag:a = test_bit(temp0.d, 4)
flag:z = test_bit(temp0.d, 6)
flag:s = test_bit(temp0.d, 7)
flag:d = test_bit(temp0.d, 0xa)
flag:o = test_bit(temp0.d, 0xb)
goto 1494 @ 0x1838f

[ebx - 0x4b627b7c].w = cs
goto 102 @ 0x18390

if (not(flag:s)) then 1496 @ 0x1838c else 1498 @ 0x18313

if (not(flag:s)) then 1499 @ 0x183a3 else 1501 @ 0x1832a

if (not(flag:s)) then 1501 @ 0x1832a else 1502 @ 0x182b1

[eax - 0x37].b = [eax - 0x37].b - bh
if (flag:d) then 1503 else 1506

al, ah, eflags = __aas(al, ah, eflags)
goto 659 @ 0x184fc

ecx = pop
if (flag:s) then 536 @ 0x1847a else 1509 @ 0x18402

if (not(flag:s)) then 1511 @ 0x18881 else 1520 @ 0x18808

if (not(flag:s)) then 1520 @ 0x18808 else 1521 @ 0x1878f

if (not(flag:s)) then 1522 @ 0x18809 else 1524 @ 0x18790

if (flag:s) then 1525 @ 0x18787 else 1526 @ 0x18718

if (not(flag:s)) then 1527 @ 0x187f4 else 1528 @ 0x1877b  {"yyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyy"}

if (flag:s) then 1529 @ 0x18758 else 1530 @ 0x18703  {"yy"""}

if (flag:s) then 1531 @ 0x1874e else 1541 @ 0x186d6

if (not(flag:s)) then 1542 @ 0x18723 else 1544 @ 0x186aa

if (flag:c) then 1546 @ 0x18737 else 1547 @ 0x186c0

if (flag:s) then 1323 @ 0x1862b else 1548 @ 0x18648

edi = edi - 1
goto 1551

edi = edi + 1
goto 1551

if (flag:z || flag:s != flag:o) then 1552 @ 0x187e9 else 1553 @ 0x187d0

if (flag:s) then 1555 @ 0x1877c else 1529 @ 0x18758  {"yy"""}  {"yyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyy"}

if (flag:s) then 1556 @ 0x186f0 else 1565 @ 0x186e6

[edi].b = [esi].b
edi = edi - 1
esi = esi - 1
goto 1566 @ 0x186df

[edi].b = [esi].b
edi = edi + 1
esi = esi + 1
goto 1566 @ 0x186df

if (flag:z) then 1575 @ 0x1872d else 1579 @ 0x186c9

if (not(flag:s)) then 1333 @ 0x186e3 else 1588 @ 0x1866a

temp0, edi = __insb(edi, dx, eflags)
[edi].b = temp0.b
goto 1591 @ 0x18620

push(esi)
temp75.b = [esi].b
temp76.b = [edi].b
flag:c = temp75.b u< temp76.b
flag:s = temp75.b - temp76.b s< 0
flag:o = add_overflow(temp75.b, neg.b(temp76.b))
if (flag:d) then 1592 else 1595

ebp = 0xb0c97828
temp77.b = [esi - 0xe].b
[esi - 0xe].b = [esi - 0xe].b ^ al
flag:c = 0
flag:p = unimplemented
flag:z = (temp77.b ^ al) == 0
flag:s = (temp77.b ^ al) s< 0
if (not(flag:c)) then 947 @ 0x185ee else 950 @ 0x1857d

al - [edi].b
if (flag:d) then 1598 else 1600

x87.push([eax].t)
if (flag:s) then 517 @ 0x18480 else 381 @ 0x184b7

ah = ah & [edx].b
temp78.b = [eax].b
[eax].b = [eax].b + al
flag:c = temp78.b + al u< temp78.b
goto 1531 @ 0x1874e

if (flag:z || flag:c) then 1602 @ 0x1874d else 1611 @ 0x186d5

if (not(flag:s)) then 1363 @ 0x18635 else 1149 @ 0x18639

bl = 0x79
temp79.b = bh
temp80.b = [ecx - 0x44].b
bh = adc.b(temp79.b, temp80.b, flag:c)
flag:p = unimplemented
flag:a = unimplemented
flag:z = adc.b(temp79.b, temp80.b, flag:c) == 0
flag:s = adc.b(temp79.b, temp80.b, flag:c) s< 0
goto 1612 @ 0x18677  {"yli"s"}

if (flag:s) then 1613 @ 0x18671 else 1356 @ 0x18658

ecx = ecx - 1
eax = eax + 1
edi = pop
temp81.d = [esi + (eax << 1) + 0x6c].d
[esi + (eax << 1) + 0x6c].d = [esi + (eax << 1) + 0x6c].d ^ ecx
flag:z = (temp81.d ^ ecx) == 0
flag:s = (temp81.d ^ ecx) s< 0
flag:o = 0
goto 1591 @ 0x18620

esi = esi - 1
goto 1614 @ 0x185b3

esi = esi + 1
goto 1614 @ 0x185b3

ah = 0x9a
goto 1616 @ 0x18391

[ebp + (ebx << 2) - 0x6ba4654c].b & al
goto 1618 @ 0x18393

if (not(flag:s)) then 1395 @ 0x1838e else 1619 @ 0x18315

al = [esi].b
if (flag:d) then 1620 else 1622

if (not(flag:s)) then 1624 @ 0x183a5 else 1635 @ 0x1832c

if (not(flag:s)) then 1635 @ 0x1832c else 1636 @ 0x182b3

[edi].b = al
edi = edi - 1
goto 1637 @ 0x18538

[edi].b = al
edi = edi + 1
goto 1637 @ 0x18538

push(ebx)
goto 826 @ 0x18403

temp82.b = ah
cond:30 = flag:c
ah = sbb.b(temp82.b, 0x62, cond:30)
flag:c = unimplemented
flag:p = unimplemented
flag:z = sbb.b(temp82.b, 0x62, cond:30) == 0
flag:s = sbb.b(temp82.b, 0x62, cond:30) s< 0
flag:o = unimplemented
if (not(flag:s)) then 1643 @ 0x188eb else 1644 @ 0x18886

if (not(flag:s)) then 1645 @ 0x187cf else 1654 @ 0x1880a

if (not(flag:s)) then 1654 @ 0x1880a else 1656 @ 0x18791

ymm5 = __vpaddusw_ymmqq_ymmqq_memqq(ymm3.32, [ebp + 0x79a77979].32)
goto 1657 @ 0x18812

if (not(flag:s)) then 1659 @ 0x1880b else 1660 @ 0x18792

if (not(flag:s)) then 1661 @ 0x18802 else 1662 @ 0x18789

if (flag:d) then 1663 else 1666

trap(0xd)
{ Does not return }

if (not(flag:s)) then 1669 @ 0x187f6 else 1670 @ 0x1877d  {"yyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyy"}

if (not(flag:s)) then 1671 @ 0x187d3 else 1674 @ 0x1875a

if (flag:s) then 1670 @ 0x1877d else 1683 @ 0x18705  {"yyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyy"}

temp83.b = al
cond:31 = flag:c
al = sbb.b(temp83.b, 0x4f, cond:31)
flag:c = unimplemented
flag:p = unimplemented
flag:a = unimplemented
flag:z = sbb.b(temp83.b, 0x4f, cond:31) == 0
flag:s = sbb.b(temp83.b, 0x4f, cond:31) s< 0
flag:o = unimplemented
goto 1684 @ 0x18750  {"UxUWxxx$yy"""}

if (flag:s) then 1686 @ 0x18744 else 1687 @ 0x186d8

ecx = ecx - 1
if (flag:z || ecx != 0) then 1690 @ 0x1879d else 1691 @ 0x18725

eax = [0x799591a0].d
if (not(flag:s)) then 1471 @ 0x18672 else 1694 @ 0x186b1

goto 1695 @ 0x18739

if (flag:s) then 1698 @ 0x1873a else 1709 @ 0x186c2

eax = eax | 0xd5fb0146
st0 f- fconvert.t([edx + 0x63].q)
undefined

goto 1291 @ 0x18633

if (not(flag:s)) then 1711 @ 0x187a5 else 1712 @ 0x187eb

flag:c = flag:c ^ 1
goto 1714 @ 0x187d1

if (not(flag:s)) then 1715 @ 0x187f7 else 1716 @ 0x1877e  {"yyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyy"}

temp84.b = [ecx - 0x39].b
[ecx - 0x39].b = [ecx - 0x39].b s>> cl
flag:c = unimplemented
flag:p = unimplemented
flag:a = unimplemented
flag:z = temp84.b s>> cl == 0
flag:s = temp84.b s>> cl s< 0
flag:o = unimplemented
goto 1717 @ 0x186f3

if (flag:s) then 1717 @ 0x186f3 else 1718 @ 0x186e8

temp85.b = [eax + 0x77].b
[eax + 0x77].b = [eax + 0x77].b << 0x70
flag:c = unimplemented
flag:p = unimplemented
flag:a = unimplemented
flag:z = temp85.b << 0x70 == 0
flag:s = temp85.b << 0x70 s< 0
flag:o = unimplemented
goto 1333 @ 0x186e3

temp0.d = ebp
ebp = eax
eax = temp0.d
if (not(flag:s)) then 1719 @ 0x187a9 else 1721 @ 0x18730

push(eax)
push(ecx)
push(edx)
push(ebx)
push(esp)
push(ebp)
push(esi)
push(edi)
if (flag:o) then 1698 @ 0x1873a else 1723 @ 0x186cc

edx:eax = sx.q(eax)
cl = [ecx + (edi << 1) - 0x4c864987].b
goto 1726 @ 0x18673

if (not(flag:z)) then 1727 @ 0x1869a else 1729 @ 0x18622

esi = esi - 1
edi = edi - 1
goto 1731

esi = esi + 1
edi = edi + 1
goto 1731

edi = edi - 1
goto 1732

edi = edi + 1
goto 1732

temp86.b = [edi + (ecx << 1)].b
[edi + (ecx << 1)].b = [edi + (ecx << 1)].b + bl
flag:c = temp86.b + bl u< temp86.b
flag:p = unimplemented
flag:a = unimplemented
flag:z = temp86.b == neg.b(bl)
flag:s = temp86.b + bl s< 0
flag:o = add_overflow(temp86.b, bl)
goto 1684 @ 0x18750  {"UxUWxxx$yy"""}

if (flag:s) then 1733 @ 0x1874f else 1741 @ 0x186d7  {"OUxUWxxx$yy"""}

if (not(flag:s)) then 1744 @ 0x186e5 else 1753 @ 0x18679

if (not(flag:s)) then 1758 @ 0x18626 else 1726 @ 0x18673

edi = 0xb1c96228
if (flag:c) then 1129 @ 0x18628 else 610 @ 0x185ba

ebx = pop
goto 1759 @ 0x18392

if (flag:d) then 1763 else 1767

if (not(flag:s)) then 102 @ 0x18390 else 1771 @ 0x18317

esi = esi - 1
goto 1772

esi = esi + 1
goto 1772

temp87.d = ebp
temp88.d = [ebx + (edx << 2)].d
cond:32 = flag:c
ebp = sbb.d(temp87.d, temp88.d, cond:32)
flag:c = unimplemented
flag:p = unimplemented
flag:a = unimplemented
flag:z = sbb.d(temp87.d, temp88.d, cond:32) == 0
flag:s = sbb.d(temp87.d, temp88.d, cond:32) s< 0
flag:o = unimplemented
goto 133 @ 0x183a8

if (not(flag:s)) then 133 @ 0x183a8 else 1773 @ 0x1832e

if (not(flag:s)) then 1773 @ 0x1832e else 1774 @ 0x182b5

al, ah, eflags = __aam_immb(0xc5, al)
[ecx + 0x46].d = [ecx + 0x46].d & edx
temp89.b = al
al = al ^ 0xf1
flag:o = 0
goto 534 @ 0x1853f

if (not(flag:z)) then 1775 @ 0x1896b else 1776 @ 0x188ed

if (flag:p) then 1782 @ 0x18831 else 1784 @ 0x18888

temp90.d = ebp
cond:33 = flag:c
ebp = sbb.d(temp90.d, esi, cond:33)
flag:c = unimplemented
flag:p = unimplemented
flag:z = sbb.d(temp90.d, esi, cond:33) == 0
flag:s = sbb.d(temp90.d, esi, cond:33) s< 0
flag:o = unimplemented
goto 1714 @ 0x187d1

eax = __in_oeax_immb(0xdd, eflags)
goto 1786 @ 0x1880c

if (not(flag:s)) then 1786 @ 0x1880c else 1788 @ 0x18793

st0 = float.t([ecx - 0x55].w) f/ st0
goto 1789 @ 0x18815

undefined

if (not(flag:s)) then 1791 @ 0x1880d else 1793 @ 0x18794

if (not(flag:s)) then 1794 @ 0x1887d else 1797 @ 0x18804

if (not(flag:s)) then 1797 @ 0x18804 else 1309 @ 0x1878b

[edi].d = eax
edi = edi - 4
goto 1798 @ 0x18719

[edi].d = eax
edi = edi + 4
goto 1798 @ 0x18719

trap(0xd)
{ Does not return }

if (not(flag:s)) then 1816 @ 0x187f8 else 1817 @ 0x1877f  {"yyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyy"}

temp91.d = [ecx + 0x79].d | edi
[ecx + 0x79].d = temp91.d
if (temp91.d s>= 0) then 1818 @ 0x18856 else 1820 @ 0x187d8

ah = ah & [edx].b
temp92.b = [edx].b
[edx].b = [edx].b + al
flag:c = temp92.b + al u< temp92.b
flag:p = unimplemented
flag:z = temp92.b == neg.b(al)
flag:s = temp92.b + al s< 0
flag:o = add_overflow(temp92.b, al)
if (not(flag:s)) then 1828 @ 0x187d9 else 1836 @ 0x18760

if (flag:s) then 1817 @ 0x1877f else 1838 @ 0x18707  {"yyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyy"}

push(ebp)
if (flag:s) then 1839 @ 0x187a8 else 1331 @ 0x18753  {"Wxxx$yy"""}

if (flag:s) then 1840 @ 0x187be else 1841 @ 0x18746

ecx = 0xbc1f1f93
esp = 0x7770c0a4
if (flag:o) then 1842 @ 0x1873d else 1431 @ 0x186e4

if (not(flag:s)) then 1850 @ 0x18818 else 1851 @ 0x1879f

temp0, x87control, x87tag, x87status = __fnsave_memmem108(x87control, x87tag, x87status)
[edi - 0x3f].108 = temp0.108
if (not(flag:s)) then 1853 @ 0x187a3 else 1861 @ 0x1872a

if (not(flag:s)) then 1863 @ 0x1866e else 1864 @ 0x186b3

[edx].b = [edx].b + ah
al = al & [eax].b
goto 1842 @ 0x1873d

ah = ah & [edx].b
[eax].b = [eax].b + al
temp93.b = dl
temp94.b = [ebp + 0x55].b
dl = dl & [ebp + 0x55].b
flag:c = 0
flag:p = unimplemented
flag:z = (temp93.b & temp94.b) == 0
flag:s = (temp93.b & temp94.b) s< 0
flag:o = 0
goto 1865 @ 0x18741

push(ebp)
goto 1866 @ 0x186c3

if (not(flag:s)) then 1867 @ 0x18820 else 1869 @ 0x187a7

edx = 0x79792828
goto 1870 @ 0x187f0

if (not(flag:s)) then 1873 @ 0x187b8 else 1671 @ 0x187d3

if (not(flag:s)) then 1874 @ 0x18872 else 1876 @ 0x187f9

if (not(flag:s)) then 1876 @ 0x187f9 else 1877 @ 0x18780  {"yyyyyyyyyyyyyyyyyyyyyyyyyyyyyyy9"}

if (not(flag:s)) then 1878 @ 0x186b6 else 1887 @ 0x186f5

if (not(flag:s)) then 1888 @ 0x18763 else 1889 @ 0x186ea

[ecx - 0x78].d = edi
goto 1891 @ 0x187ac

eip, eflags = __into(eflags)
goto 1892 @ 0x18731

push(zx.d(0x66))
push(zx.d(0x76))
if (not(flag:z) && not(flag:c)) then 1464 @ 0x1874a else 1893 @ 0x186d2

if (not(flag:s)) then 1894 @ 0x18687 else 1895 @ 0x18675

esi = esi - 1
goto 1896 @ 0x1869b

push(edx)
if (not(flag:z)) then 1899 @ 0x1869d else 943 @ 0x18625

goto 1378 @ 0x185a9

goto 1409 @ 0x18534

temp95.d = edi
edi = edi - 1
flag:p = unimplemented
flag:a = unimplemented
flag:z = temp95.d == 1
flag:s = temp95.d - 1 s< 0
flag:o = add_overflow(temp95.d, -1)
goto 1684 @ 0x18750  {"UxUWxxx$yy"""}

temp0, edi = __insb(edi, dx, eflags)
[edi].b = temp0.b
goto 1687 @ 0x186d8

temp96.b = bh
temp97.b = [eax + 0xb].b
bh = bh | [eax + 0xb].b
flag:c = 0
flag:p = unimplemented
flag:z = (temp96.b | temp97.b) == 0
flag:s = (temp96.b | temp97.b) s< 0
flag:o = 0
goto 1718 @ 0x186e8

temp98.d = [edx].d
esp = [edx].d * 0x6f700073
flag:c = unimplemented
flag:o = unimplemented
if (not(flag:z) && not(flag:c)) then 1902 @ 0x186f9 else 1903 @ 0x18681

if (flag:s) then 1904 @ 0x18685 else 1129 @ 0x18628

temp0.d = esp
esp = eax
eax = temp0.d
goto 1618 @ 0x18393

[edi].d = [esi].d
edi = edi - 4
esi = esi - 4
goto 1905 @ 0x18394

[edi].d = [esi].d
edi = edi + 4
esi = esi + 4
goto 1905 @ 0x18394

if (not(flag:s)) then 1759 @ 0x18392 else 1907 @ 0x18319

goto 105 @ 0x183a4

if (not(flag:s)) then 161 @ 0x18339 else 1908 @ 0x18330

if (not(flag:s)) then 1908 @ 0x18330 else 1909 @ 0x182b7

if (flag:z || flag:s != flag:o) then 1910 @ 0x189b2 else 1917 @ 0x1896d

temp99.b = cl
cl = sbb.b(temp99.b, -9, flag:c)
flag:z = sbb.b(temp99.b, -9, flag:c) == 0
flag:s = sbb.b(temp99.b, -9, flag:c) s< 0
flag:o = unimplemented
goto 1923 @ 0x188f0

al = __in_al_dx(dx, eflags)
goto 1925 @ 0x18832

cl = 0x81
goto 1927 @ 0x1888a

al = [esi].b
if (flag:d) then 1931 else 1933

if (not(flag:s)) then 1935 @ 0x1880e else 1936 @ 0x18795

call(-0xffffffffc07b01ff)
goto 1937 @ 0x1881a

eax = __in_oeax_immb(0x79, eflags)
goto 1941 @ 0x1880f

if (not(flag:s)) then 1941 @ 0x1880f else 1942 @ 0x18796

esi = ror.d(esi, 0x83)
[eax + 0x657962dc].d = [eax + 0x657962dc].d - 0x7e4e5686
goto 1927 @ 0x1888a

if (not(flag:s)) then 1943 @ 0x187ed else 1415 @ 0x18806

temp0.d = pop
flag:c = test_bit(temp0.d, 0)
flag:p = test_bit(temp0.d, 2)
flag:a = test_bit(temp0.d, 4)
flag:z = test_bit(temp0.d, 6)
flag:s = test_bit(temp0.d, 7)
flag:d = test_bit(temp0.d, 0xa)
flag:o = test_bit(temp0.d, 0xb)
temp100.b = ch
temp101.b = [eax + eax].b
ch = ch & [eax + eax].b
flag:c = 0
flag:p = unimplemented
flag:a = undefined
flag:z = (temp100.b & temp101.b) == 0
flag:s = (temp100.b & temp101.b) s< 0
flag:o = 0
goto 1945 @ 0x1871d

if (not(flag:s)) then 1948 @ 0x187e5 else 1949 @ 0x187fa

if (not(flag:s)) then 1949 @ 0x187fa else 1950 @ 0x18781

st0 = float.t([edi + 0x6587fc81].d) f/ st0
goto 1951 @ 0x1885c

temp102.b = [eax].b
[eax].b = [eax].b - ch
flag:c = temp102.b u< ch
flag:p = unimplemented
flag:z = temp102.b == ch
flag:s = temp102.b - ch s< 0
flag:o = add_overflow(temp102.b, neg.b(ch))
goto 1957 @ 0x187da

temp103.b = [ecx - 0x46].b
[ecx - 0x46].b = [ecx - 0x46].b - bh
flag:c = temp103.b u< bh
flag:p = unimplemented
flag:z = temp103.b == bh
flag:s = temp103.b - bh s< 0
flag:o = add_overflow(temp103.b, neg.b(bh))
goto 1958 @ 0x187dc

push(edx)
if (not(flag:s)) then 1873 @ 0x187b8 else 1888 @ 0x18763

if (not(flag:z) && not(flag:c)) then 1959 @ 0x18770 else 1960 @ 0x18709  {"yyy9yyyyyyyyyyyyyyyyyyyyyyyyyyyy"}

if (flag:p) then 1961 @ 0x18733 else 1962 @ 0x187aa

if (not(flag:s)) then 1963 @ 0x18839 else 1964 @ 0x187c0

if (flag:s) then 1966 @ 0x1876a else 1353 @ 0x18748

temp104.b = [edx].b
[edx].b = [edx].b + ah
flag:c = temp104.b + ah u< temp104.b
flag:p = unimplemented
flag:z = temp104.b == neg.b(ah)
flag:s = temp104.b + ah s< 0
flag:o = add_overflow(temp104.b, ah)
goto 1967 @ 0x1873f

if (not(flag:s)) then 1957 @ 0x187da else 1937 @ 0x1881a

flag:s = ecx - edi s< 0
goto 1970 @ 0x187a1

temp105.d = [ecx + 0x79].d
flag:c = temp105.d u< edi
flag:p = unimplemented
flag:a = unimplemented
flag:z = temp105.d == edi
flag:s = temp105.d - edi s< 0
flag:o = add_overflow(temp105.d, neg.d(edi))
if (not(flag:s)) then 1971 @ 0x18821 else 1839 @ 0x187a8

al = 0xb2
goto 1575 @ 0x1872d

if (not(flag:s)) then 1972 @ 0x186e9 else 1364 @ 0x18670

if (not(flag:s)) then 1128 @ 0x186a2 else 1973 @ 0x186b5

if (flag:s) then 1974 @ 0x18798 else 1975 @ 0x18743

if (flag:s) then 1842 @ 0x1873d else 1977 @ 0x186c5

[ecx - 0x26].t = x87.pop{x87c1z}
goto 1978 @ 0x18823

if (not(flag:s)) then 1978 @ 0x18823 else 1719 @ 0x187a9

__out_immb_al(0x79, al, eflags)
__out_immb_al(0x79, al, eflags)
goto 1527 @ 0x187f4

if (flag:p) then 1980 @ 0x18833 else 1981 @ 0x187ba

eax = eax - -0x3e60f571
undefined

goto 1982 @ 0x18874

if (not(flag:s)) then 1987 @ 0x187fb else 1988 @ 0x18782

temp106.d = [esi].d
temp107.d = [edi].d
flag:c = temp106.d u< temp107.d
flag:p = unimplemented
flag:a = unimplemented
flag:z = temp106.d == temp107.d
flag:s = temp106.d - temp107.d s< 0
flag:o = add_overflow(temp106.d, neg.d(temp107.d))
if (flag:d) then 1989 else 1992

if (not(flag:s)) then 1894 @ 0x18687 else 1995 @ 0x186f7  {"ytq"x"}

if (not(flag:s)) then 1996 @ 0x187dd else 1998 @ 0x18765

[esi].d - [edi].d
if (flag:d) then 1999 else 2002

if (not(flag:s)) then 2005 @ 0x18827 else 2007 @ 0x187ae

if (not(flag:s)) then 1311 @ 0x186ff else 1961 @ 0x18733

if (not(flag:z) && not(flag:c)) then 1464 @ 0x1874a else 1421 @ 0x186d4

if (not(flag:o)) then 1718 @ 0x186e8 else 2008 @ 0x18689

if (not(flag:s)) then 1291 @ 0x18633 else 1612 @ 0x18677  {"yli"s"}

esi = esi - 1
ebp = ebp + 1
goto 1899 @ 0x1869d

ebp = ebp + 1
eip = __int1()
goto 1029 @ 0x1869f

if (not(flag:o)) then 1945 @ 0x1871d else 2016 @ 0x186fb

if (flag:s) then 1687 @ 0x186d8 else 2017 @ 0x18683

if (flag:s) then 1311 @ 0x186ff else 1894 @ 0x18687

ecx = [edx + 0x65].d * -0x6c
goto 128 @ 0x18398

if (not(flag:s)) then 279 @ 0x18395 else 2018 @ 0x1831b

if (not(flag:s)) then 162 @ 0x183ab else 155 @ 0x18332

if (not(flag:s)) then 155 @ 0x18332 else 2019 @ 0x182b9

edx = edx - 1
eflags = __cli(eflags)
temp108.d = [eax - 0x46119f7f].d
[eax - 0x46119f7f].d = [eax - 0x46119f7f].d | edx
flag:s = (temp108.d | edx) s< 0
flag:o = 0
goto 2020 @ 0x189ba

temp109.d = [edx - 0x1d].d
[edx - 0x1d].d = [edx - 0x1d].d | 0x69a3237f
flag:p = unimplemented
mm0 = _m_psrld(mm0, mm6)
esi = __outsd(dx, [esi].d, esi, eflags)
if (not(flag:p)) then 2022 @ 0x1893a else 2039 @ 0x1897b

__out_dx_al(dx, al, eflags)
if (not(flag:z) && flag:s == flag:o) then 2043 @ 0x1896c else 2045 @ 0x188f4

eax = __in_oeax_dx(dx, eflags)
goto 1980 @ 0x18833

flag:d = 0
esi = 0x69e081ee
ch = 0xde
goto 2053 @ 0x18892

esi = esi - 1
goto 2054

esi = esi + 1
goto 2054

if (not(flag:s)) then 2055 @ 0x18889 else 2060 @ 0x18810

if (not(flag:s)) then 2060 @ 0x18810 else 2068 @ 0x18797

st0 f- st3
__free_slot(st0)
top = top + 1
undefined

if (not(flag:s)) then 1873 @ 0x187b8 else 2069 @ 0x18811

if (not(flag:s)) then 2069 @ 0x18811 else 1974 @ 0x18798

[ecx + 0x79].b = [ecx + 0x79].b - bh
goto 1870 @ 0x187f0

__out_dx_oeax(dx, eax, eflags)
al = [esi].b
if (flag:d) then 2070 else 2072

trap(0xd)
{ Does not return }

if (not(flag:s)) then 2074 @ 0x18875 else 2076 @ 0x187fc

if (not(flag:s)) then 2076 @ 0x187fc else 2077 @ 0x18783

edx = edx + 1
esi = 0x63f22d42
temp110.b = [ebx].b
flag:c = bl u< temp110.b
al, ah, eflags = __aaa(al, ah, eflags)
goto 2078 @ 0x18865

if (not(flag:s)) then 1942 @ 0x18796 else 1958 @ 0x187dc

if (not(flag:s)) then 1415 @ 0x18806 else 2084 @ 0x187de

if (not(flag:s)) then 1712 @ 0x187eb else 2086 @ 0x18772  {"y9yyyyyyyyyyyyyyyyyyyyyyyyyyyyyy"}

if (not(flag:c)) then 1670 @ 0x1877d else 2087 @ 0x1870c  {"yyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyy"}

if (not(flag:s)) then 1469 @ 0x186d3 else 2089 @ 0x18735

if (not(flag:s)) then 2090 @ 0x18734 else 1891 @ 0x187ac

if (not(flag:s)) then 2096 @ 0x188b4 else 2102 @ 0x1883b

edx:eax = sx.q(eax)
if (not(flag:s)) then 2104 @ 0x1883c else 2105 @ 0x187c3

if (not(flag:s)) then 1948 @ 0x187e5 else 2106 @ 0x1876c

push(ebp)
push(ebp)
goto 1865 @ 0x18741

if (not(flag:s)) then 2107 @ 0x1881c else 1853 @ 0x187a3

if (not(flag:s)) then 2108 @ 0x187fd else 1978 @ 0x18823

if (not(flag:s)) then 2109 @ 0x18692 else 2110 @ 0x186eb

if (not(flag:s)) then 1041 @ 0x1865e else 2120 @ 0x186b7  {"ypm"v"}

if (not(flag:s)) then 2121 @ 0x18813 else 2122 @ 0x1879a

push(ebp)
goto 1686 @ 0x18744

if (flag:s) then 1967 @ 0x1873f else 1440 @ 0x186c7

ecx = ecx - 1
if (ecx != 0) then 1797 @ 0x18804 else 2123 @ 0x18826

goto 2124 @ 0x1881d

if (not(flag:s)) then 2126 @ 0x18835 else 2127 @ 0x187bc

bl = bl | [edi + 0x470dbc1].b
temp111.d = edi
edi = edi - 1
flag:s = temp111.d - 1 s< 0
goto 2128 @ 0x1887b

if (not(flag:s)) then 2130 @ 0x18876 else 2108 @ 0x187fd

if (not(flag:s)) then 2108 @ 0x187fd else 2135 @ 0x18784

esi = esi - 4
edi = edi - 4
goto 2136

esi = esi + 4
edi = edi + 4
goto 2136

if (not(flag:s)) then 2137 @ 0x1876d else 1902 @ 0x186f9

[edx + 0x79f4e6e6].b = [edx + 0x79f4e6e6].b - bh
goto 2138 @ 0x187e3

if (not(flag:s)) then 2140 @ 0x1870d else 2142 @ 0x18767

esi = esi - 4
edi = edi - 4
goto 2143

esi = esi + 4
edi = edi + 4
goto 2143

edx = 0xbac979ec
goto 1659 @ 0x1880b

if (not(flag:s)) then 2144 @ 0x1882a else 2147 @ 0x187b0

ebx = pop
temp0, edi = __insd(edi, dx, eflags)
[edi].d = temp0.d
temp112.d = [ebp + 0x62].d
esp = [ebp + 0x62].d * 0x68
flag:c = unimplemented
flag:o = unimplemented
if (flag:z || flag:c) then 2154 @ 0x18708 else 2155 @ 0x18691

goto 2156 @ 0x186fd

if (not(flag:z) && not(flag:c)) then 2156 @ 0x186fd else 1904 @ 0x18685

if (not(flag:s)) then 306 @ 0x18396 else 2157 @ 0x1831d

if (not(flag:s)) then 166 @ 0x18334 else 2158 @ 0x182bb

es = pop.w
goto 2159 @ 0x189bb

bl = 0x59
flag:c = 1
edi = pop
bh = 0x88
eax = eax ^ [ecx + (ebp << 2)].d
al = al + [ebx + 0x16].b
temp113.b = [ebx - 0x4d7b1608].b
[ebx - 0x4d7b1608].b = [ebx - 0x4d7b1608].b + bl
flag:c = temp113.b + bl u< temp113.b
flag:p = unimplemented
flag:z = temp113.b == neg.b(bl)
flag:s = temp113.b + bl s< 0
flag:o = add_overflow(temp113.b, bl)
flag:d = 0
__out_dx_al(dx, al, eflags)
al, ah, eflags = __aas(al, ah, eflags)
if (flag:z || flag:c) then 2159 @ 0x189bb else 2161 @ 0x18951

push(ebp)
ebx = 0xfe7c8d20
push(0x7c798370)
goto 2162 @ 0x18987

ebp = ebp + 1
goto 1917 @ 0x1896d

flag:d = 1
[ecx - 0x2e].d & eax
al = 0x69
al, eflags = __das(al, eflags)
ebx = pop
temp114.d = [edi].d
flag:c = eax u< temp114.d
if (flag:d) then 2164 else 2166

goto 2168 @ 0x18855

goto 1791 @ 0x1880d

esp - -0x1f7e1142
esi = [ebp - 0x523e1422].d * -0x2f8d4d8f
esp = pop
al = [esi].b
if (flag:d) then 2170 else 2172

temp115.d = [esi].d
temp116.d = [edi].d
flag:c = temp115.d u< temp116.d
flag:p = unimplemented
flag:z = temp115.d == temp116.d
flag:s = temp115.d - temp116.d s< 0
flag:o = add_overflow(temp115.d, neg.d(temp116.d))
if (flag:d) then 2174 else 2177

if (not(flag:s)) then 1657 @ 0x18812 else 2180 @ 0x18799

if (not(flag:s)) then 2181 @ 0x187f1 else 2121 @ 0x18813

esi = esi - 1
goto 2182 @ 0x1871f

esi = esi + 1
goto 2182 @ 0x1871f

ah = flagbit.b(flag:s, 7) | flagbit.b(flag:z, 6) | flagbit.b(flag:a, 4) | flagbit.b(flag:p, 2) | flagbit.b(flag:c, 0)
goto 2130 @ 0x18876

if (not(flag:s)) then 2184 @ 0x18877 else 2185 @ 0x187fe

if (not(flag:s)) then 2185 @ 0x187fe else 2189 @ 0x18785

temp117.d = [esp + (esi << 2) + 0x58d8f81e].d
cond:34 = flag:c
[esp + (esi << 2) + 0x58d8f81e].d = rrc.d(temp117.d, cl, cond:34)
flag:c = unimplemented
eax = eax - 1
goto 2190 @ 0x1886d

edx = 0x79f4e6e6
goto 2138 @ 0x187e3

if (not(flag:s)) then 2192 @ 0x187ad else 2193 @ 0x18774  {"yyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyy"}

esi = __outsb(dx, [esi].b, esi, eflags)
goto 2140 @ 0x1870d

if (not(flag:s)) then 2194 @ 0x186b9 else 1546 @ 0x18737

flag:c = test_bit(ah, 0)
flag:p = test_bit(ah, 2)
flag:a = test_bit(ah, 4)
flag:z = test_bit(ah, 6)
flag:s = test_bit(ah, 7)
goto 2089 @ 0x18735

temp118.b = [edi].b
[edi].b = neg.b([edi].b)
flag:z = neg.b(temp118.b) == 0
flag:s = neg.b(temp118.b) s< 0
flag:o = neg.b(temp118.b) == 0x80
goto 2206 @ 0x188b6

eax = __in_oeax_dx(dx, eflags)
goto 2104 @ 0x1883c

undefined

if (not(flag:s)) then 2217 @ 0x1883e else 2219 @ 0x187c5

if (not(flag:s)) then 2220 @ 0x187e7 else 2222 @ 0x1876e

undefined

if (not(flag:s)) then 1996 @ 0x187dd else 2223 @ 0x187ff

if (not(flag:z) && not(flag:c)) then 2225 @ 0x1870a else 2226 @ 0x18694

al = 0x99
call(0x79d4006d)
temp119.d = [ecx - 0x70].d
[ecx - 0x70].d = [ecx - 0x70].d s>> 0x79
flag:c = unimplemented
flag:p = unimplemented
flag:z = temp119.d s>> 0x79 == 0
flag:s = temp119.d s>> 0x79 s< 0
flag:o = unimplemented
if (flag:z) then 2227 @ 0x1876b else 2228 @ 0x186fa

if (not(flag:s)) then 2238 @ 0x18729 else 2194 @ 0x186b9

if (not(flag:s)) then 1964 @ 0x187c0 else 1789 @ 0x18815

if (not(flag:s)) then 1789 @ 0x18815 else 2239 @ 0x1879c

goto 2240 @ 0x187e2

st0 = float.t([ecx + 0x79].d) f/ st0
goto 1867 @ 0x18820

if (not(flag:s)) then 2241 @ 0x18814 else 2242 @ 0x18837

if (flag:p) then 1851 @ 0x1879f else 1840 @ 0x187be

edx = pop
goto 2246 @ 0x1887c

ebx = rrc.d(ebx, 0x70, flag:c)
temp120.b = al
al = al + 0x4f
flag:s = temp120.b + 0x4f s< 0
goto 2128 @ 0x1887b

if (not(flag:s)) then 2223 @ 0x187ff else 2247 @ 0x18786

goto 2120 @ 0x186b7  {"ypm"v"}

if (not(flag:s)) then 2248 @ 0x187e8 else 2249 @ 0x1876f

__out_immb_al(0x79, al, eflags)
goto 1948 @ 0x187e5

push(zx.d(0x6c))
goto 2251 @ 0x1870f

if (not(flag:s)) then 2240 @ 0x187e2 else 2252 @ 0x18769

goto 2110 @ 0x186eb

esp = ebp
ebp = pop
goto 2253 @ 0x1882b

temp121.d = [ecx + 0x39].d
flag:c = temp121.d u< edi
flag:p = unimplemented
flag:z = temp121.d == edi
flag:s = temp121.d - edi s< 0
flag:o = add_overflow(temp121.d, neg.d(edi))
goto 2255 @ 0x187b3

if (not(flag:c)) then 1670 @ 0x1877d else 2087 @ 0x1870c  {"yyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyy"}

if (flag:s) then 2225 @ 0x1870a else 2256 @ 0x18693

if (flag:s) then 2257 @ 0x18773 else 1311 @ 0x186ff  {"9yyyyyyyyyyyyyyyyyyyyyyyyyyyyyyy"}

if (not(flag:s)) then 128 @ 0x18398 else 2264 @ 0x1831f

if (not(flag:s)) then 188 @ 0x18336 else 2265 @ 0x182bd

push(ecx)
if (flag:s == flag:o) then 2266 @ 0x189cb else 2277 @ 0x189be

if (flag:p) then 2020 @ 0x189ba else 2286 @ 0x18953

ecx = ecx - 1
if (ecx != 0) then 2299 @ 0x189b0 else 2300 @ 0x18989

edi = edi - 4
goto 2306

edi = edi + 4
goto 2306

__out_dx_al(dx, al, eflags)
goto 1818 @ 0x18856

esi = esi - 1
goto 2307 @ 0x1889b

esi = esi + 1
goto 2307 @ 0x1889b

esi = esi - 4
edi = edi - 4
goto 2311

esi = esi + 4
edi = edi + 4
goto 2311

if (not(flag:s)) then 2241 @ 0x18814 else 2312 @ 0x1879b

if (not(flag:s)) then 1828 @ 0x187d9 else 2313 @ 0x187f3

unimplemented  {enter sub_3b60+3, 0x55}
goto 1542 @ 0x18723

undefined

st4 = st0 f- st4
__free_slot(st0)
top = top + 1
goto 2314 @ 0x18800

if (not(flag:s)) then 2314 @ 0x18800 else 1525 @ 0x18787

ds = pop.w
goto 2315 @ 0x1886e

if (not(flag:s)) then 2321 @ 0x18828 else 2323 @ 0x187af

if (not(flag:s)) then 2324 @ 0x187ef else 2325 @ 0x18776  {"yyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyy"}

temp0, edi = __insd(edi, dx, eflags)
[edi].d = temp0.d
temp122.b = dh
temp123.b = [esi].b
dh = dh & [esi].b
flag:c = 0
flag:p = unimplemented
flag:a = undefined
flag:z = (temp122.b & temp123.b) == 0
flag:s = (temp122.b & temp123.b) s< 0
flag:o = 0
if (flag:z) then 1892 @ 0x18731 else 2326 @ 0x186bf

push(eax)
push(ecx)
push(edx)
push(ebx)
push(esp)
push(ebp)
push(esi)
push(edi)
esi = 0xc871beaf
ecx = pop
if (not(flag:z) && flag:s == flag:o) then 2327 @ 0x188fe else 2330 @ 0x188bf

st0 = st0 f- st0
goto 2005 @ 0x18827

if (not(flag:s)) then 2334 @ 0x18844 else 2336 @ 0x187c7

edx = 0xbaba7979
goto 2337 @ 0x187ec

if (not(flag:s)) then 2252 @ 0x18769 else 1959 @ 0x18770  {"yyy9yyyyyyyyyyyyyyyyyyyyyyyyyyyy"}

al = __in_al_immb(0x79, eflags)
goto 2340 @ 0x18801

if (not(flag:c)) then 1670 @ 0x1877d else 2087 @ 0x1870c  {"yyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyy"}

if (flag:s) then 2341 @ 0x1870e else 2344 @ 0x18696

if (not(flag:s)) then 2345 @ 0x187e6 else 2137 @ 0x1876d

temp124.b = bh
temp125.b = [eax].b
bh = bh & [eax].b
flag:c = 0
flag:p = unimplemented
flag:a = undefined
flag:z = (temp124.b & temp125.b) == 0
flag:s = (temp124.b & temp125.b) s< 0
flag:o = 0
goto 2156 @ 0x186fd

if (not(flag:s)) then 1231 @ 0x186db else 2346 @ 0x1872b

if (not(flag:s)) then 2348 @ 0x18817 else 2349 @ 0x1879e

if (not(flag:s)) then 2350 @ 0x187ca else 2351 @ 0x187e4

if (flag:d) then 2352 else 2355

st5 = st0 f- st5
__free_slot(st0)
top = top + 1
goto 1963 @ 0x18839

if (not(flag:s)) then 2358 @ 0x1883f else 2360 @ 0x1887e

if (not(flag:s)) then 2340 @ 0x18801 else 2369 @ 0x18788

if (not(flag:s)) then 2370 @ 0x18863 else 2376 @ 0x187ea

flag:c = 1
goto 1959 @ 0x18770  {"yyy9yyyyyyyyyyyyyyyyyyyyyyyyyyyy"}

if (flag:z || flag:c) then 2369 @ 0x18788 else 2378 @ 0x18711

if (not(flag:s)) then 2351 @ 0x187e4 else 2227 @ 0x1876b

edx = 0x7979ddeb
goto 2379 @ 0x18830

if (not(flag:s)) then 2381 @ 0x1882e else 2382 @ 0x187b5

if (flag:z || flag:c) then 2140 @ 0x1870d else 2384 @ 0x18695

temp126.d = [ecx + 0x79].d
flag:c = temp126.d u< edi
flag:p = unimplemented
flag:z = temp126.d == edi
flag:s = temp126.d - edi s< 0
flag:o = add_overflow(temp126.d, neg.d(edi))
goto 2325 @ 0x18776  {"yyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyy"}

if (not(flag:s)) then 2385 @ 0x18312 else 97 @ 0x18321

if (not(flag:s)) then 207 @ 0x18338 else 251 @ 0x182bf

temp127.b = [ecx - 0x7db8aefd].b
[ecx - 0x7db8aefd].b = [ecx - 0x7db8aefd].b + bh
flag:c = temp127.b + bh u< temp127.b
bl = 0x6c
eax = sx.d(ax)
__out_dx_al(dx, al, eflags)
ebx = ebx - 1
al = __in_al_dx(dx, eflags)
edx = sbb.d(edx, [edx - 0x1b9555c].d, flag:c)
eflags = __sti(eflags)
undefined

dl - [ebx + (ebx << 2) + 0x7db9dd01].b
edi = pop
ds = pop.w
al = __salc(eflags)
temp0, edi = __insb(edi, dx, eflags)
[edi].b = temp0.b
eflags = __cli(eflags)
es = pop.w
goto 2266 @ 0x189cb

ch = 0x28
al, ah, eflags = __aaa(al, ah, eflags)
esp & edi
al = 0x12
flag:c = 0
temp128.d = eax
eax = eax + 1
flag:p = unimplemented
flag:a = unimplemented
flag:z = temp128.d == -1
flag:s = temp128.d + 1 s< 0
flag:o = add_overflow(temp128.d, 1)
goto 2386 @ 0x18961

if (([esi].d & eax) s> 0) then 2388 @ 0x189fc else 1910 @ 0x189b2

eax = __in_oeax_immb(0x71, eflags)
temp0.d = [eax + 0x5f38851].d
[eax + 0x5f38851].d = eax
eax = temp0.d
esi = esi ^ 0xe5180695
undefined

goto 2391 @ 0x188fd

[ebx - 0x31].b = [ebx - 0x31].b | 0x4c
push(ebx)
breakpoint

goto 2069 @ 0x18811

if (not(flag:s)) then 2395 @ 0x18816 else 1690 @ 0x1879d

if (not(flag:s)) then 1552 @ 0x187e9 else 2397 @ 0x187f5

if (not(flag:s)) then 2128 @ 0x1887b else 1661 @ 0x18802

temp129.b = ah
cond:35 = flag:c
ah = sbb.b(temp129.b, -0x10, cond:35)
flag:c = unimplemented
call(-0xffffffff9f0c17a3)
goto 2130 @ 0x18876

al = __in_al_dx(dx, eflags)
if (not(flag:s)) then 1527 @ 0x187f4 else 2253 @ 0x1882b

if (flag:p) then 2376 @ 0x187ea else 2398 @ 0x187b1

if (not(flag:s)) then 2399 @ 0x187d7 else 2181 @ 0x187f1

if (not(flag:s)) then 2181 @ 0x187f1 else 2400 @ 0x18778  {"yyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyy"}

if (not(flag:z) && not(flag:c)) then 1695 @ 0x18739 else 2401 @ 0x186c1

__free_slot(st2)
ah - [ebx - 0x1183b078].b
goto 2402 @ 0x18906

temp0.d = ebp
ebp = eax
eax = temp0.d
undefined

ecx = ecx - 1
if (ecx != 0) then 2330 @ 0x188bf else 2404 @ 0x18846

if (not(flag:s)) then 2406 @ 0x18845 else 2407 @ 0x187c9

temp130.b = [eax].b
[eax].b = [eax].b - ch
if (temp130.b - ch s>= 0) then 2408 @ 0x18869 else 1870 @ 0x187f0

if (not(flag:s)) then 2246 @ 0x1887c else 2413 @ 0x18803

temp0, edi = __insb(edi, dx, eflags)
[edi].b = temp0.b
goto 2251 @ 0x1870f

if (flag:s) then 2414 @ 0x18702 else 2416 @ 0x18698

trap(0xd)
{ Does not return }

dl = 0x9b
goto 1575 @ 0x1872d

if (not(flag:s)) then 2053 @ 0x18892 else 2418 @ 0x18819

if (not(flag:s)) then 1828 @ 0x187d9 else 2420 @ 0x187a0

if (flag:z || flag:s != flag:o) then 2422 @ 0x1884a else 2423 @ 0x187cc

if (not(flag:s)) then 1957 @ 0x187da else 2345 @ 0x187e6

[edi].d = eax
edi = edi - 4
goto 2424

[edi].d = eax
edi = edi + 4
goto 2424

call(-0xffffffffe57b6e2f)
goto 2334 @ 0x18844

eip, eflags = __into(eflags)
temp131.d = [ecx + 0x7962dc80].d
[ecx + 0x7962dc80].d = [ecx + 0x7962dc80].d + 0x65
flag:c = temp131.d u>= 0xffffff9b
flag:p = unimplemented
flag:z = temp131.d == -0x65
flag:s = temp131.d + 0x65 s< 0
flag:o = add_overflow(temp131.d, 0x65)
goto 1644 @ 0x18886

if (not(flag:s)) then 2413 @ 0x18803 else 2425 @ 0x1878a

temp132.d = esi
temp133.d = [edi].d
cond:36 = flag:c
esi = sbb.d(temp132.d, temp133.d, cond:36)
flag:c = unimplemented
goto 2078 @ 0x18865

edx = 0x792828ba
goto 2324 @ 0x187ef

if (flag:s) then 2425 @ 0x1878a else 2426 @ 0x18713

st4 = st4 f- st0
goto 1925 @ 0x18832

if (not(flag:s)) then 2427 @ 0x188a9 else 2379 @ 0x18830

edx:eax = sx.q(eax)
if (not(flag:s)) then 1782 @ 0x18831 else 1873 @ 0x187b8

if (flag:s) then 2251 @ 0x1870f else 2432 @ 0x18697

if (not(flag:s)) then 2435 @ 0x1838d else 2437 @ 0x18314

eax = [-0xfffffffffa6acc21].d
if (flag:s != flag:o) then 2438 @ 0x1896a else 2440 @ 0x18968

eflags = __cli(eflags)
push(zx.d(ss))
jump(-0xffffffffe0667bdd)

ebp = sbb.d(ebp, -0x775cc53e, flag:c)
temp134.d = edi
edi = edi - 1
if (temp134.d s< 1) then 2045 @ 0x188f4 else 2402 @ 0x18906

eax = __in_oeax_immb(0x79, eflags)
goto 1850 @ 0x18818

if (not(flag:s)) then 1712 @ 0x187eb else 1715 @ 0x187f7

if (not(flag:s)) then 2337 @ 0x187ec else 2255 @ 0x187b3

if (flag:z || flag:s != flag:o) then 2340 @ 0x18801 else 1828 @ 0x187d9

if (not(flag:s)) then 2313 @ 0x187f3 else 2449 @ 0x1877a  {"yyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyy"}

if (flag:s) then 1526 @ 0x18718 else 1866 @ 0x186c3

[eax - 0x29].b & bh
goto 2450 @ 0x18909

st0 = float.t([edx - 0x12868615].d) f/ st0
goto 2453 @ 0x1884c

if (not(flag:s)) then 1971 @ 0x18821 else 2454 @ 0x18847

if (flag:s != flag:o) then 2456 @ 0x18849 else 2457 @ 0x187cb

flag:c = 0
st0 f- fconvert.t([eax + 0x48].d)
__free_slot(st0)
top = top + 1
goto 2190 @ 0x1886d

if (not(flag:s)) then 2360 @ 0x1887e else 2458 @ 0x18805

push(ebp)
goto 1530 @ 0x18703

esp = esp & ebp
goto 1727 @ 0x1869a

ch = rrc.b(ch, 0xeb, flag:c)
undefined

flag:c = 1
goto 1970 @ 0x187a1

if (not(flag:s)) then 1963 @ 0x18839 else 2453 @ 0x1884c

if (flag:s != flag:o) then 2422 @ 0x1884a else 1429 @ 0x187ce

goto 1789 @ 0x18815

if (not(flag:s)) then 2458 @ 0x18805 else 2460 @ 0x1878c

if (not(flag:z) && not(flag:c)) then 1416 @ 0x1878d else 2461 @ 0x18715

flag:c = al u< 0x7d
flag:p = unimplemented
flag:s = al - 0x7d s< 0
flag:o = add_overflow(al, -0x7d)
if (not(flag:c)) then 2462 @ 0x1891e else 2463 @ 0x188ad

push(zx.d(0x23))
eax = __in_oeax_immb(0x4e, eflags)
goto 1896 @ 0x1869b

[ebp - 0x6ba4654c].b & bl
goto 1618 @ 0x18393

if (not(flag:s)) then 1494 @ 0x1838f else 2464 @ 0x18316

push(flagbit.d(flag:o, 0xb) | flagbit.d(flag:d, 0xa) | flagbit.d(flag:s, 7) | flagbit.d(flag:z, 6) | flagbit.d(flag:a, 4) | flagbit.d(flag:p, 2) | flagbit.d(flag:c, 0))
goto 1775 @ 0x1896b

temp135.d = ebp
ebp = ebp - 1
flag:p = unimplemented
flag:a = unimplemented
flag:z = temp135.d == 1
flag:s = temp135.d - 1 s< 0
flag:o = add_overflow(temp135.d, -1)
push(flagbit.d(flag:o, 0xb) | flagbit.d(flag:d, 0xa) | flagbit.d(flag:s, 7) | flagbit.d(flag:z, 6) | flagbit.d(flag:a, 4) | flagbit.d(flag:p, 2) | flagbit.d(flag:c, 0))
goto 1775 @ 0x1896b

if (not(flag:s)) then 2397 @ 0x187f5 else 1555 @ 0x1877c  {"yyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyy"}

esi = __outsb(dx, [esi].b, esi, eflags)
dl = 0xf0
undefined

undefined

edx = 0xed7979eb
goto 2453 @ 0x1884c

if (not(flag:s)) then 2465 @ 0x188c4 else 2492 @ 0x1884b

if (flag:z || flag:s != flag:o) then 2456 @ 0x18849 else 2494 @ 0x187cd

__out_immb_oeax(0x79, eax, eflags)
goto 2495 @ 0x18807

if (not(flag:s)) then 2495 @ 0x18807 else 1417 @ 0x1878e

if (flag:s) then 1521 @ 0x1878f else 2496 @ 0x18717

if (flag:s == flag:o) then 2498 @ 0x1897a else 2501 @ 0x18920

if (flag:p) then 2505 @ 0x188e0 else 2508 @ 0x188af

if (not(flag:s)) then 1616 @ 0x18391 else 2511 @ 0x18318

eax = 0x7f7eee84
flag:c = 1
eax = sx.d(ax)
dh = not.b(dh)
ebp = ebp + 1
ebp = pop
ecx = pop
edi = edi + 1
ecx = 0x5549ceb7
al, ah, eflags = __aas(al, ah, eflags)
edi = pop
esi = pop
ebp = pop
esp = esp + 4
ebx = pop
edx = pop
ecx = pop
eax = pop
temp136.b = al
al = al & 0x25
flag:c = 0
flag:p = unimplemented
flag:a = undefined
flag:z = (temp136.b & 0x25) == 0
flag:s = (temp136.b & 0x25) s< 0
flag:o = 0
if (flag:d) then 2512 else 2515

eax = __in_oeax_dx(dx, eflags)
goto 2453 @ 0x1884c

if (flag:s != flag:o) then 2518 @ 0x1884d else 1645 @ 0x187cf

if (not(flag:s)) then 2520 @ 0x18882 else 1522 @ 0x18809

esi = __outsd(dx, [esi].d, esi, eflags)
goto 1526 @ 0x18718

edi = 0x20bb5565
edi = esi + (edi << 3) + 0x68
if (flag:o) then 2522 @ 0x18908 else 2524 @ 0x18985

temp137.d = [edx].d
edi = [edx].d * 0x4414f9eb
flag:o = unimplemented
if (not(flag:o)) then 2525 @ 0x188f7 else 2529 @ 0x18928

[eax - 0x48fb8813].b = [eax - 0x48fb8813].b << 1
esp = pop
goto 2540 @ 0x188e7

temp138.d = ecx
ecx = ecx + 1
if (temp138.d s< -1) then 1951 @ 0x1885c else 2551 @ 0x188b3

if (not(flag:s)) then 1618 @ 0x18393 else 257 @ 0x1831a

[edi].d = eax
edi = edi - 4
goto 2559 @ 0x188db

[edi].d = eax
edi = edi + 4
goto 2559 @ 0x188db

__out_dx_al(dx, al, eflags)
if (not(flag:s)) then 2381 @ 0x1882e else 2560 @ 0x18850

st0 = st0 f- fconvert.t([edx + 0x79].q)
if (flag:p) then 1782 @ 0x18831 else 1784 @ 0x18888

al = [ebx + al.d].b
goto 2450 @ 0x18909

if (not(flag:s)) then 2561 @ 0x18a03 else 2162 @ 0x18987

temp139.b = [eax - 0x50a4d097].b
[eax - 0x50a4d097].b = [eax - 0x50a4d097].b << cl
flag:c = unimplemented
goto 2391 @ 0x188fd

temp0.d = pop
flag:c = test_bit(temp0.d, 0)
flag:p = test_bit(temp0.d, 2)
flag:a = test_bit(temp0.d, 4)
flag:z = test_bit(temp0.d, 6)
flag:s = test_bit(temp0.d, 7)
flag:d = test_bit(temp0.d, 0xa)
flag:o = test_bit(temp0.d, 0xb)
al = adc.b(al, 6, flag:c)
ch = 0xff
undefined

temp0, edi = __insb(edi, dx, eflags)
[edi].b = temp0.b
temp140.b = al
al = al - 0x32
flag:c = temp140.b u>= 0x32
flag:p = unimplemented
flag:a = unimplemented
flag:z = temp140.b == 0x32
flag:s = temp140.b - 0x32 s< 0
flag:o = add_overflow(temp140.b, -0x32)
goto 2564 @ 0x188ea

temp141.b = dh
temp142.b = dh
dh = dh + dh
flag:z = temp141.b == neg.b(temp142.b)
flag:s = temp141.b + temp142.b s< 0
flag:o = add_overflow(temp141.b, temp142.b)
ds = pop.w
goto 2206 @ 0x188b6

if (flag:s == flag:o) then 2565 @ 0x18861 else 2568 @ 0x188dd

goto 2379 @ 0x18830

temp0, edi = __insb(edi, dx, eflags)
[edi].b = temp0.b
if (not(flag:c)) then 2572 @ 0x1899f else 2573 @ 0x18a06

if (ecx == 0) then 2386 @ 0x18961 else 2579 @ 0x188ec

temp0, eflags = __arpl_memw_gpr16([edx].w, di)
[edx].w = temp0.w
goto 2370 @ 0x18863

temp0.d = [ebp - 0x124f2fcd].d
[ebp - 0x124f2fcd].d = eax
eax = temp0.d
if (not(flag:z) && not(flag:c)) then 2580 @ 0x188e9 else 2582 @ 0x188e5

if (flag:d) then 2584 else 2587

al = __in_al_dx(dx, eflags)
temp0.d = edx
edx = eax
eax = temp0.d
edx = [edx + ecx - 0x5c5001ff].d
undefined

if (flag:z || flag:s != flag:o) then 2315 @ 0x1886e else 2590 @ 0x188ee

eip, eflags = __into(eflags)
goto 2564 @ 0x188ea

bh = 0x5c
goto 2540 @ 0x188e7

[edi].b = al
edi = edi - 1
goto 2592 @ 0x189a0

[edi].b = al
edi = edi + 1
goto 2592 @ 0x189a0

top = top + 1
goto 1923 @ 0x188f0

if (flag:d) then 2593 else 2597

[edi].b = [esi].b
edi = edi - 1
esi = esi - 1
goto 2601 @ 0x189a1

[edi].b = [esi].b
edi = edi + 1
esi = esi + 1
goto 2601 @ 0x189a1

temp143.d = [esi - 0x73].d
flag:c = 0
flag:c = flag:c ^ 1
temp0, edi = __insd(edi, dx, eflags)
[edi].d = temp0.d
bh = bh ^ [edi].b
cond:19 = bh != 0
temp0.d = ecx
ecx = eax
eax = temp0.d
ecx = ecx - 1
if (cond:19 && ecx != 0) then 2300 @ 0x18989 else 2613 @ 0x189ab

temp0.d = [edi - 0x12].d
[edi - 0x12].d = ebp
ebp = temp0.d
goto 2299 @ 0x189b0

int32_t __convention("regparm") sub_193f4(int32_t arg1, int32_t* arg2, void* arg3 @ ebp, int32_t arg4 @ esi, int32_t* arg5 @ edi)
temp1.d = esp {__return_addr}
temp2.d = [edi].d
esp = esp & [edi].d
flag:c = 0
eax = eax - 1
eax = sbb.d(eax, -0x419fca09, flag:c)
cl = 0xb1
eax = eax ^ 0xf8415d35
push(ecx)
ecx = pop
eax = eax ^ 0x38359659
cl - [ebx + 0x38 {&data_38}].b
eax = eax ^ 0x3579e745
[ebp + 0x35].d = [ebp + 0x35].d | edi
eax = eax ^ 0x38753e35
bh - [edx].b
[eax].b - bh
dl - [ebp + 0x61].b
eax = eax ^ 0x3535355d
eax = eax ^ 0x3a45bd35
[esi + 0x59d3ed47].b - dh
eax = eax & 0xc277be35
al, ah, eflags = __aaa(al, ah, eflags)
dh - [esi].b
0
temp3.b = bh
bh = bh << 0xb8
flag:c = unimplemented
flag:z = temp3.b << 0xb8 == 0
ecx = pop
push(zx.d(ds))
if (flag:z || flag:c) then 32 @ 0x19485 else 42 @ 0x19444

eax = eax - -0x3fc23fc8
temp0.d = [eax - 0x40].d
[eax - 0x40].d = edi
edi = temp0.d
push(ebp)
push(ebp)
al = al - 0x42
edi & esi
push(-0x3f3fc788)
undefined

[eax - 0x79].d = esp
eflags = __sti(eflags)
edi = [edx].d * -0x7800a42
ebx, es = __les_gprz_memp([ecx - 0x5200b898].6)
[-0xffffffff8c8b8bed].d = [-0xffffffff8c8b8bed].d ^ esi
eax = eax ^ 0xcd8a3539
temp0.d = pop
esp = esp + 0x87f9
<return> jump(temp0.d)

int32_t __convention("regparm") sub_19462(int32_t arg1, int16_t arg2, void* arg3 @ ebp, void* arg4 @ esi, void* arg5 @ edi)
eax = eax ^ 0x8847b886
[ebp - 0x3f78bacb].w = ds
temp1.b = [0x35354d45].b
[0x35354d45].b = [0x35354d45].b << 0x9f
flag:c = unimplemented
[ebx + 0x39c03675 {0x39c03675}].b = dh
[edi - 0x3ffa70bb].b = sbb.b([edi - 0x3ffa70bb].b, 0x34, flag:c)
al & 0xff
eax = eax ^ 0x3dc0382d
[edi + 0x5555c078].b = rol.b([edi + 0x5555c078].b, 0x80)
[esi + 0x7868f785].b = [esi + 0x7868f785].b s>> 0x38
al = rol.b(al, 0xff)
[esi + 0x413880f7].b - bh
eax - -0x3fc7ae80
temp0.d = pop
esp = esp + 0x2751
<return> jump(temp0.d)

int32_t __convention("regparm") sub_196b9(int32_t arg1)
jump([eax].d)

int32_t __convention("regparm") sub_1be1f(int32_t arg1)
push(eax)
jump(eax)

int32_t sub_1ca2c()
call([eax - 0x6f01].d)
ah = 0xff
call([eax - 0x6000ff30].d)
ebx = pop
__out_dx_al(dx, al, eflags)
[eax].b = [eax].b + al
[eax].d = [eax].d + 1
jump([ebx].d)

int32_t sub_1ca59(void* arg1 @ esi, int80_t arg2 @ st0, int80_t arg3 @ st1)
push([esi - 0x5c261e].d)
dh = 0xc5
call([ebp - 0x12].d)
if (flag:z || flag:c) then 4 @ 0x1ca1c else 9 @ 0x1ca66

[eax].b = [eax].b + al
eflags = __sti(eflags)
cl = cl + al
[ecx - 0x23ca2200].b = [ecx - 0x23ca2200].b + ch
undefined

st0 f- st1
__free_slot(st0)
__free_slot(st1)
top = top + 2
al, ah, eflags = __aad_immb(0, al, ah)
[esi - 0x7e422a9c].d = [esi - 0x7e422a9c].d - 1
[eax].d = [eax].d + 1
push([ebx - 0x32 {0xffffffce}].d)
ch = ch + dl
undefined

int32_t __convention("regparm") sub_1ca7a(char* arg1, int16_t arg2, int32_t arg3 @ esi, int32_t arg4 @ edi)
[eax].b = [eax].b + al
[eax].b = [eax].b + al
temp0, edi = __insb(edi, dx, eflags)
[edi].b = temp0.b
[eax].d = [eax].d + 1
__out_immb_oeax(0, eax, eflags)
eax & 0xdc35ff00
if (flag:d) then 8 else 11

[edi].b = al
edi = edi - 1
goto 14 @ 0x1ca89

[edi].b = al
edi = edi + 1
goto 14 @ 0x1ca89

edx:eax = mulu.dp.d(eax, esi)
temp0.d = divs.dp.d(edx:eax, edi)
temp1.d = mods.dp.d(edx:eax, edi)
eax = temp0.d
edx = temp1.d
al - -0x12
undefined

int32_t __convention("regparm") sub_1ca96(char arg1)
esp, ds = __lds_gprz_memp([ebx {sub_0}].6)
al = sbb.b(al, 0, flag:c)
[-0xffffffff87ac5b93].d = [-0xffffffff87ac5b93].d + 1
undefined

int32_t __convention("regparm") sub_1cd7a(int32_t arg1) __noreturn
esp = esp + 1
[eax + eax - 0x34].b = [eax + eax - 0x34].b + al
breakpoint

int32_t __convention("regparm") sub_1cd82(int32_t arg1, uint16_t arg2) __noreturn
esp = esp + 1
al = __in_al_dx(dx, eflags)
esp = esp + 1
breakpoint

int32_t sub_1cd92() __noreturn
esp = esp + 1
breakpoint

int32_t __convention("regparm") sub_1cdd1(uint8_t arg1, uint16_t arg2, int32_t arg3) __noreturn
temp0.d = esp {__return_addr}
esp = esp - -0x333333b4
cond:0 = temp0.d != -0x333333b4
ecx = ecx - 1
if (cond:0 && ecx != 0) then 5 @ 0x1cdc7 else 9 @ 0x1cdd9

esp = esp + 1
eax & 0xcccccccc
breakpoint

__out_dx_al(dx, al, eflags)
breakpoint

int32_t sub_1d6e7() __noreturn
esp = esp - 1
breakpoint

int32_t sub_1d6ed() __noreturn
esp = esp - 1
breakpoint

int32_t sub_1d70d() __noreturn
esp = esp - 1
breakpoint

int32_t sub_1d72d() __noreturn
esp = esp - 1
breakpoint

int32_t __convention("regparm") sub_1d736(int32_t arg1) __noreturn
esp = esp - 1
ebx = 0x999999bb
edx:eax = sx.q(eax)
ebx = 0xffbb99bb
call([ecx - 0x33440001].6)
breakpoint

int32_t sub_1d74d() __noreturn
esp = esp - 1
breakpoint

int32_t __convention("regparm") sub_1d756(int32_t arg1)
esp = esp - 1
ebx = 0x999999bb
edx:eax = sx.q(eax)
ebx = 0xffbb99bb
call([ecx - 0x33440001].6)
undefined

int32_t sub_1d76d() __noreturn
esp = esp - 1
breakpoint

int32_t sub_1d78d() __noreturn
esp = esp - 1
breakpoint

int32_t sub_1d7ad() __noreturn
esp = esp - 1
breakpoint

int32_t sub_1d7cd() __noreturn
esp = esp - 1
breakpoint

int32_t sub_1f55e() __pure
temp0.d = pop
esp = esp + 0x4081
<return> jump(temp0.d)

int32_t __convention("regparm") sub_1f561(int32_t* arg1, char* arg2, int16_t arg3, void* arg4 @ esi)
al, ah, eflags = __aad_immb(0x81, al, ah)
push(eax)
al = al - 0x2d
dl = dl + [esi + 0x40].b
eax = [eax].d
al, ah, eflags = __aad_immb(0xff, al, ah)
temp1.d = [edx].d
[edx].d = [edx].d + 0x40008b89
flag:c = temp1.d u>= 0xbfff7477
al, ah, eflags = __aaa(al, ah, eflags)
dl = adc.b(dl, ch, flag:c)
temp0.d = pop
esp = esp + 0x8b2c
<return> jump(temp0.d)

void* __convention("regparm") sub_1f579(void* arg1, char arg2)
al = 0xc2
[eax - 0x73].b = [eax - 0x73].b + dl
temp0.d = pop
esp = esp + 0x4081
<return> jump(temp0.d)

int32_t __convention("regparm") sub_1f581(int32_t* arg1, char* arg2, int16_t arg3, void* arg4 @ esi)
al, ah, eflags = __aad_immb(0x81, al, ah)
push(eax)
al = al - 0x2d
dl = dl + [esi + 0x40].b
eax = [eax].d
al, ah, eflags = __aad_immb(0xff, al, ah)
temp1.d = [edx].d
[edx].d = [edx].d + 0x40008b89
flag:c = temp1.d u>= 0xbfff7477
esp = esp - 1
dl = adc.b(dl, ch, flag:c)
temp0.d = pop
esp = esp + 0xd52c
<return> jump(temp0.d)

int32_t __convention("regparm") sub_1f599(int32_t arg1, char* arg2 @ esi)
eax = eax - -0x724bff3e
al = [esi].b
if (flag:d) then 3 else 5

esi = esi - 1
goto 7 @ 0x1f59f

esi = esi + 1
goto 7 @ 0x1f59f

temp0.d = pop
esp = esp + 0x8140
<return> jump(temp0.d)

int32_t __convention("regparm") sub_1f5a2(int32_t* arg1, int32_t* arg2)
[eax + 0x2d].d = adc.d([eax + 0x2d].d, 0x8b0240, flag:c)
temp1.b = bh
temp2.b = bh
bh = bh + bh
flag:c = temp1.b + temp2.b u< temp1.b
[edx].d = adc.d([edx].d, -0x2a0f763e, flag:c)
eax = [eax].d
eax = eax - 0x40c18b8b
push(esi)
temp0.d = pop
esp = esp + 0x4081
<return> jump(temp0.d)

int32_t sub_1f5bc() __pure
temp0.d = pop
esp = esp + 0x8100
<return> jump(temp0.d)

int32_t __convention("regparm") sub_1f5bf(int32_t arg1, int32_t arg2, int16_t arg3, char* arg4 @ ebp)
al, ah, eflags = __aad_immb(0x2d, al, ah)
edx = ebp
al = al + ch
al = 0x8d
push(eax)
eax = eax - 0x8b4002
al, ah, eflags = __aad_immb(0x89, al, ah)
[edx].b = [edx].b + dl
eax = eax + 1
eax = eax - -0x7e74003e
al = __salc(eflags)
push(esi)
temp0.d = pop
esp = esp + 0x4081
<return> jump(temp0.d)

int32_t sub_1f5dc() __pure
temp0.d = pop
esp = esp + 0x8100
<return> jump(temp0.d)

void** __convention("regparm") sub_1f5df(void** arg1, int32_t arg2, void* arg3)
al, ah, eflags = __aad_immb(0x2f, al, ah)
edx = ebp
bl = bl + [ecx - 0x50].b
edx = eax + 0x2f
al = al + [eax - 0x75].b
temp1.b = ch
ch = ch + dl
flag:c = temp1.b + dl u< temp1.b
[eax].d = eax
al = adc.b(al, [eax + 0x2d].b, flag:c)
temp0.d = pop
esp = esp + 0x8bff
<return> jump(temp0.d)

void** __convention("regparm") sub_1f5f6(void** arg1, int32_t arg2, void* arg3, void* arg4 @ ebp)
[ebp + 0x56].d = [ebp + 0x56].d & 0xc24081c2
[ecx - 0x2a74d02b].b = [ecx - 0x2a74d02b].b + al
ch = ch + [ecx - 0x50].b
edx = eax + 0x2f
al = al + [eax - 0x75].b
temp1.b = ch
ch = ch + dl
flag:c = temp1.b + dl u< temp1.b
[eax].d = eax
al = adc.b(al, [eax + 0x2d].b, flag:c)
temp0.d = pop
esp = esp + 0x8bff
<return> jump(temp0.d)

int32_t __convention("regparm") sub_1f616(int32_t arg1, char* arg2, void* arg3, void* arg4 @ ebp, int32_t arg5 @ esi)
[ebp + 0x56].d = [ebp + 0x56].d ^ 0xc24081c2
[ecx - 0x2a74d22b].b = [ecx - 0x2a74d22b].b + al
ah = ah + [eax + (esi << 2) - 0x73].b
push(eax)
eax = eax - 0x8b4002
al, ah, eflags = __aad_immb(0x89, al, ah)
[edx].b = [edx].b + dl
eax = eax + 1
temp1.d = eax
eax = eax - -0x7e74003e
if (temp1.d == -0x7e74003e) then 11 @ 0x1f68f else 22 @ 0x1f639

ecx = [ebx + 0x12834000 {0x12834000}].d
al = al + dl
temp2.b = al
al = al - 0x50
flag:c = temp2.b u< 0x50
ebp = adc.d(ebp, -0x2abf7ed4, flag:c)
ebp = [edi + 0x56].d
ecx = [ebp + 0x200c2c2].d
ecx = [ecx - 0x74bfedd3].d * 0
eax = eax + 1
undefined

temp0.d = pop
esp = esp + 0x4081
<return> jump(temp0.d)

int32_t sub_1f63c() __pure
temp0.d = pop
esp = esp + 0x8100
<return> jump(temp0.d)

int32_t sub_1f65c() __pure
temp0.d = pop
esp = esp + 0x8100
<return> jump(temp0.d)

void** __convention("regparm") sub_1f65f(void** arg1, int32_t arg2, int16_t arg3, void* arg4 @ ebp)
al, ah, eflags = __aad_immb(0x2f, al, ah)
edx = ebp
bl = bl + [edx + 0x2f508db0].b
al = al + [eax - 0x75].b
temp1.b = ch
ch = ch + dl
flag:c = temp1.b + dl u< temp1.b
[eax].d = eax
al = adc.b(al, [eax + 0x2d].b, flag:c)
temp0.d = pop
esp = esp + 0x8bff
<return> jump(temp0.d)

int32_t* __convention("regparm") sub_1f676(int32_t* arg1, void* arg2 @ ebp)
[ebp + 0x4081ac8b].d = [ebp + 0x4081ac8b].d - -0x7e3dff3e
temp1.b = al
al = al - -0x2b
cond:0 = temp1.b - -0x2b s>= 0
al, ah, eflags = __aad_immb(2, al, ah)
if (cond:0) then 6 @ 0x1f6b3 else 10 @ 0x1f686

[eax].d = [eax].d + 0x50c2d502
temp0.d = pop
esp = esp + 0x2cd5
<return> jump(temp0.d)

edx = eax + 0x40
[eax].d = eax
al, ah, eflags = __aad_immb(0xff, al, ah)
temp2.d = eax
eax = eax ^ 0x40008b8b
flag:c = 0
[edx].d = adc.d([edx].d, 2, flag:c)
temp0.d = pop
esp = esp + 0x502c
<return> jump(temp0.d)

int32_t sub_1f6c4() __pure
temp0.d = pop
esp = esp + 0xac
<return> jump(temp0.d)

int32_t __convention("fastcall") sub_1f6c7(char arg1)
cl = cl + [ebx + 0xba4007 {0xba4007}].b
push(edi)
<return> jump(pop)

int32_t __convention("regparm") sub_1f708(int32_t arg1, int32_t* arg2, int32_t arg3 @ ebp)
al - dl
esp = [ebp + (edx << 3) - 0x3d2a7ed3].d
eax = [edx].d
[-0xfffffffff22c8b40].d = [-0xfffffffff22c8b40].d | 0xd5008b40
eax = [eax].d
al - [eax + 0x2c].b
temp0.d = pop
esp = esp + 0xb903
<return> jump(temp0.d)

int32_t __convention("regparm") sub_1f726(int32_t arg1, char arg2, int32_t* arg3, char* arg4 @ esi)
[ecx].d = adc.d([ecx].d, -0x55ffbf7f, flag:c)
dl = dl + ah
al = al - 9
al = [esi].b
if (flag:d) then 5 else 7

esi = esi - 1
goto 9 @ 0x1f731

esi = esi + 1
goto 9 @ 0x1f731

temp0.d = pop
esp = esp + 0x8b04  {"oosdanunmfoiItlreAomr"}
<return> jump(temp0.d)

int32_t __convention("regparm") sub_1f84d(int32_t arg1, char* arg2)
eax = eax - -0x743c2a7f
al = al + [eax].b
[edx + 0x40].d = [edx + 0x40].d + 0x40022d8b
eax = [eax].d
al, ah, eflags = __aad_immb(0x8b, al, ah)
[edx].b = [edx].b + al
eax = eax + 1
al, eflags = __das(al, eflags)
temp0.d = pop
esp = esp + 0x8b8b
<return> jump(temp0.d)

int32_t __convention("regparm") sub_1f866(int32_t* arg1, int32_t* arg2, int32_t arg3 @ ebp)
temp0.d = [ebp + (edx << 3) - 0x3cbf7ed3].d
[ebp + (edx << 3) - 0x3cbf7ed3].d = [ebp + (edx << 3) - 0x3cbf7ed3].d & 0x2dc26400
flag:c = 0
ebp = sbb.d(ebp, -0x74bf63fd, flag:c)
eax = [eax].d
al, ah, eflags = __aad_immb(0x8b, al, ah)
[edx].d = [edx].d - 0x22fc743d
eax = [eax].d
eax = eax - 0x40a0818b
<return> jump(pop)

int32_t __convention("regparm") sub_1f889(int32_t arg1, int32_t* arg2, int32_t arg3)
[ebx + (ecx << 2) + 0x2d40022d].b = [ebx + (ecx << 2) + 0x2d40022d].b + ah
[edx + (eax << 3) - 0x7474bf23].b = [edx + (eax << 3) - 0x7474bf23].b + bl
[edx].d = [edx].d - 0x2a9b743d
eax = eax - -0x743d227f
eax = eax + [eax].d
[eax + 0x132c8b40].d = [eax + 0x132c8b40].d & 0xdd008b40
eax = [eax].d
eax = eax + [eax + 0x2d].d
<return> jump(pop)

void __convention("regparm") sub_1f940(int32_t* arg1)
if (eax u> [ebx - 0x3cc1f9d8 {0xc33e0628}].d) then 1 @ 0x1f957 else 5 @ 0x1f948

[eax].d = [eax].d - 0x77e74b0
temp0.d = pop
esp = esp + 0x32ba
<return> jump(temp0.d)

temp0.d = pop
esp = esp + 0x3100
<return> jump(temp0.d)

void __convention("regparm") sub_1f94b(int32_t* arg1, int32_t arg2, int32_t arg3 @ esi)
push(zx.d(0x31))
[eax + 0x2d].b = [eax + 0x2d].b + al
esi = esi ^ edx
edx = 0x8bff31d5
[eax].d = [eax].d - 0x77e74b0
temp0.d = pop
esp = esp + 0x32ba
<return> jump(temp0.d)

int32_t __convention("regparm") sub_1f960(int32_t arg1, int32_t, int32_t arg3, void** arg4 @ esi, int32_t arg5 @ edi)
al, ah, eflags = __aad_immb(0x8d, al, ah)
ch = adc.b(ch, [0x40da4f8b].b, flag:c)
[ebx + 0x3e044c {0x3e044c}].d = [ebx + 0x3e044c {0x3e044c}].d + ecx
[esi].b = [esi].b + bh
edi = edi - 1
[ebx + 0x53000f1e {0x53000f1e}].b & al
temp0.d = pop
esp = esp + 0x2dd5
<return> jump(temp0.d)

int32_t __convention("regparm") sub_1f97c(void* arg1, void** arg2, char arg3, int32_t* arg4 @ ebp, char* arg5 @ esi, char* arg6 @ edi, long double arg7 @ st0, void* arg8)
[eax - 0x7f].d = [eax - 0x7f].d - 0x74745b2b
eax = eax + edx
al = [esi].b
if (flag:d) then 4 else 6

esi = esi - 1
goto 8 @ 0x1f986

esi = esi + 1
goto 8 @ 0x1f986

[edx].b = [edx].b + bl
edx = pop
[eax - 1].b = [eax - 1].b | al
[edx].b = [edx].b + dl
esi = esi - 1
eax = [edx].d
eax = eax - 0x520b8b50
ebx = pop
[eax + 0x75].d = [eax + 0x75].d + 0x2d04044e
if (flag:d) then 18 else 22

[edi].b = [esi].b
edi = edi - 1
esi = esi - 1
goto 26 @ 0x1f9a0

[edi].b = [esi].b
edi = edi + 1
esi = esi + 1
goto 26 @ 0x1f9a0

eax = ebx
esp = ebp
ebp = pop
edi = [esi].d
[ebx - 0x23].b = [ebx - 0x23].b + dl
eax = eax - 1
eax = eax | [esi + edi].d
ecx = ecx + [ebp + 0x41].d
push(esi)
esi = esi + 1
temp1.d = ebx
temp2.d = [ebx - 0x75].d
ebx = ebx + [ebx - 0x75].d
flag:c = temp1.d + temp2.d u< temp1.d
[ebx].d = adc.d([ebx].d, -0x48, flag:c)
[edi].b = [edi].b + cl
[eax].b = [eax].b + al
temp0 = __sldt_memw(ldtr)
[eax + 0x39009e00].w = temp0.w
temp3.d = [ebp + (eax << 2) - 0x3c9fff00].d
flag:c = 0
ebp = sbb.d(ebp, 0x2ee8b8b, flag:c)
temp4.b = [edi].b
[edi].b = [edi].b + al
flag:c = temp4.b + al u< temp4.b
[ebx + 0x2d].b = rlc.b([ebx + 0x2d].b, 0x13, flag:c)
eax = eax + 1
eax = [eax].d
[ebx + 0x2d400300].q = int.q(ftrunc.t(x87.pop))
<return> jump(pop)

int32_t __convention("regparm") sub_1f9e4(int32_t* arg1, int32_t arg2 @ ebp, long double arg3 @ st0)
ecx = [ebx + 0x2ddd8a81 {0x2ddd8a81}].d
temp0.d = [eax - 0x3d].d
[eax - 0x3d].d = [eax - 0x3d].d + 0x2fc3a400
flag:c = temp0.d u>= 0xd03c5c00
temp1.d = ebp
cond:0 = flag:c
ebp = sbb.d(temp1.d, -0x74bfbdf5, cond:0)
flag:c = unimplemented
eax = [eax].d
[ebx - 0x743cfc7f {0x8bc30381}].q = int.q(ftrunc.t(x87.pop))
ebx = adc.d(ebx, ebp, flag:c)
eax = [eax].d
eax = eax - 0x409c818b
<return> jump(pop)

int32_t __convention("regparm") sub_1fa1d(int32_t arg1)
al = al - -0x7f
__free_slot(st3)
ecx = [ebx {sub_0}].d
[ecx - 0x5b74bf5c {0x258366a3}].b = [ecx - 0x5b74bf5c {0x258366a3}].b + al
eax = eax + [eax + 0x61].d
[ebx + 0x2d034000 {0x2d034000}].b = [ebx + 0x2d034000 {0x2d034000}].b + cl
eax = eax - -0x22fc747f
<return> jump(pop)

int32_t sub_1fa78() __pure
temp0.d = pop
esp = esp + 0x7500
<return> jump(temp0.d)

int32_t __convention("regparm") sub_1fa7b(int32_t arg1, int32_t, void* arg3)
esi = [ebx {sub_0}].d
al, ah, eflags = __aad_immb(0x40, al, ah)
eax = eax - -0x229757c0
[ecx + 0x5dc1818b].b = rol.b([ecx + 0x5dc1818b].b, 0xa4)
ebp = [0x5e5b02].d
edi = pop
<return> jump(pop)

int32_t sub_1fb37()
undefined

int32_t __convention("regparm") sub_20ded(int32_t arg1, char* arg2 @ esi, char* arg3 @ edi)
al, ah, eflags = __aaa(al, ah, eflags)
al, ah, eflags = __aaa(al, ah, eflags)
if (flag:d) then 3 else 7

[edi].b = [esi].b
edi = edi - 1
esi = esi - 1
goto 11 @ 0x20df1

[edi].b = [esi].b
edi = edi + 1
esi = esi + 1
goto 11 @ 0x20df1

al, ah, eflags = __aaa(al, ah, eflags)
eax & 0xb937af37
al, ah, eflags = __aaa(al, ah, eflags)
temp0.d = pop
esp = esp + 0xcd37
<return> jump(temp0.d)

int32_t __convention("regparm") sub_20dfb(int32_t arg1, uint16_t arg2, int32_t arg3 @ ebp, int32_t arg4 @ esi, char* arg5 @ edi, long double arg6 @ st0, char* arg7, int32_t arg8, int32_t arg9, int32_t arg10, int32_t arg11, int32_t arg12)
al, ah, eflags = __aaa(al, ah, eflags)
temp0, x87status = __fnstenv_memmem28()
[edi].28 = temp0.28
temp3.t = st0
temp4.t = float.t([edi].w)
st0 = temp3.t f/ temp4.t
flag:c1 = unimplemented
__out_dx_al(dx, al, eflags)
al, ah, eflags = __aaa(al, ah, eflags)
al, ah, eflags = __aaa(al, ah, eflags)
flag:c = 1
al, ah, eflags = __aaa(al, ah, eflags)
push([edi].d)
eax = adc.d(eax, 0x24381c38, flag:c)
[eax + edi - 0x66].b - dl
[esi + 0x27390a38].b - ah
[edi].d - ebp
[esi + 0x39].d - eax
edx = pop
[ebp - 0x26c649c7].d - edx
edx - esp
temp5.d = [edi + 0x3a].d
flag:c = temp5.d u< edi
ch = 0x3a
edi = sbb.d(edi, [ebx {sub_0}].d, flag:c)
edi = pop
esi = pop
ebp = pop
esp = esp + 4
ebx = pop
edx = pop
ecx = pop
eax = pop
ebp - [ebx + 0x3b].d
temp0.d = ebx
ebx = eax
eax = temp0.d
ebx - [ecx - 0x2cc44ec5].d
edi - ebx
eax - [edx].d
al - 0x1f
al - -0x40
al - -0x29
al - -9
al - 5
eax - 0x3d453d1b
ecx = pop
flag:c = eax u< 0x3e623e0e
flag:s = eax - 0x3e623e0e s< 0
flag:o = add_overflow(eax, -0x3e623e0e)
if (flag:s == flag:o) then 51 @ 0x20e90 else 53 @ 0x20e52

al = adc.b(al, 0x3b, flag:c)
goto 68 @ 0x20e92

temp0.b = divs.dp.b(ax, [esi].b)
temp1.b = mods.dp.b(ax, [esi].b)
al = temp0.b
ah = temp1.b
[edi].d = [edi].d - edi
push(ecx)
al, ah, eflags = __aas(al, ah, eflags)
push(edi)
al, ah, eflags = __aas(al, ah, eflags)
al, ah, eflags = __aas(al, ah, eflags)
temp0.b = [edi].b
[edi].b = bh
bh = temp0.b
[esi].b - [edi].b
if (flag:d) then 99 else 102

edi = [ebx].d * 0x79
edx - [ebx + 0xc3c083b].d
al - 0x10
al - 0x14
al - 0x18
al - 0x1c
al - 0x20
al - 0x24
al - 0x28
al - 0x2c
al - 0x30
al - 0x34
al - 0x38
al - 0x3c
al - 0x40
al - 0x44
al - 0x48
al - 0x4c
al - 0x50
al - 0x54
al - 0x58
al - 0x5c
al - -4
al - 0x30
eax - 0x3d8f3d3b
temp0.d = esp
esp = eax
eax = temp0.d
cond:0 = eax == 0x3dd63da2
ecx = ecx - 1
if (cond:0 || ecx != 0) then 105 @ 0x20f11 else 111 @ 0x20ed4

esi = esi - 1
edi = edi - 1
goto 138 @ 0x20e5f

esi = esi + 1
edi = edi + 1
goto 138 @ 0x20e5f

al = al ^ 0xd0
eax = eax ^ 0x363e35e5
cond:1 = eax s>= 0
push(edi)
al, ah, eflags = __aaa(al, ah, eflags)
if (flag:d) then 140 else 143

bh = bh - [esi].b
bh - [esi].b
ecx = ecx + 1
di = [esi].w * -0x6a
[esi].b = [esi].b s>> cl
eip = __int1()
edi = edi + [edi].d
push(edx)
al, ah, eflags = __aas(al, ah, eflags)
push(0x3f)
[eax].b = [eax].b ^ al
[eax].b = [eax].b + ah
[eax].b = [eax].b + al
al, ah, eflags = __aaa(al, ah, eflags)
[esi - 0x1fcf3dd0].b = [esi - 0x1fcf3dd0].b ^ cl
bh = bh ^ dh
[-0xffffffff92316631].b = [-0xffffffff92316631].b ^ dl
[ebx + esi].d = [ebx + esi].d ^ edi
temp0.d = edi
edi = eax
eax = temp0.d
ecx = 0
ebp = ebp ^ ebx
edi = edi ^ edx
esp = esp ^ [edi].d
al = al ^ 0xad
goto 105 @ 0x20f11

al, ah, eflags = __aas(al, ah, eflags)
if (flag:d) then 146 else 149

[edi].d = eax
edi = edi - 4
goto 152 @ 0x20f1b

[edi].d = eax
edi = edi + 4
goto 152 @ 0x20f1b

[edi].d = eax
edi = edi - 4
goto 161 @ 0x20e61

[edi].d = eax
edi = edi + 4
goto 161 @ 0x20e61

al, ah, eflags = __aaa(al, ah, eflags)
temp0, x87status = __fnstenv_memmem28()
[edi].28 = temp0.28
temp2.d = [edi].d
temp0.d = divu.dp.d(edx:eax, temp2.d)
temp1.d = modu.dp.d(edx:eax, temp2.d)
eax = temp0.d
edx = temp1.d
if (cond:1) then 183 @ 0x20f5a else 194 @ 0x20f22

al, ah, eflags = __aas(al, ah, eflags)
eflags = __sti(eflags)
al, ah, eflags = __aas(al, ah, eflags)
[eax].b = [eax].b + ah
[eax].b = [eax].b + al
[eax].b = al
[eax].b = [eax].b + al
dh = dh + [eax].b
al = al | 0x30
dh = dh & [eax].b
esi = pop
[edi + 0x30].b = [edi + 0x30].b ^ ch
push(zx.d(ds))
[edi - 0x60cc3bce].d = [edi - 0x60cc3bce].d ^ ecx
al = al ^ 7
eax = eax ^ 0x3569355b
[0x35e93594].b = [0x35e93594].b ^ 0xdd
al, ah, eflags = __aaa(al, ah, eflags)
edx = edx - 1
[ecx].d - ecx
dl - [ebx + edi].b
goto 68 @ 0x20e92

flag:c = 1
ebx = ebx ^ esp
dh = dh ^ al
edi = edi ^ ebp
edx = edx ^ [edx].d
al = al ^ 0x32
al = al ^ 0x57
al = al ^ 0xb5
al = al ^ 0xbf
al = al ^ 0xce
goto 201 @ 0x20f6d

al = [0x2f3a0839].b
bl - [eax + 0x43aba3a].b
temp6.d = [ecx + 0x3b].d
flag:c = eax u< temp6.d
flag:z = eax == temp6.d
flag:o = add_overflow(eax, neg.d(temp6.d))
if (not(flag:o)) then 201 @ 0x20f6d else 203 @ 0x20f32

al = al ^ 0xdf
goto 204 @ 0x20f6f

if (not(flag:z) && not(flag:c)) then 204 @ 0x20f6f else 212 @ 0x20f34

al = al ^ 0xe5
al = al ^ 0xef
al = al ^ 0xf5
al = al ^ 0xff
al = al ^ 9
eax = eax ^ 0x35233513
eax = eax ^ 0x35423537
goto 219 @ 0x20f84

al = __in_al_dx(dx, eflags)
ecx - [esp + edi].d
al = al - 0x3d
edx = edx + 1
cond:2 = eax - 0x3ddc3d8c s>= 0
ecx = ecx - 1
if (ecx != 0) then 222 @ 0x20f7f else 224 @ 0x20f42

push(ecx)
eax = eax ^ 0x35733568
goto 225 @ 0x20f8a

eax = eax ^ 0x35423537
goto 219 @ 0x20f84

if (cond:2) then 230 @ 0x20f82 else 233 @ 0x20f44

edx:eax = sx.q(eax)
eax = eax ^ 0x360d35d6
ch = 0x36
[esi].b = [esi].b << cl
undefined

edx = edx + 1
eax = eax ^ 0x35683551
if (eax u>= 0) then 236 @ 0x20fbf else 225 @ 0x20f8a

[edi].b - -0x32
al, ah, eflags = __aas(al, ah, eflags)
trap(0xd)
{ Does not return }

al - -0x28
al - -0x1c
al - 0x14
eax - 0x3e083dfe
[esi].d = [esi].d & edi
temp7.d = ecx
ecx = ecx - 1
flag:z = temp7.d == 1
flag:o = add_overflow(temp7.d, -1)
push(ebp)
temp0, eflags = __arpl_memw_gpr16([esi].w, di)
[esi].w = temp0.w
if (not(flag:o)) then 249 @ 0x21013 else 254 @ 0x20fd4

push(zx.d(ss))
al, ah, eflags = __aaa(al, ah, eflags)
dh - [edi].b
esi = [edi].d * 0x392c37c7
goto 264 @ 0x2101e

temp0.d = [esi].d
[esi].d = edi
edi = temp0.d
temp0.d = ebx
ebx = eax
eax = temp0.d
edi, es = __les_gprz_memp([esi].6)
al = [ebx + al.d].b
ecx = ecx - 1
if (flag:z || ecx != 0) then 267 @ 0x2101c else 269 @ 0x20fde  {"5?Z?d?t?"}

[ecx].b & bh
eax - [edi].d
if (flag:d) then 273 else 275

al = al - 0x39
goto 264 @ 0x2101e

eax = eax ^ 0x643f5a3f
cond:3 = eax == 0
al, ah, eflags = __aas(al, ah, eflags)
if (cond:3) then 277 @ 0x21025 else 300 @ 0x20fe6

edi = edi - 4
goto 308 @ 0x21021

edi = edi + 4
goto 308 @ 0x21021

esp - [ebx + edi - 0x78].d
esi - [ecx - 0x1c331c4].d
al - -0x6a
eax - 0x3dfd3dd1
[esi].d = [esi].d | edi
ss = pop.w
temp8.d = eax
eax = eax & 0x703e4f3e
flag:c = 0
eax = [-0xffffffffd93ecd3e].d
__out_immb_oeax(0x3e, eax, eflags)
flag:c = flag:c ^ 1
temp9.b = bh
temp10.b = [edi].b
cond:4 = flag:c
bh = adc.b(temp9.b, temp10.b, cond:4)
flag:c = adc.b(temp9.b, temp10.b, cond:4) u< temp9.b || (cond:4 && adc.b(temp9.b, temp10.b, cond:4) == temp9.b)
eax = sbb.d(eax, 0x513f433f, flag:c)
al, ah, eflags = __aas(al, ah, eflags)
[edi].d - 0x3fca3f8c
[edi].b = [edi].b s>> cl
[edi].w = flagbit.w(flag:c0, 8) | flagbit.w(flag:c1, 9) | flagbit.w(flag:c2, 0xa) | flagbit.w(flag:c3, 0xe) | (top & 7) << 0xb
trap(0xd)
{ Does not return }

[eax].b = [eax].b + al
[eax].b = [eax].b + dl
[eax].b = [eax].b + bh
[eax].b = [eax].b + al
call(0x5a331727)
[edi + 0x2c32fe32].d = [edi + 0x2c32fe32].d ^ esp
ecx = ecx ^ [edx + 0x33].d
undefined

[edi].d - eax
ebx - [ecx].d
goto 277 @ 0x21025

int32_t __convention("regparm") sub_21001(int32_t arg1, int32_t arg2, int32_t arg3, int32_t arg4 @ esi, int32_t* arg5 @ edi) __noreturn
temp0.d = esi
temp1.d = [esp + esi + 0x350834c7].d
esi = esi ^ [esp + esi + 0x350834c7].d
flag:c = 0
eax = adc.d(eax, -0x52ca58cb, flag:c)
eax = eax ^ 0x36373631
push(zx.d(ss))
al, ah, eflags = __aaa(al, ah, eflags)
dh - [edi].b
esi = [edi].d * 0x392c37c7
[ecx].b & bh
eax - [edi].d
if (flag:d) then 13 else 15

edi = edi - 4
goto 17 @ 0x21021

edi = edi + 4
goto 17 @ 0x21021

[edi].d - eax
ebx - [ecx].d
esp - [ebx + edi - 0x78].d
esi - [ecx - 0x1c331c4].d
al - -0x6a
eax - 0x3dfd3dd1
[esi].d = [esi].d | edi
ss = pop.w
temp2.d = eax
eax = eax & 0x703e4f3e
flag:c = 0
eax = [-0xffffffffd93ecd3e].d
__out_immb_oeax(0x3e, eax, eflags)
flag:c = flag:c ^ 1
temp3.b = bh
temp4.b = [edi].b
cond:0 = flag:c
bh = adc.b(temp3.b, temp4.b, cond:0)
flag:c = adc.b(temp3.b, temp4.b, cond:0) u< temp3.b || (cond:0 && adc.b(temp3.b, temp4.b, cond:0) == temp3.b)
eax = sbb.d(eax, 0x513f433f, flag:c)
al, ah, eflags = __aas(al, ah, eflags)
[edi].d - 0x3fca3f8c
[edi].b = [edi].b s>> cl
[edi].w = flagbit.w(flag:c0, 8) | flagbit.w(flag:c1, 9) | flagbit.w(flag:c2, 0xa) | flagbit.w(flag:c3, 0xe) | (top & 7) << 0xb
trap(0xd)
{ Does not return }

