int32_t sub_5() __pure
goto 1 @ 0x80

eax = 0x1000653c
<return> jump(pop)

int32_t __stdcall j_sub_1d00(void* arg1, int32_t arg2, int32_t arg3, int32_t arg4, int32_t arg5, int32_t arg6, int32_t arg7, int32_t arg8, char arg9, int32_t arg10, char arg11)
<return> tailcall(sub_1d00)

int32_t __stdcall j_sub_1b30(void* arg1, int32_t arg2, int32_t arg3, int32_t arg4, int32_t arg5, int32_t arg6, int32_t arg7, char arg8, int32_t arg9, char arg10)
<return> tailcall(sub_1b30)

int32_t sub_14() __pure
goto 1 @ 0x90

eax = 0x10006558
<return> jump(pop)

void j_sub_d20(int32_t arg1 @ esi, int32_t arg2 @ edi, int32_t* arg3)
<return> tailcall(sub_d20)

int32_t j_sub_1360(void* arg1)
<return> tailcall(sub_1360)

int32_t j_sub_150()
<return> tailcall(sub_150)

int32_t j_sub_920()
<return> tailcall(sub_920)

int32_t j_sub_e40(void* arg1)
<return> tailcall(sub_e40)

int32_t j_sub_930()
<return> tailcall(sub_930)

int32_t j_sub_160()
<return> tailcall(sub_160)

long double sub_a0(double* arg1 @ esi, double* arg2 @ edi)
push(ebp)
ebp = esp {__saved_ebp}
esp = esp & 0xfffffff8
esp = esp - 0x18
goto 5 @ 0xb2

call(sub_2674)
[esp {var_20_1}].d = eax
x87.push{x87c1z}(float.t([esp {var_20_1}].d))
st0 = st0 f/ fconvert.t([0x100065a8].q)
st0 = st0 f+ st0
st0 = st0 f- fconvert.t([0x10006598].q)
[esp + 8 {var_18_1}].q = fconvert.d(x87.pop)
call(sub_2674)
[esp {var_20}].d = eax
x87.push{x87c1z}(float.t([esp {var_20}].d))
st0 = st0 f/ fconvert.t([0x100065a8].q)
st0 = st0 f+ st0
x87.push{x87c1z}(float.t(1))
st1 = st1 f- st0
temp0.t = st0
st0 = st1
st1 = temp0.t
[esp + 0x10 {var_10_1}].q = fconvert.d(st0)
st0 = st0 f* st0
x87.push(fconvert.t([esp + 8 {var_18_1}].q))
st0 = st0 f* st0
st1 = st1 f+ st0
__free_slot(st0)
top = top + 1
[esp {var_20}].q = fconvert.d(st0)
st0 f- st1
flag:c0 = st0 f< st1
flag:c1 = 0
flag:c2 = is_unordered.t(st0, st1)
flag:c3 = st0 f== st1
ax = flagbit.w(flag:c0, 8) | flagbit.w(flag:c1, 9) | flagbit.w(flag:c2, 0xa) | flagbit.w(flag:c3, 0xe) | (top & 7) << 0xb
st1 = x87.pop{x87c1z}
if ((ah & 1) == 0) then 38 @ 0xb0 else 40 @ 0x104

st0 = x87.pop{x87c1z}
goto 5 @ 0xb2

x87.push{x87c1z}(float.t(0))
x87.push(st0)
st0 f- st2
flag:c0 = st0 f< st2
flag:c1 = 0
flag:c2 = is_unordered.t(st0, st2)
flag:c3 = st0 f== st2
__free_slot(st0)
top = top + 1
ax = flagbit.w(flag:c0, 8) | flagbit.w(flag:c1, 9) | flagbit.w(flag:c2, 0xa) | flagbit.w(flag:c3, 0xe) | (top & 7) << 0xb
flag:p = unimplemented
if (flag:p) then 52 @ 0x11b else 65 @ 0x111

st0 = x87.pop{x87c1z}
call(sub_2796)
st0 = st0 f* fconvert.t([0x10006578].q)
st0 = st0 f/ fconvert.t([esp {var_20}].q)
call(sub_2790)
x87.push(fconvert.t([esp + 8 {var_18_1}].q))
st0 = st0 f* st1
[edi].q = fconvert.d(x87.pop)
st0 = st0 f* fconvert.t([esp + 0x10 {var_10_1}].q)
[esi].q = fconvert.d(x87.pop)
esp = ebp
ebp = pop
<return> jump(pop)

st1 = x87.pop{x87c1z}
[edi].q = fconvert.d(st0)
[esi].q = fconvert.d(x87.pop)
esp = ebp
ebp = pop
<return> jump(pop)

int32_t sub_150() __pure
eax = 0x1000655c
<return> jump(pop)

int32_t sub_160() __pure
eax = 0x10006560
<return> jump(pop)

int32_t __convention("regparm") sub_170(int32_t arg1, int32_t arg2, int32_t arg3, int32_t arg4)
esp = esp - 0x94
eax = [0x10008000].d
eax = eax ^ esp
[esp + 0x90 {var_4}].d = eax
push(ebp)
ebp = [esp + 0x9c {arg4}].d
push(esi)
eax = esp + 0x24 {s}
cond:0 = (al & 3) != 0
push(edi)
edi = ecx
[esp + 0x24 {var_7c}].d = ebp
if (cond:0) then 13 @ 0x1d4 else 20 @ 0x19c

push(zx.d(0x34))
ecx = esp + 0x2c {s}
push(zx.d(0))
push(ecx)
call(sub_27ac)
esp = esp + 0xc
goto 35 @ 0x1e5

eax = 0
[esp + 0x28 {s}].d = eax
[esp + 0x2c {var_74}].d = eax
[esp + 0x30 {var_70}].d = eax
[esp + 0x34 {var_6c}].d = eax
[esp + 0x38 {var_68}].d = eax
[esp + 0x3c].d = eax
[esp + 0x40].d = eax
[esp + 0x44 {var_5c}].d = eax
[esp + 0x48 {var_58}].d = eax
[esp + 0x4c {var_54}].d = eax
[esp + 0x50 {var_50}].d = eax
[esp + 0x54].d = eax
[esp + 0x58 {var_48}].d = eax
goto 35 @ 0x1e5

push(0x220)
edx = esp + 0x2c {s}
push(edx)
push(zx.d(0x40))
push(0x100066d4)
[esp + 0x4c {var_64}].d = 0x40
[esp + 0x50 {var_60}].d = 0x44
[esp + 0x64 {var_4c}].d = ebp
call(sub_26e0)
esp = esp + 0x10
[esp + 0x10 {var_90}].d = eax
call(sub_26da)
esi = eax
if (esi s>= 0) then 49 @ 0x245 else 59 @ 0x221

push(zx.d(0))
push(zx.d(1))
push(edi)
call(sub_26c8)
ecx = [0x100093d4].d
ecx = [ecx].d
esp = esp + 0xc
cond:1 = eax != 5
[esp + 0x14 {var_8c}].d = ecx
if (cond:1) then 69 @ 0x428 else 75 @ 0x269

push(0x100066b8)
push(0x2dd)
push(0x10006690)
call(sub_26d4)
push(esi)
push(0x10006658)
push(zx.d(0x14))
call(sub_26ce)
esp = esp + 0x18
goto 49 @ 0x245

call(sub_267a)
cond:2 = eax == 2
edi = pop
esi = pop
ebp = pop
if (cond:2) then 76 @ 0x458 else 82 @ 0x435

if (ecx s<= 0) then 69 @ 0x428 else 91 @ 0x26f

ecx = [esp + 0x90 {var_4}].d
eax = [esp + 4 {var_90}].d
ecx = ecx ^ esp
call(sub_279c)
esp = esp + 0x94
<return> jump(pop)

push(0x100066b8)
push(0x30f)
push(0x10006690)
call(sub_26d4)
push(0x100065b4)
push(zx.d(0x14))
call(sub_26ce)
esp = esp + 0x14
goto 76 @ 0x458

edx = [0x100093d8].d
esi = [edx].d
edi = [esi + 0xc].d
cond:3 = [edi].d == 1
[esp + 0x20 {var_80_1}].d = esi
[esp + 0x18 {var_88_1}].d = edi
if (cond:3) then 98 @ 0x2ca else 101 @ 0x287

push(ebx)
ebx = 0
if ([esp + 0x18 {var_8c}].d s<= ebx) then 109 @ 0x427 else 111 @ 0x2d7

push(zx.d(0))
push(0x100066b8)
push(0x2f2)
push(0x10006690)
push(zx.d(0x14))
call(sub_26b6)
esp = esp + 0x14
if (al == 0) then 98 @ 0x2ca else 115 @ 0x2a6

ebx = pop
goto 69 @ 0x428

eax = esp + 0x60 {s_1}
eax = eax & 3
[esp + 0x20 {var_84_1}].d = eax
goto 126 @ 0x2f0

push(0x10006608)
call(sub_26b0)
esp = esp + 4
push(eax)
push(0x1006084)
call(sub_26aa)
esp = esp + 4
push(eax)
call(sub_26a4)
esp = esp + 8
goto 98 @ 0x2ca

eax = [esi + 0x10].d
eax = [eax + (ebx << 2)].d
push(zx.d(1))
push(edi)
push(eax)
call(sub_269e)
push(ebp)
edi = eax
call(sub_2698)
ecx = [0x100093f4].d
edx = [ecx].d
push(zx.d(8))
push(edx)
ebp = eax
call(sub_268c)
esi = eax
esp = esp + 0x18
cond:4 = [esp + 0x20 {var_84_1}].d != 0
[esi].d = edi
[esi + 4].d = ebx
if (cond:4) then 147 @ 0x386 else 154 @ 0x32a

push(zx.d(0x40))
eax = esp + 0x64 {s_1}
push(zx.d(0))
push(eax)
call(sub_27ac)
esp = esp + 0xc
goto 172 @ 0x397

eax = 0
[esp + 0x60 {s_1}].d = eax
[esp + 0x64 {var_40}].d = eax
[esp + 0x68 {var_3c}].d = eax
[esp + 0x6c {var_38}].d = eax
[esp + 0x70 {var_34}].d = eax
[esp + 0x74 {var_30}].d = eax
[esp + 0x78 {var_2c}].d = eax
[esp + 0x7c {var_28}].d = eax
[esp + 0x80 {var_24}].d = eax
[esp + 0x84 {var_20}].d = eax
[esp + 0x88 {var_1c}].d = eax
[esp + 0x8c {var_18}].d = eax
[esp + 0x90 {var_14}].d = eax
[esp + 0x94 {var_10}].d = eax
[esp + 0x98 {var_c}].d = eax
[esp + 0x9c {var_8}].d = eax
goto 172 @ 0x397

push(edi)
push(0x10006604)
ecx = esp + 0x68 {s_1}
push(zx.d(0x3f))
push(ecx)
call(sub_2686)
ecx = [esp + 0x24 {var_90}].d
edx = esp + 0x23 {var_91}
push(edx)
push(zx.d(1))
eax = esp + 0x78 {s_1}
push(eax)
push(ecx)
call(sub_2680)
esp = esp + 0x20
cond:5 = [esp + 0x13 {var_91}].b == 0
edi = eax
if (cond:5) then 190 @ 0x40e else 196 @ 0x3cb

push(ebp)
[edi + 0x40].d = esi
call(sub_2698)
ebx = ebx + 1
esp = esp + 4
if (ebx s< [esp + 0x18 {var_8c}].d) then 204 @ 0x2e4 else 109 @ 0x427

push(zx.d(0))
push(0x100066b8)
push(0x307)
push(0x10006690)
push(zx.d(0x14))
call(sub_26b6)
esp = esp + 0x14
if (al == 0) then 190 @ 0x40e else 208 @ 0x3ea

esi = [esp + 0x24 {var_80_1}].d
edi = [esp + 0x1c {var_88_1}].d
ebp = [esp + 0x28 {var_7c}].d
goto 126 @ 0x2f0

push(0x100065e8)
call(sub_26b0)
esp = esp + 4
push(eax)
push(0x47084)
call(sub_26aa)
esp = esp + 4
push(eax)
call(sub_26a4)
esp = esp + 8
goto 190 @ 0x40e

int32_t __convention("regparm") sub_480(int32_t arg1, int32_t* arg2, int32_t arg3, int32_t arg4, int32_t arg5)
esp = esp - 0x7c
eax = [0x10008000].d
eax = eax ^ esp
[esp + 0x78 {var_4}].d = eax
eax = [esp + 0x80 {arg4}].d
push(ebx)
push(ebp)
push(esi)
push(edi)
push(eax)
edi = ecx
[esp + 0x44 {var_4c}].d = eax
ebx = edx
call(sub_2716)
push(ebx)
ebp = eax
call(sub_2710)
edx = [esp + 0x9c {arg5}].d
[esp + 0x3c {var_58}].d = eax
eax = [0x100093a8].d
ecx = [eax].d
push(ecx)
push(zx.d(0))
push(edx)
call(sub_2704)
esp = esp + 0x14
[esp + 0x28 {var_64}].d = eax
call(sub_26da)
esi = eax
if (esi s>= 0) then 30 @ 0x500 else 40 @ 0x4dc

push(zx.d(0))
push(zx.d(1))
push(edi)
call(sub_26c8)
ecx = [0x100093d4].d
ecx = [ecx].d
esp = esp + 0xc
cond:0 = eax != 5
[esp + 0x30 {var_5c}].d = ecx
if (cond:0) then 50 @ 0x8c9 else 52 @ 0x524

push(0x10006848)
push(0x32c)
push(0x10006690)
call(sub_26d4)
push(esi)
push(0x1000680c)
push(zx.d(0x14))
call(sub_26ce)
esp = esp + 0x18
goto 30 @ 0x500

esi = [esp + 0x28 {var_64}].d
goto 53 @ 0x8cd

if (ecx s<= 0) then 50 @ 0x8c9 else 55 @ 0x52a

call(sub_267a)
if (eax == 2) then 66 @ 0x8fa else 76 @ 0x8d7

cond:1 = ebp != 0
edx = [0x100093d8].d
edi = [edx].d
eax = [edi + 0xc].d
esi = [eax].d
[esp + 0x44 {var_48_1}].d = edi
[esp + 0x18 {var_74_1}].d = eax
[esp + 0x1c {var_70_1}].d = esi
[esp + 0x14 {var_78_1}].d = 0
[esp + 0x13 {var_79_1}].b = 1
if (cond:1) then 85 @ 0x599 else 86 @ 0x554  {"UhHh"}

ecx = [esp + 0x88 {var_4}].d
edi = pop
eax = esi
esi = pop
ebp = pop
ebx = pop
ecx = ecx ^ esp
call(sub_279c)
esp = esp + 0x7c
<return> jump(pop)

push(0x10006848)
push(0x3ae)
push(0x10006690)
call(sub_26d4)
push(0x100066e4)
push(zx.d(0x14))
call(sub_26ce)
esp = esp + 0x14
goto 66 @ 0x8fa

if (esi s>= 3) then 94 @ 0x5ec else 98 @ 0x59b

push(ebp)
push(0x10006848)
push(0x345)
push(0x10006690)
push(zx.d(0x14))
call(sub_26b6)
esp = esp + 0x14
if (al == 0) then 85 @ 0x599 else 106 @ 0x572

ebp = esi + ebp - 2
cond:2 = [ebx].d == ebp
[esp + 0x2c {var_60_1}].d = ebp
if (cond:2) then 117 @ 0x64d else 132 @ 0x5f8

push(zx.d(0))
push(0x10006848)
push(0x35a)
push(0x10006690)
push(zx.d(0x14))
call(sub_26b6)
esp = esp + 0x14
if (al == 0) then 94 @ 0x5ec else 140 @ 0x5ba

push(0x10006608)
call(sub_26b0)
esp = esp + 4
push(eax)
push(0x1006084)
call(sub_26aa)
esp = esp + 4
push(eax)
call(sub_26a4)
esp = esp + 8
goto 85 @ 0x599

ecx = [0x100093f4].d
edx = [ecx].d
esi = ebp << 2
push(esi)
push(edx)
call(sub_268c)
push(esi)
ebp = eax
push(zx.d(0))
push(ebp)
call(sub_27ac)
esp = esp + 0x14
cond:3 = [esp + 0x30 {var_5c}].d s<= 0
[esp + 0x20 {var_6c_1}].d = 0
if (cond:3) then 155 @ 0x8ae else 165 @ 0x684

push(zx.d(0))
push(0x10006848)
push(0x365)
push(0x10006690)
push(zx.d(0x14))
call(sub_26b6)
esp = esp + 0x14
if (al == 0) then 117 @ 0x64d else 169 @ 0x617

push(0x100067b8)
call(sub_26fe)
esp = esp + 4
push(eax)
push(0x1000678c)
call(sub_26b0)
esp = esp + 4
push(eax)
push(0x3080082)
call(sub_26aa)
esp = esp + 4
push(eax)
call(sub_26a4)
esp = esp + 0xc
goto 94 @ 0x5ec

edx = [esp + 0x34 {var_58}].d
push(ebp)
push(edx)
call(sub_26f8)
esi = [esp + 0x30 {var_64}].d
push(eax)
push(esi)
call(sub_26f2)
esp = esp + 0x10
goto 53 @ 0x8cd

eax = [esp + 0x1c {var_70_1}].d
eax = eax - 1
[esp + 0x3c {var_50_1}].d = eax
goto 187 @ 0x695

eax = [ebx].d
push(ebp)
push(eax)
push(0x10006738)
call(sub_26fe)
esp = esp + 0xc
push(eax)
push(0x1000671c)
call(sub_26b0)
esp = esp + 4
push(eax)
push(0x1006084)
call(sub_26aa)
esp = esp + 4
push(eax)
call(sub_26a4)
esp = esp + 0xc
goto 117 @ 0x64d

ecx = [edi + 0x10].d
edx = [esp + 0x20 {var_6c_1}].d
eax = [esp + 0x18 {var_74_1}].d
esi = [ecx + (edx << 2)].d
push(zx.d(1))
push(eax)
push(esi)
[esp + 0x30 {var_68_1}].d = esi
call(sub_269e)
esp = esp + 0xc
cond:4 = [esp + 0x13 {var_79_1}].b != 0
edi = eax
[esp + 0x38 {var_54_1}].d = edi
if (cond:4) then 201 @ 0x748 else 207 @ 0x6c4

ebx = [esp + 0x1c {var_70_1}].d
esi = 1
ebx = ebx - 2
cond:5 = ebx s<= esi
[ebp].d = edi
if (cond:5) then 209 @ 0x784 else 213 @ 0x75b

ebx = [esp + 0x14 {var_78_1}].d
if (ebx != 0) then 214 @ 0x6d2 else 215 @ 0x6cc

esi = [esp + 0x24 {var_68_1}].d
ebx = [esp + 0x14 {var_78_1}].d
[esp + 0x13 {var_79_1}].b = 0
goto 217 @ 0x791

goto 226 @ 0x760

if (edi == 0) then 237 @ 0x705 else 248 @ 0x6d4

cond:6 = edi == 0
goto 251 @ 0x6ff

edx = [esp + 0x3c {var_50_1}].d
eax = [esp + 0x18 {var_74_1}].d
push(edx)
push(eax)
push(esi)
call(sub_269e)
esi = eax
esp = esp + 0xc
if (esi == 0) then 252 @ 0x86b else 253 @ 0x7ae

eax = [esp + 0x18 {var_74_1}].d
ecx = [esp + 0x24 {var_68_1}].d
edi = esi + 1
push(edi)
push(eax)
push(ecx)
call(sub_269e)
[ebp + (esi << 2)].d = eax
esi = edi
esp = esp + 0xc
if (esi s< ebx) then 226 @ 0x760 else 255 @ 0x780

ecx = [esp + 0x34 {var_58}].d
push(ebp)
push(ecx)
call(sub_26f8)
edx = [esp + 0x30 {var_64}].d
push(eax)
push(edx)
call(sub_26f2)
esi = 0
esp = esp + 0x10
if ([esp + 0x2c {var_60_1}].d s<= esi) then 201 @ 0x748 else 257 @ 0x726

ecx = edi
eax = ebx
goto 259 @ 0x6d8

if (cond:6) then 217 @ 0x791 else 237 @ 0x705

if (ebx == 0) then 264 @ 0x878 else 265 @ 0x86d

ecx = esp + 0x48 {s}
if ((cl & 3) != 0) then 269 @ 0x801 else 276 @ 0x7b7

edi = [esp + 0x38 {var_54_1}].d
goto 209 @ 0x784

eax = [ebp + (esi << 2)].d
if (eax == 0) then 294 @ 0x73f else 296 @ 0x72e

dl = [eax].b
temp0.b = [ecx].b
flag:c = dl u< temp0.b
flag:z = dl == temp0.b
if (not(flag:z)) then 301 @ 0x6f8 else 308 @ 0x6e0

if (edi == 0) then 309 @ 0x891 else 311 @ 0x87a

push(ebx)
call(sub_26ec)
esp = esp + 4
goto 264 @ 0x878

push(zx.d(0x40))
edx = esp + 0x4c {s}
push(zx.d(0))
push(edx)
call(sub_27ac)
esp = esp + 0xc
goto 319 @ 0x812

eax = 0
[esp + 0x48 {s}].d = eax
[esp + 0x4c {var_40}].d = eax
[esp + 0x50 {var_3c}].d = eax
[esp + 0x54 {var_38}].d = eax
[esp + 0x58 {var_34}].d = eax
[esp + 0x5c {var_30}].d = eax
[esp + 0x60 {var_2c}].d = eax
[esp + 0x64 {var_28}].d = eax
[esp + 0x68 {var_24}].d = eax
[esp + 0x6c {var_20}].d = eax
[esp + 0x70 {var_1c}].d = eax
[esp + 0x74 {var_18}].d = eax
[esp + 0x78 {var_14}].d = eax
[esp + 0x7c {var_10}].d = eax
[esp + 0x80 {var_c}].d = eax
[esp + 0x84 {var_8}].d = eax
goto 319 @ 0x812

esi = esi + 1
if (esi s< [esp + 0x2c {var_60_1}].d) then 257 @ 0x726 else 201 @ 0x748

push(eax)
call(sub_26ec)
esp = esp + 4
[ebp + (esi << 2)].d = 0
goto 294 @ 0x73f

temp1.d = eax
temp2.d = eax
cond:8 = flag:c
eax = sbb.d(temp1.d, temp2.d, cond:8)
flag:c = unimplemented
eax = sbb.d(eax, -1, flag:c)
goto 334 @ 0x6fd

if (dl == 0) then 336 @ 0x6f4 else 338 @ 0x6e2

[esp + 0x14 {var_78_1}].d = 0
goto 343 @ 0x899

eax = [0x100093f4].d
ecx = [eax].d
push(edi)
push(ecx)
call(sub_26e6)
esp = esp + 8
[esp + 0x14 {var_78_1}].d = eax
goto 343 @ 0x899

push(esi)
push(0x10006604)
eax = esp + 0x50 {s}
push(zx.d(0x3f))
push(eax)
call(sub_2686)
edx = [esp + 0x50 {var_4c}].d
push(zx.d(0))
push(zx.d(0))
ecx = esp + 0x60 {s}
push(ecx)
push(edx)
call(sub_2680)
esp = esp + 0x20
if (eax == 0) then 252 @ 0x86b else 348 @ 0x83e

cond:6 = eax == 0
goto 251 @ 0x6ff

eax = 0
goto 334 @ 0x6fd

dl = [eax + 1].b
temp3.b = [ecx + 1].b
flag:c = dl u< temp3.b
flag:z = dl == temp3.b
if (not(flag:z)) then 301 @ 0x6f8 else 350 @ 0x6ea

eax = [esp + 0x20 {var_6c_1}].d
eax = eax + 1
cond:7 = eax s< [esp + 0x30 {var_5c}].d
[esp + 0x20 {var_6c_1}].d = eax
if (cond:7) then 353 @ 0x691 else 155 @ 0x8ae

esi = [eax + 0x40].d
if (esi == 0) then 252 @ 0x86b else 355 @ 0x845

eax = eax + 2
ecx = ecx + 2
if (dl != 0) then 259 @ 0x6d8 else 336 @ 0x6f4

edi = [esp + 0x44 {var_48_1}].d
goto 187 @ 0x695

ebx = [esp + 0x1c {var_70_1}].d
eax = [esp + 0x18 {var_74_1}].d
ecx = [esp + 0x24 {var_68_1}].d
push(ebx)
push(eax)
push(ecx)
call(sub_269e)
edx = [esi + 4].d
esp = esp + 0xc
edx = edx + ebx
ebx = [esp + 0x14 {var_78_1}].d
[ebp + (edx << 2) - 8].d = eax
goto 252 @ 0x86b

int32_t sub_920() __pure
eax = 0x10006564
<return> jump(pop)

int32_t sub_930() __pure
eax = 0x10006568
<return> jump(pop)

void* sub_940(int32_t* arg1 @ edi, char arg2)
eax = 0
if ([esp + 4 {arg2}].b == al) then 2 @ 0x94f else 3 @ 0x948

if (bl == 0) then 5 @ 0x966 else 7 @ 0x951

eax = 1
goto 2 @ 0x94f

eax = eax + 3
if ([edi].d == eax) then 9 @ 0x9be else 14 @ 0x96d

eax = eax + 4
if ([edi].d == eax) then 9 @ 0x9be else 18 @ 0x958

eax = [edi + 4].d
ecx = [eax + 4].d
edx = [eax].d
eax = [edx + 0x44].d
if (eax == [ecx + 0x44].d) then 22 @ 0xa1f else 25 @ 0x9ce

push(zx.d(0))
push(0x100069fc)
push(0x5ac)
goto 33 @ 0x979

push(zx.d(0))
push(0x100069fc)
push(0x5a3)
goto 33 @ 0x979

ecx = [edi + 4].d
edx = [ecx + 8].d
if ([edx + 0x44].d == 0x17) then 38 @ 0xa86 else 39 @ 0xa2b

push(zx.d(0))
push(0x100069fc)
push(0x5b4)
push(0x10006690)
push(zx.d(0x14))
call(sub_26b6)
esp = esp + 0x14
if (al == 0) then 22 @ 0xa1f else 47 @ 0x9ed

push(0x10006690)
push(zx.d(0x14))
call(sub_26b6)
esp = esp + 0x14
if (al == 0) then 9 @ 0x9be else 62 @ 0x98c

if (bl == 0) then 77 @ 0xb35 else 78 @ 0xa8c

push(zx.d(0))
push(0x100069fc)
push(0x5bc)
push(0x10006690)
push(zx.d(0x14))
call(sub_26b6)
esp = esp + 0x14
if (al == 0) then 38 @ 0xa86 else 81 @ 0xa4a

push(0x10006980)
call(sub_26fe)
esp = esp + 4
push(eax)
push(0x1000671c)
call(sub_26b0)
esp = esp + 4
push(eax)
push(0x1006084)
call(sub_26aa)
esp = esp + 4
push(eax)
call(sub_26a4)
esp = esp + 0xc
goto 22 @ 0xa1f

push(0x100069b4)
call(sub_26fe)
esp = esp + 4
push(eax)
push(0x1000671c)
call(sub_26b0)
esp = esp + 4
push(eax)
push(0x1006084)
call(sub_26aa)
esp = esp + 4
push(eax)
call(sub_26a4)
esp = esp + 0xc
goto 9 @ 0x9be

if ([esp + 4 {arg2}].b == 0) then 99 @ 0xb6e else 100 @ 0xb37

eax = [edi + 4].d
ecx = [eax + 0xc].d
if ([ecx + 0x44].d == 0x19) then 103 @ 0xaf6 else 104 @ 0xa98

push(zx.d(0x17))
call(sub_271c)
push(eax)
push(0x1000695c)
call(sub_26fe)
esp = esp + 0xc
push(eax)
push(0x1000671c)
call(sub_26b0)
esp = esp + 4
push(eax)
push(0x1006084)
call(sub_26aa)
esp = esp + 4
push(eax)
call(sub_26a4)
esp = esp + 0xc
goto 38 @ 0xa86

<return> jump(pop)

ecx = [edi + 4].d
edx = [ecx + 0xc].d
if ([edx + 0x44].d == 0x17) then 99 @ 0xb6e else 112 @ 0xb43

if ([esp + 4 {arg2}].b == 0) then 99 @ 0xb6e else 124 @ 0xaf8

push(zx.d(0))
push(0x100069fc)
push(0x5c4)
push(0x10006690)
push(zx.d(0x14))
call(sub_26b6)
esp = esp + 0x14
if (al == 0) then 103 @ 0xaf6 else 127 @ 0xab7

push(0x100069fc)
push(0x5cd)
push(0x10006690)
call(sub_26d4)
push(zx.d(0x17))
call(sub_271c)
push(eax)
push(0x10006868)
push(zx.d(0x14))
call(sub_26ce)
esp = esp + 0x1c
goto 99 @ 0xb6e

edx = [edi + 4].d
eax = [edx + 0x10].d
if ([eax + 0x44].d == 0x17) then 99 @ 0xb6e else 145 @ 0xb04

push(zx.d(0x19))
call(sub_271c)
push(eax)
push(0x10006934)
call(sub_26fe)
esp = esp + 0xc
push(eax)
push(0x1000671c)
call(sub_26b0)
esp = esp + 4
push(eax)
push(0x1006084)
call(sub_26aa)
esp = esp + 4
push(eax)
call(sub_26a4)
esp = esp + 0xc
goto 103 @ 0xaf6

push(0x100069fc)
push(0x5c8)
push(0x10006690)
call(sub_26d4)
push(zx.d(0x17))
call(sub_271c)
push(eax)
push(0x100068d0)
push(zx.d(0x14))
call(sub_26ce)
esp = esp + 0x1c
<return> jump(pop)

int32_t sub_b70(void* arg1 @ esi, void* arg2 @ edi)
eax = [edi + 4].d
ecx = [eax].d
edx = [esi + 4].d
eax = [edx].d
ecx = [ecx + 0x44].d
if (ecx == [eax + 0x44].d) then 6 @ 0xbd3 else 12 @ 0xb82

edx = [edi + 4].d
eax = [edx + 4].d
ecx = [esi + 4].d
edx = [ecx + 4].d
eax = [eax + 0x44].d
if (eax == [edx + 0x44].d) then 20 @ 0xc38 else 22 @ 0xbe7

push(zx.d(0))
push(0x10006ad0)
push(0x5e4)
push(0x10006690)
push(zx.d(0x14))
call(sub_26b6)
esp = esp + 0x14
if (al == 0) then 6 @ 0xbd3 else 30 @ 0xba1

al = 1
<return> jump(pop)

push(zx.d(0))
push(0x10006ad0)
push(0x5ee)
push(0x10006690)
push(zx.d(0x14))
call(sub_26b6)
esp = esp + 0x14
if (al == 0) then 20 @ 0xc38 else 45 @ 0xc06

push(0x10006a80)
call(sub_26fe)
esp = esp + 4
push(eax)
push(0x1000671c)
call(sub_26b0)
esp = esp + 4
push(eax)
push(0x1006084)
call(sub_26aa)
esp = esp + 4
push(eax)
call(sub_26a4)
esp = esp + 0xc
goto 6 @ 0xbd3

push(0x10006a20)
call(sub_26fe)
esp = esp + 4
push(eax)
push(0x1000671c)
call(sub_26b0)
esp = esp + 4
push(eax)
push(0x1006084)
call(sub_26aa)
esp = esp + 4
push(eax)
call(sub_26a4)
esp = esp + 0xc
goto 20 @ 0xc38

int32_t* __convention("regparm") sub_c40(int32_t* arg1, int32_t arg2, int32_t* arg3)
push(esi)
esi = ecx
cond:0 = [esi].d s< 2
push(edi)
edi = eax
if (cond:0) then 6 @ 0xceb else 10 @ 0xc52

edi = pop
al = 0
esi = pop
<return> jump(pop)

if ([edi].d s< 3) then 6 @ 0xceb else 11 @ 0xc58

eax = [esi + 4].d
ecx = [eax].d
edx = [edi + 4].d
eax = [edx].d
ecx = [ecx + 0x44].d
if (ecx == [eax + 0x44].d) then 17 @ 0xcbb else 22 @ 0xc6a

edx = [edi + 4].d
eax = [edx + 8].d
edx = [esi].d
ecx = 1
if (edx s<= ecx) then 30 @ 0xce6 else 34 @ 0xccc

push(zx.d(0))
push(0x10006b34)
push(0x60c)
push(0x10006690)
push(zx.d(0x14))
call(sub_26b6)
esp = esp + 0x14
if (al == 0) then 17 @ 0xcbb else 38 @ 0xc89

edi = pop
al = 1
esi = pop
<return> jump(pop)

edi = [eax + 0x44].d
eax = [esi + 4].d
eax = eax + 4
goto 53 @ 0xcd5

push(0x10006af0)
call(sub_26fe)
esp = esp + 4
push(eax)
push(0x1000671c)
call(sub_26b0)
esp = esp + 4
push(eax)
push(0x1006084)
call(sub_26aa)
esp = esp + 4
push(eax)
call(sub_26a4)
esp = esp + 0xc
goto 17 @ 0xcbb

esi = [eax].d
if ([esi + 0x44].d != edi) then 6 @ 0xceb else 55 @ 0xcdc

ecx = ecx + 1
eax = eax + 4
if (ecx s< edx) then 53 @ 0xcd5 else 30 @ 0xce6

int32_t __convention("regparm") sub_cf0(int32_t arg1)
push(eax)
call(sub_273a)
push(eax)
push(0x10003734)
call(sub_272e)
push(eax)
call(sub_2728)
push(eax)
call(sub_2722)
esp = esp + 0x14
<return> jump(pop)

void sub_d20(int32_t arg1 @ esi, int32_t arg2 @ edi, int32_t* arg3)
push(ebp)
ebp = esp
esp = esp & 0xffffffc0
esp = esp - 0x34
push(ebx)
ebx = [ebp + 8 {arg3}].d
eax = [ebx].d
cond:0 = [eax + 0x10].d != 0
push(esi)
push(edi)
if (cond:0) then 11 @ 0xd83 else 24 @ 0xd37

push(ebx)
call(sub_274c), esp += 0x40
ecx = [eax + 0xc].d
x87.push(fconvert.t([ecx].q))
edx = [eax].d
[esp + 0x34].q = fconvert.d(x87.pop)
esp = esp + 4
cond:1 = edx s>= [eax + 4].d
x87.push(fconvert.t([ecx + 8].q))
[esp + 0x28].q = fconvert.d(x87.pop)
[esp + 0x1c].d = eax
[esp + 0x18].d = ecx
if (cond:1) then 52 @ 0xe10 else 66 @ 0xdaf

push(ebx)
call(sub_2752)
esi = eax
ecx = [esi + 0x14].d
push(ecx)
call(sub_2698)
edx = [ebx + 0x10].d
[esi + 4].d = edx
edi = eax
eax = [0x100093f4].d
ecx = [eax].d
push(zx.d(0x20))
push(ecx)
call(sub_268c)
edx = [ebx + 0x14].d
x87.push(fconvert.t([edx].q))
push(edi)
[eax].q = fconvert.d(x87.pop)
ecx = [ebx + 0x18].d
x87.push(fconvert.t([ecx].q))
[eax + 0x18].b = 0
[eax + 8].q = fconvert.d(x87.pop)
x87.push{x87c1z}(float.t(0))
[eax + 0x10].q = fconvert.d(x87.pop)
[esi + 0xc].d = eax
call(sub_2698)
esp = esp + 0x14
goto 11 @ 0xd83

push(eax)
push(ebx)
call(sub_2740)
ecx = [ebx + 8].d
esp = esp + 8
edi = pop
[ecx + 0x14].d = 2
esi = pop
[ebx + 0xc].b = 1
eax = 0
ebx = pop
esp = ebp
ebp = pop
<return> jump(pop)

if ([ecx + 0x18].b == 0) then 67 @ 0xdba else 87 @ 0xdb1

esi = esp + 0x38
edi = esp + 0x20
call(sub_a0)
x87.push(fconvert.t([esp + 0x20].q))
x87.push(fconvert.t([esp + 0x28].q))
eax = [esp + 0x18].d
st1 = st1 f* st0
[eax + 0x18].b = 1
x87.push(fconvert.t([esp + 0x30].q))
st2 = st2 f+ st0
x87.push(fconvert.t([esp + 0x38].q))
st2 = st2 f* st0
__free_slot(st0)
top = top + 1
st1 = st1 f+ st0
__free_slot(st0)
top = top + 1
[eax + 0x10].q = fconvert.d(x87.pop)
eax = [esp + 0x1c].d
goto 90 @ 0xdee

x87.push(fconvert.t([ecx + 0x10].q))
[ecx + 0x18].b = 0
goto 90 @ 0xdee

[eax].d = [eax].d + 1
eax = [ebx + 8].d
esp = esp - 8
[esp].q = fconvert.d(x87.pop)
[eax + 0x14].d = 1
call(sub_2746)
esp = esp + 8
edi = pop
esi = pop
ebx = pop
esp = ebp
ebp = pop
<return> jump(pop)

int32_t sub_e40(void* arg1)
esp = esp - 0x28
push(ebx)
push(ebp)
push(esi)
push(edi)
edi = [esp + 0x3c {arg1}].d
eax = [edi + 0x10].d
push(eax)
call(sub_2770)
push(eax)
call(sub_2722)
esi = [edi + 8].d
esp = esp + 8
cond:0 = esi == 0
ebp = eax
[esp + 0x1c {var_1c}].d = esi
if (cond:0) then 17 @ 0xe72 else 25 @ 0xe70

push(zx.d(0))
push(0x10006d3c)
push(0x178)
push(0x10006690)
push(zx.d(0x14))
call(sub_26b6)
esp = esp + 0x14
if (al == 0) then 26 @ 0xeb9 else 27 @ 0xe91

if ([esi].d == 0x3b7) then 26 @ 0xeb9 else 17 @ 0xe72

if (([esi + 0xc].b & 2) != 0) then 38 @ 0xefe else 43 @ 0xebb

push(0x10006cf0)
call(sub_26b0)
esp = esp + 4
push(eax)
push(0x440)
call(sub_26aa)
esp = esp + 4
push(eax)
call(sub_26a4)
esp = esp + 8
goto 26 @ 0xeb9

ecx = [esi + 4].d
ebx = [ecx + 0x10].d
call(sub_26da)
esi = eax
if (esi s>= 0) then 51 @ 0xf33 else 61 @ 0xf0f

push(zx.d(0))
push(0x10006d3c)
push(0x17d)
push(0x10006690)
push(zx.d(0x14))
call(sub_26b6)
esp = esp + 0x14
if (al == 0) then 38 @ 0xefe else 71 @ 0xeda

push(zx.d(0))
push(zx.d(1))
push(ebp)
call(sub_26c8)
edx = [0x100093d4].d
ebp = [edx].d
esp = esp + 0xc
cond:1 = eax != 5
[esp + 0x28 {var_10}].d = ebp
if (cond:1) then 82 @ 0x133e else 93 @ 0xf57

push(0x10006d3c)
push(0x184)
push(0x10006690)
call(sub_26d4)
push(esi)
push(0x10006c74)
push(zx.d(0x14))
call(sub_26ce)
esp = esp + 0x18
goto 51 @ 0xf33

push(0x10006ca0)
call(sub_26b0)
esp = esp + 4
push(eax)
push(0x440)
call(sub_26aa)
esp = esp + 4
push(eax)
call(sub_26a4)
esp = esp + 8
goto 38 @ 0xefe

call(sub_267a)
edx = [esp + 0x1c {var_1c}].d
[edx + 0x14].d = 2
[edi + 0xc].b = 1
edi = pop
esi = pop
ebp = pop
eax = 0
ebx = pop
esp = esp + 0x28
<return> jump(pop)

if (ebp s<= 0) then 82 @ 0x133e else 94 @ 0xf5d

eax = [0x100093d8].d
eax = [eax].d
esi = [eax + 0xc].d
cond:2 = [esi].d == 3
[esp + 0x30 {var_8}].d = eax
[esp + 0x20 {var_18}].d = esi
if (cond:2) then 101 @ 0xfc5 else 110 @ 0xf74

ecx = esp + 0x14 {var_24}
push(ecx)
push(zx.d(0))
push(edi)
call(sub_276a)
esp = esp + 0xc
temp0.d = eax
eax = eax - 1
if (temp0.d == 1) then 118 @ 0x1047 else 122 @ 0xfda

push(zx.d(0))
push(0x10006d3c)
push(0x1a5)
push(0x10006690)
push(zx.d(0x14))
call(sub_26b6)
esp = esp + 0x14
if (al == 0) then 101 @ 0xfc5 else 125 @ 0xf93

ecx = [esp + 0x14 {var_24}].d
eax = esi
call(sub_c40)
if (al != 0) then 140 @ 0x1099 else 174 @ 0x1056

temp1.d = eax
eax = eax - 1
if (temp1.d == 1) then 182 @ 0x1004 else 190 @ 0xfdf

push(0x10006c20)
call(sub_26fe)
esp = esp + 4
push(eax)
push(0x1000678c)
call(sub_26b0)
esp = esp + 4
push(eax)
push(0x3080082)
call(sub_26aa)
esp = esp + 4
push(eax)
call(sub_26a4)
esp = esp + 0xc
goto 101 @ 0xfc5

push(ebx)
call(sub_2698)
edx = [esp + 0x18 {var_24}].d
push(edx)
esi = eax
call(sub_2764)
edi = [esp + 0x24 {var_1c}].d
[esp + 0x1c {var_24}].d = eax
eax = [0x100093a8].d
ecx = [eax].d
edx = zx.d([edi + 0xc].b)
push(ecx)
edx = edx & 0xffffff04
push(zx.d(0))
push(edx)
call(sub_2704)
push(esi)
[esp + 0x44 {var_c}].d = eax
call(sub_2698)
eax = [esp + 0x2c {var_24}].d
push(eax)
call(sub_2710)
ecx = [esp + 0x30 {var_24}].d
ebx = [ecx].d
[esp + 0x50 {var_4}].d = eax
eax = 0
ebx = ebx - 1
esp = esp + 0x1c
cond:3 = ebp s<= eax
[esp + 0x24 {var_14}].d = ebx
[esp + 0x3c {arg1}].b = 1
[esp + 0x18 {var_20}].d = eax
[esp + 0x10 {var_28}].d = eax
if (cond:3) then 199 @ 0x131a else 212 @ 0x110c

push(zx.d(0))
push(0x10006d3c)
push(0x1c2)
push(0x10006690)
push(zx.d(0x14))
call(sub_26b6)
esp = esp + 0x14
if (al == 0) then 140 @ 0x1099 else 214 @ 0x1075

push(zx.d(0))
push(0x10006d3c)
push(0x1b2)
push(0x10006690)
push(zx.d(0x14))
call(sub_26b6)
esp = esp + 0x14
if (al == 0) then 118 @ 0x1047 else 225 @ 0x1023

push(0x10006d3c)
push(0x1b6)
push(0x10006690)
call(sub_26d4)
push(0x10006bf4)
push(zx.d(0x14))
call(sub_26ce)
esp = esp + 0x14
goto 118 @ 0x1047

eax = [esp + 0x2c {var_c}].d
[edi + 0x10].d = 2
[edi + 0x18].d = eax
ecx = [esp + 0x14 {var_24}].d
[edi + 0x1c].d = ecx
call(sub_267a)
edi = pop
esi = pop
ebp = pop
eax = 0
ebx = pop
esp = esp + 0x28
<return> jump(pop)

esp = esp
goto 236 @ 0x1110

push(0x10006b54)
call(sub_26b0)
esp = esp + 4
push(eax)
push(0x1006084)
call(sub_26aa)
esp = esp + 4
push(eax)
call(sub_26a4)
esp = esp + 8
goto 140 @ 0x1099

push(0x10006b98)
call(sub_26b0)
esp = esp + 4
push(eax)
push(0x440)
call(sub_26aa)
esp = esp + 4
push(eax)
call(sub_26a4)
esp = esp + 8
goto 118 @ 0x1047

edx = [0x100093f4].d
eax = (ebx << 2) + &data_4
push(eax)
eax = [edx].d
push(eax)
call(sub_275e)
esp = esp + 8
edi = 0
cond:7 = ebx s<= 0
ebp = eax
if (cond:7) then 247 @ 0x1274 else 260 @ 0x1135

edx = [esp + 0x34 {var_4}].d
push(ebp)
push(edx)
call(sub_26f8)
esi = eax
eax = [esp + 0x34 {var_c}].d
push(esi)
push(eax)
call(sub_26f2)
push(esi)
call(sub_2758)
esp = esp + 0x14
goto 261 @ 0x1295

goto 263 @ 0x1140

eax = [esp + 0x18 {var_20}].d
if (eax == 0) then 265 @ 0x12a6 else 268 @ 0x129d

eax = [esp + 0x10 {var_28}].d
if (eax s>= [esp + 0x28 {var_10}].d) then 247 @ 0x1274 else 272 @ 0x114e

eax = [ebp].d
esi = 0
if (eax == esi) then 284 @ 0x12c7 else 286 @ 0x12af

push(eax)
call(sub_26ec)
esp = esp + 4
goto 265 @ 0x12a6

ecx = [esp + 0x30 {var_8}].d
edx = [ecx + 0x10].d
ebx = [edx + (eax << 2)].d
eax = [esp + 0x20 {var_18}].d
push(zx.d(1))
push(eax)
push(ebx)
call(sub_269e)
esp = esp + 0xc
cond:4 = edi != 0
esi = eax
if (cond:4) then 294 @ 0x11db else 295 @ 0x1170

[esp + 0x18 {var_20}].d = esi
goto 296 @ 0x12cb

ecx = [0x100093f4].d
edx = [ecx].d
push(eax)
push(edx)
call(sub_26e6)
esp = esp + 8
[esp + 0x18 {var_20}].d = eax
goto 296 @ 0x12cb

if (esi != 0) then 301 @ 0x11e7 else 303 @ 0x11e1

if (esi == 0) then 304 @ 0x1189 else 306 @ 0x1172

ebx = [esp + 0x24 {var_14}].d
edi = ebx + 1
cond:6 = edi s<= 0
[esp + 0x3c {arg1}].b = 0
if (cond:6) then 314 @ 0x12f8 else 322 @ 0x12db

ecx = [ebp].d
if (ecx == 0) then 323 @ 0x1262 else 325 @ 0x11ee

if ([ebp].d == 0) then 327 @ 0x1219 else 338 @ 0x11e5

[ebp].d = 0
goto 339 @ 0x1195

ecx = [0x100093f4].d
edx = [ecx].d
push(esi)
push(edx)
call(sub_26e6)
esp = esp + 8
[ebp].d = eax
goto 339 @ 0x1195

push(ebp)
call(sub_26ec)
eax = [esp + 0x14 {var_28}].d
eax = eax + 1
esp = esp + 4
cond:5 = eax s< [esp + 0x28 {var_10}].d
[esp + 0x10 {var_28}].d = eax
if (cond:5) then 236 @ 0x1110 else 340 @ 0x1316

goto 342 @ 0x12e0

[esp + 0x10 {var_28}].d = [esp + 0x10 {var_28}].d - 1
if (esi == 0) then 247 @ 0x1274 else 344 @ 0x126b

eax = esi
goto 348 @ 0x11f0

eax = [esp + 0x20 {var_18}].d
push(zx.d(3))
push(eax)
push(ebx)
call(sub_269e)
ebx = [esp + 0x30 {var_14}].d
ecx = ebx - 1
esp = esp + 0xc
cond:8 = edi s>= ecx
[ebp + (edi << 2) + 4].d = eax
if (cond:8) then 353 @ 0x123f else 354 @ 0x1238

if (esi == 0) then 323 @ 0x1262 else 301 @ 0x11e7

if ([esp + 0x3c {arg1}].b != 0) then 294 @ 0x11db else 356 @ 0x1197

edi = [esp + 0x1c {var_1c}].d
goto 199 @ 0x131a

eax = [ebp + (esi << 2)].d
if (eax == 0) then 358 @ 0x12f1 else 360 @ 0x12e8

push(esi)
call(sub_26ec)
esp = esp + 4
goto 247 @ 0x1274

dl = [eax].b
temp2.b = [ecx].b
flag:c = dl u< temp2.b
flag:z = dl == temp2.b
if (not(flag:z)) then 364 @ 0x1210 else 371 @ 0x11f8

if (esi == 0) then 372 @ 0x124a else 374 @ 0x1241

[esp + 0x10 {var_28}].d = [esp + 0x10 {var_28}].d + 1
goto 353 @ 0x123f

eax = [esp + 0x18 {var_20}].d
if (eax != 0) then 378 @ 0x11ab else 379 @ 0x11a1

esi = esi + 1
if (esi s< edi) then 342 @ 0x12e0 else 314 @ 0x12f8

push(eax)
call(sub_26ec)
esp = esp + 4
goto 358 @ 0x12f1

temp3.d = eax
temp4.d = eax
cond:9 = flag:c
eax = sbb.d(temp3.d, temp4.d, cond:9)
flag:c = unimplemented
eax = sbb.d(eax, -1, flag:c)
goto 380 @ 0x1217

if (dl == 0) then 381 @ 0x120c else 383 @ 0x11fa

edi = edi + 1
if (edi s< ebx) then 263 @ 0x1140 else 388 @ 0x1255

push(esi)
call(sub_26ec)
esp = esp + 4
goto 372 @ 0x124a

if (esi == 0) then 303 @ 0x11e1 else 389 @ 0x11ad

if (esi == 0) then 265 @ 0x12a6 else 391 @ 0x11a7

if (eax != 0) then 323 @ 0x1262 else 327 @ 0x1219

eax = 0
goto 380 @ 0x1217

dl = [eax + 1].b
temp5.b = [ecx + 1].b
flag:c = dl u< temp5.b
flag:z = dl == temp5.b
if (not(flag:z)) then 364 @ 0x1210 else 392 @ 0x1202

goto 247 @ 0x1274

ecx = esi
goto 395 @ 0x11b0

goto 301 @ 0x11e7

eax = eax + 2
ecx = ecx + 2
if (dl != 0) then 348 @ 0x11f0 else 381 @ 0x120c

dl = [eax].b
temp6.b = [ecx].b
flag:c = dl u< temp6.b
flag:z = dl == temp6.b
if (not(flag:z)) then 400 @ 0x11d0 else 407 @ 0x11b8

temp7.d = eax
temp8.d = eax
cond:10 = flag:c
eax = sbb.d(temp7.d, temp8.d, cond:10)
flag:c = unimplemented
eax = sbb.d(eax, -1, flag:c)
goto 408 @ 0x11d7

if (dl == 0) then 409 @ 0x11cc else 411 @ 0x11ba

if (eax == 0) then 416 @ 0x1257 else 294 @ 0x11db

eax = 0
goto 408 @ 0x11d7

dl = [eax + 1].b
temp9.b = [ecx + 1].b
flag:c = dl u< temp9.b
flag:z = dl == temp9.b
if (not(flag:z)) then 400 @ 0x11d0 else 420 @ 0x11c2

push(esi)
call(sub_26ec)
esp = esp + 4
goto 261 @ 0x1295

eax = eax + 2
ecx = ecx + 2
if (dl != 0) then 395 @ 0x11b0 else 409 @ 0x11cc

int32_t sub_1360(void* arg1)
push(ecx)
push(ebx)
push(ebp)
push(esi)
esi = [esp + 0x14 {arg1}].d
eax = [esi + 0x10].d
push(edi)
push(eax)
call(sub_2770)
push(eax)
call(sub_2722)
ecx = [esi + 0x14].d
push(ecx)
[esp + 0x1c {var_4}].d = eax
call(sub_2770)
push(eax)
call(sub_2722)
esi = [esi + 8].d
esp = esp + 0x10
cond:0 = esi == 0
[esp + 0x18 {arg1}].d = eax
if (cond:0) then 22 @ 0x13a1 else 30 @ 0x139f

push(zx.d(0))
push(0x10006d9c)
push(0x28a)
push(0x10006690)
push(zx.d(0x14))
call(sub_26b6)
esp = esp + 0x14
if (al == 0) then 31 @ 0x13e8 else 32 @ 0x13c0

if ([esi].d == 0x3b7) then 31 @ 0x13e8 else 22 @ 0x13a1

if (([esi + 0xc].b & 2) == 0) then 43 @ 0x13f0 else 51 @ 0x13ee

push(0x10006cf0)
call(sub_26b0)
esp = esp + 4
push(eax)
push(0x440)
call(sub_26aa)
esp = esp + 4
push(eax)
call(sub_26a4)
esp = esp + 8
goto 31 @ 0x13e8

push(zx.d(0))
push(0x10006d9c)
push(0x290)
push(0x10006690)
push(zx.d(0x14))
call(sub_26b6)
esp = esp + 0x14
if (al == 0) then 52 @ 0x1433 else 63 @ 0x140f

if ([esi + 8].d != 0) then 52 @ 0x1433 else 43 @ 0x13f0

edx = [esi + 4].d
ebp = [edx + 0x10].d
push(ebp)
call(sub_2698)
ebx = eax
eax = [esi + 8].d
push(eax)
call(sub_2764)
edi = eax
esp = esp + 8
if ([edi].d s>= 2) then 74 @ 0x1497 else 97 @ 0x1454

push(0x10006ca0)
call(sub_26b0)
esp = esp + 4
push(eax)
push(0x440)
call(sub_26aa)
esp = esp + 4
push(eax)
call(sub_26a4)
esp = esp + 8
goto 52 @ 0x1433

ecx = [esp + 0x18 {arg1}].d
push(ebp)
call(sub_170)
ecx = zx.d([esi + 0xc].b)
ecx = ecx & 0xffffff04
push(ecx)
ecx = [esp + 0x18 {var_4}].d
push(eax)
edx = edi
[esi + 0x10].d = 2
call(sub_480)
push(ebx)
[esi + 0x18].d = eax
[esi + 0x1c].d = edi
call(sub_2698)
esp = esp + 0x10
edi = pop
esi = pop
ebp = pop
eax = 0
ebx = pop
ecx = pop
<return> jump(pop)

push(zx.d(0))
push(0x10006d9c)
push(0x2a3)
push(0x10006690)
push(zx.d(0x14))
call(sub_26b6)
esp = esp + 0x14
if (al == 0) then 74 @ 0x1497 else 105 @ 0x1473

push(0x10006d48)
call(sub_26b0)
esp = esp + 4
push(eax)
push(0x1006084)
call(sub_26aa)
esp = esp + 4
push(eax)
call(sub_26a4)
esp = esp + 8
goto 74 @ 0x1497

int32_t sub_14e0(int32_t arg1, int32_t arg2, int32_t arg3, int32_t arg4, int32_t arg5, int32_t arg6, int32_t arg7, int32_t arg8, int32_t* arg9, int32_t arg10, char arg11, char arg12, int32_t arg13, int32_t* arg14, int32_t arg15)
esp = esp - 0x98
eax = [0x10008000].d
eax = eax ^ esp
[esp + 0x94 {var_4}].d = eax
ecx = [esp + 0xa8 {arg4}].d
eax = [esp + 0xa4 {arg3}].d
edx = [esp + 0xb4 {arg7}].d
[esp + 0x1c {var_7c}].d = ecx
ecx = [esp + 0xcc {arg13}].d
push(ebx)
ebx = [esp + 0xa4 {arg2}].d
[esp + 0x34 {var_68}].d = ecx
ecx = [esp + 0xd4 {arg14}].d
push(ebp)
ebp = [esp + 0xb4 {arg5}].d
[esp + 0x1c {var_84}].d = eax
eax = [esp + 0xc4 {arg9}].d
[esp + 0x40 {var_60}].d = edx
edx = [ecx].d
push(esi)
esi = [esp + 0xa8 {arg1}].d
[esp + 0x18 {var_8c}].d = ecx
ecx = [esp + 0xcc {arg10}].d
cond:0 = ecx s<= 0
[esp + 0x1c {var_88}].d = eax
eax = [esp + 0xe0 {arg15}].d
push(edi)
edi = [esp + 0xc0 {arg6}].d
[esp + 0x38 {var_70}].d = esi
[esp + 0x44 {var_64}].d = ebx
[esp + 0x14 {var_94}].d = eax
[esp + 0x10 {var_98}].d = edx
if (cond:0) then 33 @ 0x1587 else 47 @ 0x1581

eax = esp + 0x7c {var_2c}
push(eax)
call(sub_2788)
esp = esp + 4
push(edi)
call(sub_273a)
push(eax)
push(0x10003734)
call(sub_272e)
push(eax)
call(sub_2728)
push(eax)
call(sub_2722)
if ([esp + 0xec {arg12}].b != 0) then 48 @ 0x15e0 else 66 @ 0x15bb

if ([esp + 0xc8 {arg8}].d s> ecx) then 82 @ 0x1a4f else 33 @ 0x1587

ecx = [esp + 0x40 {var_7c}].d
edx = [esp + 0x38 {var_84}].d
push(ecx)
push(ebx)
push(esi)
push(esi)
push(eax)
push(ebx)
push(edx)
push(ebx)
push(esi)
eax = esp + 0xb4 {var_2c}
push(0x10006e48)
push(eax)
call(sub_2782)
esp = esp + 0x40
eax = 1
goto 91 @ 0x160b

ecx = [esp + 0x38 {var_84}].d
push(ebx)
push(esi)
push(esi)
push(eax)
push(ebx)
push(ecx)
push(ebx)
push(esi)
edx = esp + 0xb0 {var_2c}
push(0x10006ea8)
push(edx)
call(sub_2782)
esp = esp + 0x3c
eax = 0
goto 91 @ 0x160b

ecx = [esp + 0xa4 {var_4}].d
edi = pop
esi = pop
ebp = pop
ebx = pop
ecx = ecx ^ esp
call(sub_279c)
esp = esp + 0x98
<return> jump(pop)

cond:2 = [esp + 0xd4 {arg11}].b != 0
edx = [0x100093f4].d
ecx = (eax << 2) + &data_10
if (cond:2) then 95 @ 0x1629 else 103 @ 0x1622

eax = [edx].d
push(ecx)
push(eax)
call(sub_268c)
esp = esp + 8
cond:1 = [esp + 0xc8 {arg8}].d != 0
ebx = eax
if (cond:1) then 105 @ 0x16eb else 116 @ 0x1645

ecx = (eax << 2) + &data_c
goto 95 @ 0x1629

edx = [esp + 0x7c {var_2c}].d
push(zx.d(0))
push(zx.d(1))
push(edx)
call(sub_26c8)
ecx = [0x100093d4].d
ecx = [ecx].d
esp = esp + 0xc
cond:3 = eax != 5
[esp + 0x30 {var_78_1}].d = ecx
if (cond:3) then 128 @ 0x1a4b else 130 @ 0x1713

push(zx.d(0))
ecx = esp + 0x9c {var_10}
push(0x10006e44)
push(ecx)
[ebx].d = edi
[ebx + 4].d = 0
call(sub_277c)
esp = esp + 0xc
cond:4 = [esp + 0xd4 {arg11}].b == 0
edx = esp + 0x98 {var_10}
[ebx + 8].d = edx {var_10}
if (cond:4) then 131 @ 0x1684 else 132 @ 0x1679

eax = [esp + 0x14 {var_94}].d
goto 82 @ 0x1a4f

if (ecx s<= 0) then 128 @ 0x1a4b else 134 @ 0x1719

if ([esp + 0xd8 {arg12}].b == 0) then 141 @ 0x16c7 else 152 @ 0x1686

[ebx + 0xc].d = edi
goto 131 @ 0x1684

cond:5 = [esp + 0xc8 {arg8}].d != 0
edx = [0x100093d8].d
eax = [edx].d
esi = [eax + 0xc].d
[esp + 0x34 {var_74_1}].d = eax
[esp + 0x28 {var_80_1}].d = esi
if (cond:5) then 163 @ 0x1794 else 176 @ 0x1736

eax = [esp + 0x1c {var_8c}].d
push(ebx)
push(eax)
call(sub_26f8)
ecx = [esp + 0x1c {var_94}].d
push(eax)
push(ecx)
call(sub_26f2)
esp = esp + 0x10
[esp + 0xc8 {arg8}].d = 1
goto 105 @ 0x16eb

ecx = [esp + 0x20 {var_88}].d
eax = [ecx].d
push(eax)
edx = eax + 1
eax = esp + 0x90 {var_1c}
push(0x10006e44)
push(eax)
[ecx].d = edx
call(sub_277c)
esp = esp + 0xc
if ([esp + 0xd4 {arg11}].b == 0) then 179 @ 0x16bd else 182 @ 0x16b1

eax = esp + 0x4c {var_5c}
push(eax)
call(sub_2788)
ecx = esp + 0x60 {var_4c}
push(ecx)
call(sub_2788)
edx = esp + 0x74 {var_3c}
push(edx)
call(sub_2788)
esp = esp + 0xc
cond:6 = [esp + 0x30 {var_78_1}].d s<= 0
[esp + 0x18 {var_90_1}].d = 0
if (cond:6) then 185 @ 0x1a0e else 188 @ 0x17c8

edi = [esp + 0x10 {var_98}].d
call(sub_b70)
if (al != 0) then 163 @ 0x1794 else 189 @ 0x1743

edx = esp + 0x8c {var_1c}
[ebx + 0xc].d = edx {var_1c}
goto 141 @ 0x16c7

ecx = esp + 0x8c {var_1c}
[ebx + 0x10].d = ecx {var_1c}
goto 141 @ 0x16c7

eax = [esp + 0x4c {var_5c}].d
esi = 0
if (eax == esi) then 197 @ 0x1a25 else 199 @ 0x1a18

goto 204 @ 0x17d0

push(zx.d(0))
push(0x10006e20)
push(0x538)
push(0x10006690)
push(zx.d(0x14))
call(sub_26b6)
esp = esp + 0x14
if (al == 0) then 163 @ 0x1794 else 260 @ 0x1762

eax = [esp + 0x5c {var_4c}].d
if (eax == esi) then 275 @ 0x1a3a else 277 @ 0x1a2d

push(eax)
call(sub_26ec)
esp = esp + 4
[esp + 0x4c {var_5c}].d = esi
goto 197 @ 0x1a25

esi = [esp + 0x48 {var_60}].d
push(esi)
eax = esp + 0x50 {var_5c}
push(0x10006604)
push(eax)
call(sub_2782)
push(ebp)
push(esi)
push(ebp)
ecx = esp + 0x74 {var_4c}
push(0x10006dd8)
push(ecx)
call(sub_2782)
edx = [esp + 0x54 {var_74_1}].d
eax = [edx + 0x10].d
ecx = [esp + 0x38 {var_90_1}].d
edx = [esp + 0x48 {var_80_1}].d
edi = [eax + (ecx << 2)].d
push(zx.d(1))
push(edx)
push(edi)
call(sub_269e)
push(ebp)
esi = eax
push(esi)
push(ebp)
eax = esp + 0xa4 {var_3c}
push(0x10006dd8)
push(eax)
call(sub_2782)
ecx = [esp + 0x68 {var_80_1}].d
esp = esp + 0x40
push(zx.d(2))
push(ecx)
push(edi)
call(sub_269e)
edx = [0x100093f4].d
push(eax)
eax = [edx].d
push(eax)
call(sub_26e6)
ecx = [esp + 0xdc {arg8}].d
push(ecx)
edx = esp + 0xb0 {var_10}
edi = eax
push(0x10006e44)
push(edx)
[esp + 0x5c {var_6c_1}].d = edi
call(sub_277c)
eax = [esp + 0x8c {var_3c}].d
ecx = [esp + 0x7c {var_4c}].d
push(eax)
push(ecx)
call([0x10009308].d)
esp = esp + 0x28
if (eax == 0) then 282 @ 0x18a4 else 302 @ 0x1881

push(0x10006de0)
call(sub_26fe)
esp = esp + 4
push(eax)
push(0x1000671c)
call(sub_26b0)
esp = esp + 4
push(eax)
push(0x1006084)
call(sub_26aa)
esp = esp + 4
push(eax)
call(sub_26a4)
esp = esp + 0xc
goto 163 @ 0x1794

eax = [esp + 0x6c {var_3c}].d
if (eax == esi) then 128 @ 0x1a4b else 311 @ 0x1a42

push(eax)
call(sub_26ec)
esp = esp + 4
[esp + 0x5c {var_4c}].d = esi
goto 275 @ 0x1a3a

push(esi)
push(ebp)
edx = esp + 0x54 {var_5c}
push(0x10006dac)
push(edx)
call(sub_2782)
ecx = [0x100093f4].d
edx = [ecx].d
eax = [esp + 0x5c {var_5c}].d
push(esi)
push(edx)
[esp + 0x28 {var_98}].d = eax
call(sub_26e6)
[ebx].d = eax
esp = esp + 0x18
cond:7 = [esp + 0xd4 {arg11}].b == 0
eax = esp + 0x98 {var_10}
[ebx + 4].d = edi
[ebx + 8].d = eax {var_10}
if (cond:7) then 315 @ 0x18f7 else 316 @ 0x18e8

push(0x10006e20)
push(0x552)  {"uBUhHh"}
push(0x10006690)
call(sub_26d4)
push(0x10006db4)
push(zx.d(0x14))
call(sub_26ce)
esp = esp + 0x14
goto 282 @ 0x18a4

push(eax)
call(sub_26ec)
esp = esp + 4
goto 128 @ 0x1a4b

if ([esp + 0xd8 {arg12}].b == 0) then 319 @ 0x193a else 327 @ 0x18f9

ecx = [esp + 0x10 {var_98}].d
[ebx + 0xc].d = ecx
goto 315 @ 0x18f7

eax = [esp + 0x1c {var_8c}].d
push(ebx)
push(eax)
call(sub_26f8)
esp = esp + 8
cond:8 = esi == 0
edi = eax
if (cond:8) then 338 @ 0x1957 else 340 @ 0x194e

ecx = [esp + 0x20 {var_88}].d
eax = [ecx].d
push(eax)
edx = eax + 1
eax = esp + 0x90 {var_1c}
push(0x10006e44)
push(eax)
[ecx].d = edx
call(sub_277c)
esp = esp + 0xc
if ([esp + 0xd4 {arg11}].b == 0) then 344 @ 0x1930 else 347 @ 0x1924

eax = [esp + 0x3c {var_6c_1}].d
if (eax == 0) then 350 @ 0x1968 else 403 @ 0x195f

push(esi)
call(sub_26ec)
esp = esp + 4
goto 338 @ 0x1957

edx = esp + 0x8c {var_1c}
[ebx + 0xc].d = edx {var_1c}
goto 319 @ 0x193a

ecx = esp + 0x8c {var_1c}
[ebx + 0x10].d = ecx {var_1c}
goto 319 @ 0x193a

esi = [esp + 0x14 {var_94}].d
push(edi)
push(esi)
call(sub_26f2)
push(edi)
call(sub_2758)
ecx = [esp + 0x28 {var_8c}].d
edx = [esp + 0x4c {var_68}].d
eax = [esp + 0xe4 {arg12}].d
push(esi)
push(ecx)
ecx = [esp + 0xe8 {arg11}].d
push(edx)
edx = [esp + 0xe8 {arg10}].d
push(eax)
eax = [esp + 0x3c {var_88}].d
push(ecx)
ecx = [esp + 0x30 {var_98}].d
push(edx)
edx = [ebx].d
push(eax)
eax = [esp + 0xf0 {arg8}].d
eax = eax + 1
push(eax)
eax = [esp + 0x58 {var_7c}].d
push(ecx)
ecx = [esp + 0x54 {var_84}].d
push(edx)
edx = [esp + 0x78 {var_64}].d
push(ebp)
push(eax)
eax = [esp + 0x74 {var_70}].d
push(ecx)
push(edx)
push(eax)
call(sub_14e0)
ecx = esp + 0x94 {var_5c}
esp = esp + 0x48
push(ecx)
[esp + 0x18 {var_94}].d = eax
call(sub_2776)
edx = esp + 0x60 {var_4c}
push(edx)
call(sub_2776)
eax = esp + 0x74 {var_3c}
push(eax)
call(sub_2776)
eax = [esp + 0x24 {var_90_1}].d
eax = eax + 1
esp = esp + 0xc
cond:9 = eax s< [esp + 0x30 {var_78_1}].d
[esp + 0x18 {var_90_1}].d = eax
if (cond:9) then 204 @ 0x17d0 else 185 @ 0x1a0e

push(eax)
call(sub_26ec)
esp = esp + 4
goto 350 @ 0x1968

int32_t __convention("regparm") sub_1a70(int32_t arg1, int32_t arg2, int32_t arg3, int32_t arg4, int32_t arg5, int32_t arg6, int32_t arg7, int32_t arg8, int32_t arg9, int32_t arg10, char arg11, char arg12, int32_t arg13, int32_t* arg14)
push(ecx)
push(ebp)
ebp = [esp + 0x20 {arg9}].d
push(esi)
push(edi)
[esp + 0xc {var_4}].d = 1
call(sub_26da)
esi = eax
if (esi s>= 0) then 9 @ 0x1aaf else 57 @ 0x1a8b

push(ebx)
call(sub_2698)
edx = [esp + 0x3c {arg13}].d
esi = eax
eax = [0x100093a8].d
ecx = [eax].d
push(ecx)
push(zx.d(0))
push(edx)
call(sub_2704)
push(esi)
edi = eax
call(sub_2698)
eax = [esp + 0x50 {arg14}].d
ecx = [esp + 0x48 {arg12}].d
edx = [esp + 0x44 {arg11}].d
push(edi)
push(eax)
eax = [esp + 0x48 {arg10}].d
push(ebx)
push(ecx)
push(edx)
edx = [esp + 0x4c {arg8}].d
push(eax)
eax = [esp + 0x4c {arg7}].d
ecx = esp + 0x38 {var_4}
push(ecx)
ecx = [esp + 0x44 {arg4}].d
push(zx.d(0))
push(ebp)
push(ebp)
push(edx)
edx = [esp + 0x5c {arg6}].d
push(eax)
eax = [esp + 0x5c {arg5}].d
push(ecx)
push(edx)
push(eax)
call(sub_14e0)
esp = esp + 0x50
esi = eax
call(sub_267a)
edi = pop
eax = esi
esi = pop
ebp = pop
ecx = pop
<return> jump(pop)

push(0x10006f28)
push(0x495)
push(0x10006690)
call(sub_26d4)
push(esi)
push(0x10006efc)
push(zx.d(0x14))
call(sub_26ce)
esp = esp + 0x18
goto 9 @ 0x1aaf

int32_t __stdcall sub_1b30(void* arg1, int32_t arg2, int32_t arg3, int32_t arg4, int32_t arg5, int32_t arg6, int32_t arg7, char arg8, int32_t arg9, char arg10)
esp = esp - 0x1c
push(ebx)
push(ebp)
push(esi)
push(edi)
edi = [esp + 0x30 {arg1}].d
eax = [edi + 0x10].d
push(eax)
call(sub_2770), esp += 4
push(eax)
call(sub_2722), esp += 4
ecx = [edi + 0x14].d
push(ecx)
[esp + 0x30 {__return_addr}].d = eax
call(sub_2770), esp += 4
push(eax)
call(sub_2722), esp += 4
edx = [edi + 0x18].d
push(edx)
[esp + 0x34 {arg1}].d = eax
call(sub_2770), esp += 4
push(eax)
call(sub_2722), esp += 4
[esp + 0x34 {arg_8}].d = eax
eax = [edi + 0x1c].d
push(eax)
call(sub_2770), esp += 4
push(eax)
call(sub_2722), esp += 4
esi = [edi + 8].d
ecx = [edi + 0x20].d
bl = 0
esp = esp + 0x20
cond:0 = esi == 0
[esp + 0x18 {arg_c}].d = eax
[esp + 0x14 {arg_8}].d = ecx
[esp + 0x30 {arg_24}].b = bl
if (cond:0) then 38 @ 0x1ba6 else 46 @ 0x1ba4

push(zx.d(0))
push(0x10006f38)
push(0x3f1)
push(0x10006690)
push(zx.d(0x14))
call(sub_26b6)
esp = esp + 0x14
if (al == 0) then 47 @ 0x1bed else 48 @ 0x1bc5

if ([esi].d == 0x3b7) then 47 @ 0x1bed else 38 @ 0x1ba6

if (([esi + 0xc].b & 2) == 0) then 59 @ 0x1bf5 else 67 @ 0x1bf3

push(0x10006cf0)
call(sub_26b0)
esp = esp + 4
push(eax)
push(0x440)
call(sub_26aa)
esp = esp + 4
push(eax)
call(sub_26a4)
esp = esp + 8
goto 47 @ 0x1bed

push(zx.d(0))
push(0x10006f38)
push(0x3f7)
push(0x10006690)
push(zx.d(0x14))
call(sub_26b6)
esp = esp + 0x14
if (al == 0) then 68 @ 0x1c3d else 69 @ 0x1c14

if ([esi + 8].d != 0) then 68 @ 0x1c3d else 59 @ 0x1bf5

if ([edi + 0xe].w != 6) then 80 @ 0x1c56 else 86 @ 0x1c3f

push(0x10006ca0)
call(sub_26b0)
esp = esp + 4
push(eax)
push(0x440)
call(sub_26aa)
esp = esp + 4
push(eax)
call(sub_26a4)
esp = esp + 8
goto 68 @ 0x1c3d

eax = [0x100093f4].d
ecx = [eax].d
push(0x10006f34)
push(ecx)
call(sub_26e6), esp += 8
goto 94 @ 0x1c68

edx = [edi + 0x24].d
push(edx)
call(sub_2770), esp += 4
push(eax)
call(sub_2722), esp += 4
bl = 1
[esp + 0x38 {arg8}].b = bl
goto 94 @ 0x1c68

edx = [esi + 4].d
ebp = [edx + 0x10].d
esp = esp + 8
push(ebp)
[esp + 0x14 {arg_c}].d = eax
call(sub_2698)
[esp + 0x2c {arg_24}].d = eax
eax = [esi + 8].d
push(eax)
call(sub_2764), esp += 4
edi = eax
push(zx.d(0))
call(sub_940)
push(edi)
call(sub_2710), esp += 8
ecx = zx.d([esi + 0xc].b)
edx = [esp + 0x40 {arg10}].d
push(eax)
eax = [esp + 0x28 {arg5}].d
ecx = ecx & 0xffffff04
push(ecx)
ecx = [esp + 0x30 {arg6}].d
push(zx.d(0))
push(edx)
edx = [esp + 0x30 {arg4}].d
push(eax)
eax = [esp + 0x40 {arg_24}].d
push(ecx)
ecx = [esp + 0x48 {arg7}].d
push(edx)
edx = [esp + 0x50 {arg8}].d
push(zx.d(0))
push(eax)
push(ecx)
push(edx)
ebx = ebp
[esi + 0x10].d = 2
call(sub_1a70)
[esi + 0x18].d = eax
eax = [esp + 0x64 {arg9}].d
push(eax)
[esi + 0x1c].d = edi
call(sub_2698)
esp = esp + 0x40
edi = pop
esi = pop
ebp = pop
eax = 0
ebx = pop
esp = esp + 0x1c
<return> jump(pop)

int32_t __stdcall sub_1d00(void* arg1, int32_t arg2, int32_t arg3, int32_t arg4, int32_t arg5, int32_t arg6, int32_t arg7, int32_t arg8, char arg9, int32_t arg10, char arg11)
esp = esp - 0x20
push(ebx)
push(ebp)
push(esi)
push(edi)
edi = [esp + 0x34 {arg1}].d
eax = [edi + 0x10].d
push(eax)
call(sub_2770), esp += 4
push(eax)
call(sub_2722), esp += 4
ecx = [edi + 0x14].d
push(ecx)
[esp + 0x34 {__return_addr}].d = eax
call(sub_2770), esp += 4
push(eax)
call(sub_2722), esp += 4
edx = [edi + 0x18].d
push(edx)
[esp + 0x38 {arg1}].d = eax
call(sub_2770), esp += 4
push(eax)
call(sub_2722), esp += 4
[esp + 0x38 {arg_8}].d = eax
eax = [edi + 0x1c].d
push(eax)
call(sub_2770), esp += 4
push(eax)
call(sub_2722), esp += 4
ecx = [edi + 0x20].d
push(ecx)
[esp + 0x40 {arg_c}].d = eax
call(sub_2770), esp += 4
push(eax)
call(sub_2722), esp += 4
esi = [edi + 8].d
edx = [edi + 0x24].d
bl = 0
esp = esp + 0x28
cond:0 = esi == 0
[esp + 0x18 {arg_10}].d = eax
[esp + 0x14 {arg_c}].d = edx
[esp + 0x34 {arg_2c}].b = bl
if (cond:0) then 44 @ 0x1d89 else 52 @ 0x1d87

push(zx.d(0))
push(0x10006f4c)
push(0x441)
push(0x10006690)
push(zx.d(0x14))
call(sub_26b6)
esp = esp + 0x14
if (al == 0) then 53 @ 0x1dd0 else 54 @ 0x1da8

if ([esi].d == 0x3b7) then 53 @ 0x1dd0 else 44 @ 0x1d89

if (([esi + 0xc].b & 2) == 0) then 65 @ 0x1dd8 else 73 @ 0x1dd6

push(0x10006cf0)
call(sub_26b0)
esp = esp + 4
push(eax)
push(0x440)
call(sub_26aa)
esp = esp + 4
push(eax)
call(sub_26a4)
esp = esp + 8
goto 53 @ 0x1dd0

push(zx.d(0))
push(0x10006f4c)
push(0x447)
push(0x10006690)
push(zx.d(0x14))
call(sub_26b6)
esp = esp + 0x14
if (al == 0) then 74 @ 0x1e20 else 75 @ 0x1df7

if ([esi + 8].d != 0) then 74 @ 0x1e20 else 65 @ 0x1dd8

if ([edi + 0xe].w != 7) then 86 @ 0x1e39 else 92 @ 0x1e22

push(0x10006ca0)
call(sub_26b0)
esp = esp + 4
push(eax)
push(0x440)
call(sub_26aa)
esp = esp + 4
push(eax)
call(sub_26a4)
esp = esp + 8
goto 74 @ 0x1e20

ecx = [0x100093f4].d
edx = [ecx].d
push(0x10006f34)
push(edx)
call(sub_26e6), esp += 8
goto 100 @ 0x1e4c

eax = [edi + 0x28].d
push(eax)
call(sub_2770), esp += 4
push(eax)
call(sub_2722), esp += 4
bl = 1
[esp + 0x3c {arg9}].b = bl
goto 100 @ 0x1e4c

[esp + 0x18 {arg_10}].d = eax
eax = [esi + 4].d
ebp = [eax + 0x10].d
esp = esp + 8
push(ebp)
call(sub_2698)
ecx = [esi + 8].d
push(ecx)
[esp + 0x34 {arg_2c}].d = eax
call(sub_2764), esp += 4
edi = eax
push(zx.d(1))
call(sub_940)
push(edi)
call(sub_2710), esp += 8
edx = zx.d([esi + 0xc].b)
ecx = [esp + 0x24 {arg5}].d
push(eax)
eax = [esp + 0x48 {arg11}].d
edx = edx & 0xffffff04
push(edx)
edx = [esp + 0x30 {arg6}].d
push(zx.d(1))
push(eax)
eax = [esp + 0x30 {arg4}].d
push(ecx)
ecx = [esp + 0x40 {arg7}].d
push(edx)
edx = [esp + 0x48 {arg_2c}].d
push(eax)
eax = [esp + 0x50 {arg8}].d
push(ecx)
ecx = [esp + 0x58 {arg9}].d
push(edx)
push(eax)
push(ecx)
ebx = ebp
[esi + 0x10].d = 2
call(sub_1a70)
edx = [esp + 0x68 {arg10}].d
push(edx)
[esi + 0x18].d = eax
[esi + 0x1c].d = edi
call(sub_2698)
esp = esp + 0x40
edi = pop
esi = pop
ebp = pop
eax = 0
ebx = pop
esp = esp + 0x20
<return> jump(pop)

int32_t sub_2674()
jump([0x1000940c].d)

int32_t sub_267a()
jump([0x10009404].d)

int32_t sub_2680()
jump([0x10009400].d)

int32_t sub_2686()
jump([0x100093fc].d)

int32_t sub_268c()
jump([0x100093f8].d)

int32_t sub_2698()
jump([0x100093f0].d)

int32_t sub_269e()
jump([0x100093ec].d)

int32_t sub_26a4()
jump([0x100093e8].d)

int32_t sub_26aa()
jump([0x100093e4].d)

int32_t sub_26b0()
jump([0x100093e0].d)

int32_t sub_26b6()
jump([0x100093dc].d)

int32_t sub_26c8()
jump([0x100093d0].d)

int32_t sub_26ce()
jump([0x10009380].d)

int32_t sub_26d4()
jump([0x100093cc].d)

int32_t sub_26da()
jump([0x100093c8].d)

int32_t sub_26e0()
jump([0x100093c4].d)

int32_t sub_26e6()
jump([0x100093c0].d)

int32_t sub_26ec()
jump([0x100093bc].d)

int32_t sub_26f2()
jump([0x100093b8].d)

int32_t sub_26f8()
jump([0x100093b4].d)

int32_t sub_26fe()
jump([0x100093b0].d)

int32_t sub_2704()
jump([0x100093ac].d)

int32_t sub_2710()
jump([0x100093a4].d)

int32_t sub_2716()
jump([0x100093a0].d)

int32_t sub_271c()
jump([0x1000939c].d)

int32_t sub_2722()
jump([0x10009398].d)

int32_t sub_2728()
jump([0x10009394].d)

int32_t sub_272e()
jump([0x10009390].d)

int32_t sub_273a()
jump([0x10009388].d)

int32_t sub_2740()
jump([0x10009384].d)

int32_t sub_2746()
jump([0x1000937c].d)

int32_t sub_274c()
jump([0x10009368].d)

int32_t sub_2752()
jump([0x10009354].d)

int32_t sub_2758()
jump([0x10009358].d)

int32_t sub_275e()
jump([0x1000935c].d)

int32_t sub_2764()
jump([0x10009360].d)

int32_t sub_276a()
jump([0x10009364].d)

int32_t sub_2770()
jump([0x10009408].d)

int32_t sub_2776()
jump([0x1000936c].d)

int32_t sub_277c()
jump([0x10009370].d)

int32_t sub_2782()
jump([0x10009374].d)

int32_t sub_2788()
jump([0x10009378].d)

int32_t sub_2790()
jump([0x10009310].d)

int32_t sub_2796()
jump([0x100092c4].d)

void __convention("fastcall") sub_279c(int32_t arg1)
if (ecx != [0x10008000].d) then 1 @ 0x27a6 else 2 @ 0x27a4

<return> tailcall(sub_2b06)

<return> jump(pop)

int32_t sub_27ac()
jump([0x1000930c].d)

int32_t sub_27bf()
push(esi)
push(0x80)
call([0x10009300].d)
esi = eax
push(esi)
call([0x10009304].d)
cond:0 = esi != 0
ecx = pop
ecx = pop
[0x10008480].d = eax
[0x10008470].d = eax
if (cond:0) then 12 @ 0x27e9 else 22 @ 0x27e4

[esi].d = 0
call(sub_2ccd)
push(0x10003cf1)
call(sub_2cbb)
[esp {var_8}].d = 0x10003c0a
call(sub_2cbb)
ecx = pop
eax = 0
esi = pop
<return> jump(pop)

eax = 0
eax = eax + 1
esi = pop
<return> jump(pop)

int32_t __stdcall sub_280c(int32_t arg1, int32_t arg2, int32_t arg3)
eax = [esp + 8 {arg1}].d
push(ebp)
ebp = 0
if (eax != ebp) then 4 @ 0x2825 else 12 @ 0x281d

cond:0 = eax != 1
ecx = [0x100092e4].d
ecx = [ecx].d
push(ebx)
push(esi)
push(edi)
[0x10008450].d = ecx
if (cond:0) then 13 @ 0x2915 else 14 @ 0x283f

if ([0x10008118].d s<= ebp) then 20 @ 0x2859 else 22 @ 0x281f

if (eax != ebp) then 24 @ 0x29c5 else 27 @ 0x291b

eax = [fsbase + 0x18].d
esi = [eax + 4].d
ebx = [0x10009280].d
[esp + 0x18 {arg1}].d = ebp
edi = 0x1000846c
goto 30 @ 0x286f

eax = 0
goto 35 @ 0x29cb

[0x10008118].d = [0x10008118].d - 1
goto 4 @ 0x2825

eax = 0
eax = eax + 1
goto 39 @ 0x29c8

esi = [0x10009280].d
edi = 0x1000846c
goto 43 @ 0x2933

push(ebp)
push(esi)
push(edi)
call(ebx), esp += 0xc
if (eax != ebp) then 48 @ 0x2862 else 49 @ 0x2878

ebp = pop
temp0.d = pop
esp = esp + 0xc
<return> jump(temp0.d)

edi = pop
esi = pop
ebx = pop
goto 35 @ 0x29cb

push(ebp)
push(zx.d(1))
push(edi)
call(esi), esp += 0xc
if (eax != 0) then 50 @ 0x2928 else 53 @ 0x293d

if (eax == esi) then 55 @ 0x287a else 57 @ 0x2864

goto 60 @ 0x2882

push(0x3e8)
call([0x10009284].d), esp += 4
goto 43 @ 0x2933

eax = [0x1000845c].d
if (eax == 2) then 65 @ 0x2951 else 72 @ 0x2947

[esp + 0x18 {arg1}].d = 1
goto 60 @ 0x2882

push(0x3e8)
call([0x10009284].d), esp += 4
goto 30 @ 0x286f

eax = [0x1000845c].d
cond:1 = eax == 0
push(zx.d(2))
esi = pop
if (cond:1) then 76 @ 0x2897 else 84 @ 0x288e

push([0x10008480].d)
ebx = [0x100092f4].d
call(ebx)
ebp = eax
cond:2 = ebp == 0
ecx = pop
if (cond:2) then 87 @ 0x29b2 else 92 @ 0x2966

push(zx.d(0x1f))
call(sub_2e88), esp += 4
ecx = pop
goto 24 @ 0x29c5

push(0x10006410)
push(0x10006208)
[0x1000845c].d = 1
call(sub_2e82)
cond:3 = eax == 0
ecx = pop
ecx = pop
if (cond:3) then 97 @ 0x28bd else 103 @ 0x28b6

push(zx.d(0x1f))
call(sub_2e88), esp += 4
goto 105 @ 0x28d3

push(zx.d(0))
push(edi)
[0x1000845c].d = 0
call([0x10009288].d), esp += 8
goto 24 @ 0x29c5

push([0x10008470].d)
call(ebx)
ecx = pop
esi = eax
goto 108 @ 0x2993

push(0x10006104)
push(0x10006000)
call(sub_2e7c), esp += 4
ecx = pop
[0x1000845c].d = esi
goto 105 @ 0x28d3

eax = 0
goto 39 @ 0x29c8

cond:4 = [esp + 0x1c {arg2}].d != ebp
ecx = pop
if (cond:4) then 110 @ 0x28e8 else 111 @ 0x28da

esi = esi - 4
if (esi u>= ebp) then 115 @ 0x2976 else 116 @ 0x299a

if ([0x10008484].d == ebp) then 123 @ 0x2908 else 125 @ 0x28ea

push(ebp)
push(edi)
call([0x10009288].d), esp += 8
goto 110 @ 0x28e8

if ([esi].d == 0) then 108 @ 0x2993 else 130 @ 0x2978

push(ebp)
call([0x100092fc].d)
ecx = pop
call([0x100092f8].d)
[0x10008470].d = eax
[0x10008480].d = eax
goto 87 @ 0x29b2

[0x10008118].d = [0x10008118].d + 1
goto 24 @ 0x29c5

push(0x10008484)
call(sub_2dc0)
cond:5 = eax == 0
ecx = pop
if (cond:5) then 123 @ 0x2908 else 134 @ 0x28f9

eax = [esi].d
[esp + 0x18 {arg1}].d = eax
call([0x100092f8].d)
if ([esp + 0x18 {arg1}].d == eax) then 108 @ 0x2993 else 139 @ 0x298a

push([esp + 0x1c {arg3}].d)
push(esi)
push([esp + 0x1c {arg1}].d)
call([0x10008484].d), esp += 0xc
goto 123 @ 0x2908

push([esp + 0x18 {arg1}].d)
call(ebx)
ecx = pop
call(eax)
goto 108 @ 0x2993

int32_t sub_29cf()
push(zx.d(0x10))
push(0x100077a8)
call(sub_2eb4), esp += 8
edi = ecx
esi = edx
ebx = [ebp + 8].d
eax = 0
eax = eax + 1
[ebp - 0x1c].d = eax
ecx = 0
[ebp - 4].d = ecx
[0x10008008].d = esi
[ebp - 4].d = eax
if (esi != ecx) then 14 @ 0x2a0c else 15 @ 0x2a00

if (esi == eax) then 16 @ 0x2a13 else 18 @ 0x2a11

if ([0x10008118].d != ecx) then 14 @ 0x2a0c else 19 @ 0x2a02

eax = [0x10006f68].d
if (eax == ecx) then 21 @ 0x2a28 else 22 @ 0x2a1c

if (esi != 2) then 28 @ 0x2a41 else 16 @ 0x2a13

[ebp - 0x1c].d = ecx
goto 34 @ 0x2ac1

if ([ebp - 0x1c].d == 0) then 34 @ 0x2ac1 else 40 @ 0x2a2e

push(edi)
push(esi)
push(ebx)
call(eax), esp += 0xc
[ebp - 0x1c].d = eax
goto 21 @ 0x2a28

push(edi)
push(esi)
push(ebx)
call(sub_2e94), esp += 0xc
[ebp - 0x1c].d = eax
if (esi != 1) then 46 @ 0x2a77 else 47 @ 0x2a53  {"u WPS"}

[ebp - 4].d = 0
[ebp - 4].d = -2
call(sub_2ada)
eax = [ebp - 0x1c].d
call(sub_2ef9)
<return> jump(pop)

push(edi)
push(esi)
push(ebx)
call(sub_280c), esp += 0xc
[ebp - 0x1c].d = eax
if (eax == 0) then 34 @ 0x2ac1 else 28 @ 0x2a41

if (esi == 0) then 48 @ 0x2a7e else 53 @ 0x2a7c

if (eax != 0) then 46 @ 0x2a77 else 54 @ 0x2a55

push(edi)
push(esi)
push(ebx)
call(sub_280c), esp += 0xc
if (eax != 0) then 64 @ 0x2a91 else 65 @ 0x2a8a

if (esi != 3) then 34 @ 0x2ac1 else 48 @ 0x2a7e

push(edi)
push(eax)
push(ebx)
call(sub_2e94), esp += 0xc
push(edi)
push(zx.d(0))
push(ebx)
call(sub_280c), esp += 0xc
eax = [0x10006f68].d
if (eax == 0) then 46 @ 0x2a77 else 67 @ 0x2a6f

if ([ebp - 0x1c].d == 0) then 34 @ 0x2ac1 else 72 @ 0x2a93

[ebp - 0x1c].d = [ebp - 0x1c].d & eax
goto 64 @ 0x2a91

push(edi)
push(zx.d(0))
push(ebx)
call(eax), esp += 0xc
goto 46 @ 0x2a77

eax = [0x10006f68].d
if (eax == 0) then 34 @ 0x2ac1 else 74 @ 0x2a9c

push(edi)
push(esi)
push(ebx)
call(eax), esp += 0xc
[ebp - 0x1c].d = eax
goto 34 @ 0x2ac1

int32_t sub_2aa6(void* arg1 @ ebp)
eax = [ebp - 0x14].d
ecx = [eax].d
ecx = [ecx].d
[ebp - 0x20].d = ecx
push(eax)
push(ecx)
call(sub_2e8e)
ecx = pop
ecx = pop
<return> jump(pop)

int32_t sub_2aba(void* arg1 @ ebp)
esp = [ebp - 0x18].d
[ebp - 0x1c].d = 0
[ebp - 4].d = 0
[ebp - 4].d = -2
call(sub_2ada)
eax = [ebp - 0x1c].d
call(sub_2ef9)
<return> jump(pop)

int32_t sub_2ada()
[0x10008008].d = -1
<return> jump(pop)

int32_t __convention("regparm") sub_2b06(void* arg1, char arg2, int32_t* arg3 @ ebp, long double arg4 @ st0)
al = al
temp0.b = [eax + 0x31].b
[eax + 0x31].b = [eax + 0x31].b + dl
flag:c = temp0.b + dl u< temp0.b
[ebx - 1 {0xffffffff}].d = int.d(st0)
eax = adc.d(eax, 0x10009260, flag:c)
esi = eax
edx = 0
edx = edx | 0x1000a0c8
ecx = 0
ecx = ecx ^ edx
eax = 0xefff5f38
eax = neg.d(eax)
ecx = ecx - eax
push(ecx)
push(esi)
push([edx {0x1000a0c8}].d)
edi = pop
edx = edx + 1
edx = edx + 3
goto 21 @ 0x2b36

ecx = zx.d([edx + edi - 1].b)
ebx = 0
[esi + edi - 1].b = bl
[esi + edi - 1].b = [esi + edi - 1].b | cl
edi = edi - 1
if (edi != 0) then 21 @ 0x2b36 else 27 @ 0x2b4d

ebx = pop
[ebx + 1].d = ebx
call(ebx)
temp1.b = [eax].b
[eax].b = [eax].b + dl
flag:c = temp1.b + dl u< temp1.b
flag:p = unimplemented
flag:a = unimplemented
flag:z = temp1.b == neg.b(dl)
flag:s = temp1.b + dl s< 0
flag:o = add_overflow(temp1.b, dl)
[0x10008204].w = gs
push(flagbit.d(flag:o, 0xb) | flagbit.d(flag:d, 0xa) | flagbit.d(flag:s, 7) | flagbit.d(flag:z, 6) | flagbit.d(flag:a, 4) | flagbit.d(flag:p, 2) | flagbit.d(flag:c, 0))
[0x10008238].d = pop
eax = [ebp].d
[0x1000822c].d = eax
eax = [ebp + 4].d
[0x10008230].d = eax
eax = ebp + 8
[0x1000823c].d = eax
eax = [ebp - 0x320].d
[0x10008178].d = 0x10001
eax = [0x10008230].d
[0x1000812c].d = eax
[0x10008120].d = -0x3ffffbf7
[0x10008124].d = 1
eax = [0x10008000].d
[ebp - 0x328].d = eax
eax = [0x10008004].d
[ebp - 0x324].d = eax
call([0x1000926c].d)
[0x10008170].d = eax
push(zx.d(1))
call(sub_2fc4)
ecx = pop
push(zx.d(0))
call([0x10009270].d), esp += 4
push(0x10006f6c)
call([0x10009274].d), esp += 4
if ([0x10008170].d != 0) then 67 @ 0x2bf6 else 74 @ 0x2bee

push(-0x3ffffbf7)
call([0x10009278].d), esp += 4
push(eax)
call([0x1000927c].d), esp += 4
esp = ebp
ebp = pop
<return> jump(pop)

push(zx.d(1))
call(sub_2fc4)
ecx = pop
goto 67 @ 0x2bf6

int32_t sub_2c0a()
push(0x10008448)
call(sub_2fca)
ecx = pop
<return> jump(pop)

int32_t sub_2c16()
push(zx.d(0x14))
push(0x100077d0)
call(sub_2eb4), esp += 8
push([0x10008480].d)
esi = [0x100092f4].d
call(esi)
ecx = pop
[ebp - 0x1c].d = eax
if (eax != -1) then 9 @ 0x2c45 else 43 @ 0x2c39

push(zx.d(8))
call(sub_2fdc)
ecx = pop
[ebp - 4].d = 0
push([0x10008480].d)
call(esi)
[ebp - 0x1c].d = eax
push([0x10008470].d)
call(esi)
ecx = pop
ecx = pop
[ebp - 0x20].d = eax
eax = ebp - 0x20
push(eax)
eax = ebp - 0x1c
push(eax)
push([ebp + 8].d)
esi = [0x10009304].d
call(esi)
ecx = pop
push(eax)
call(sub_2fd6)
[ebp - 0x24].d = eax
push([ebp - 0x1c].d)
call(esi)
[0x10008480].d = eax
push([ebp - 0x20].d)
call(esi)
esp = esp + 0x14
[0x10008470].d = eax
[ebp - 4].d = -2
call(sub_2cb2)
eax = [ebp - 0x24].d
goto 47 @ 0x2cac

push([ebp + 8].d)
call([0x100092c8].d)
ecx = pop
goto 47 @ 0x2cac

call(sub_2ef9)
<return> jump(pop)

int32_t sub_2cb2()
push(zx.d(8))
call(sub_2fd0)
ecx = pop
<return> jump(pop)

int32_t sub_2cbb(int32_t arg1)
push([esp + 4 {arg1}].d)
call(sub_2c16)
temp0.d = eax
eax = neg.d(eax)
flag:c = temp0.d != 0
eax = sbb.d(eax, eax, flag:c)
eax = neg.d(eax)
ecx = pop
eax = eax - 1
<return> jump(pop)

void sub_2ccd()
push(esi)
push(edi)
eax = 0x10007398
edi = 0x10007498
cond:0 = eax u>= edi
esi = eax
if (cond:0) then 7 @ 0x2cee else 10 @ 0x2cdf

edi = pop
esi = pop
<return> jump(pop)

eax = [esi].d
if (eax == 0) then 12 @ 0x2ce7 else 14 @ 0x2ce5

esi = esi + 4
if (esi u< edi) then 10 @ 0x2cdf else 7 @ 0x2cee

call(eax)
goto 12 @ 0x2ce7

void sub_2cf1()
push(esi)
push(edi)
eax = 0x100075a0
edi = 0x100076a0
cond:0 = eax u>= edi
esi = eax
if (cond:0) then 7 @ 0x2d12 else 10 @ 0x2d03

edi = pop
esi = pop
<return> jump(pop)

eax = [esi].d
if (eax == 0) then 12 @ 0x2d0b else 14 @ 0x2d09

esi = esi + 4
if (esi u< edi) then 10 @ 0x2d03 else 7 @ 0x2d12

call(eax)
goto 12 @ 0x2d0b

int32_t sub_2d16()
jump([0x10009304].d)

int32_t sub_2d40(int16_t* arg1)
ecx = [esp + 4 {arg1}].d
if ([ecx].w == 0x5a4d) then 2 @ 0x2d4e else 5 @ 0x2d4b

eax = [ecx + 0x3c].d
eax = eax + ecx
if ([eax].d != 0x4550) then 5 @ 0x2d4b else 7 @ 0x2d5b

eax = 0
<return> jump(pop)

ecx = 0
cl = [eax + 0x18].w == 0x10b
eax = ecx
<return> jump(pop)

void* sub_2d70(void* arg1, int32_t arg2)
eax = [esp + 4 {arg1}].d
ecx = [eax + 0x3c].d
ecx = ecx + eax
eax = zx.d([ecx + 0x14].w)
push(ebx)
push(esi)
esi = zx.d([ecx + 6].w)
edx = 0
cond:0 = esi u<= 0
push(edi)
eax = eax + ecx + 0x18
if (cond:0) then 12 @ 0x2dac else 14 @ 0x2d8e

eax = 0
goto 16 @ 0x2dae

edi = [esp + 0x14 {arg2}].d
goto 20 @ 0x2d92

edi = pop
esi = pop
ebx = pop
<return> jump(pop)

ecx = [eax + 0xc].d
if (edi u< ecx) then 22 @ 0x2da2 else 25 @ 0x2d99

edx = edx + 1
eax = eax + 0x28
if (edx u< esi) then 20 @ 0x2d92 else 12 @ 0x2dac

ebx = [eax + 8].d
ebx = ebx + ecx
if (edi u< ebx) then 16 @ 0x2dae else 22 @ 0x2da2

int32_t sub_2dc0(int32_t arg1)
push(ebp)
ebp = esp {__saved_ebp}
push(zx.d(-2))
push(0x100077f0)
push(0x10003f0d)
eax = [fsbase].d
push(eax)
esp = esp - 8
push(ebx)
push(esi)
push(edi)
eax = [0x10008000].d
[ebp - 8 {var_c_1}].d = [ebp - 8 {var_c}].d ^ eax
eax = eax ^ ebp
push(eax)
eax = ebp - 0x10 {var_14}
[fsbase].d = eax {var_14}
[ebp - 0x18 {var_1c}].d = esp {var_2c}
[ebp - 4 {var_8_1}].d = 0
push(0x10000000)
call(sub_2d40)
esp = esp + 4
if (eax == 0) then 23 @ 0x2e60 else 34 @ 0x2e0b

[ebp - 4 {var_8_3}].d = -2
eax = 0
ecx = [ebp - 0x10 {var_14}].d
[fsbase].d = ecx
ecx = pop
edi = pop
esi = pop
ebx = pop
esp = ebp
ebp = pop
<return> jump(pop)

eax = [ebp + 8 {arg1}].d
eax = eax - 0x10000000
push(eax)
push(0x10000000)
call(sub_2d70)
esp = esp + 8
if (eax == 0) then 23 @ 0x2e60 else 41 @ 0x2e25

eax = [eax + 0x24].d
eax = eax u>> 0x1f
eax = not.d(eax)
eax = eax & 1
[ebp - 4 {var_8_2}].d = -2
ecx = [ebp - 0x10 {var_14}].d
[fsbase].d = ecx
ecx = pop
edi = pop
esi = pop
ebx = pop
esp = ebp
ebp = pop
<return> jump(pop)

int32_t sub_2e49(void* arg1 @ ebp)
eax = [ebp - 0x14].d
ecx = [eax].d
eax = [ecx].d
edx = 0
dl = eax == -0x3ffffffb
eax = edx
<return> jump(pop)

int32_t sub_2e7c()
jump([0x100092f0].d)

int32_t sub_2e82()
jump([0x100092ec].d)

int32_t sub_2e88()
jump([0x100092e8].d)

int32_t sub_2e8e()
jump([0x100092e0].d)

int32_t __stdcall sub_2e94(int32_t arg1, int32_t arg2)
if ([esp + 8 {arg2}].d != 1) then 1 @ 0x2eae else 6 @ 0x2ea2

eax = 0
eax = eax + 1
temp0.d = pop
esp = esp + 0xc
<return> jump(temp0.d)

if ([0x10006f68].d != 0) then 1 @ 0x2eae else 7 @ 0x2ea4

push([esp + 4 {arg1}].d)
call([0x10009268].d), esp += 4
goto 1 @ 0x2eae

void* sub_2eb4(int32_t arg1 @ esi, int32_t arg2 @ edi, void* arg3)
push(0x10003f0d)
push([fsbase].d)
eax = [esp + 0x10 {arg_8}].d
[esp + 0x10 {arg_8}].d = ebp
ebp = esp + 0x10 {arg_8}
esp = esp - eax
push(ebx)
push(esi)
push(edi)
eax = [0x10008000].d
[ebp - 4 {arg3}].d = [ebp - 4 {arg3}].d ^ eax
eax = eax ^ ebp
push(eax)
[ebp - 0x18 {var_10}].d = esp
push([ebp - 8 {__return_addr}].d)
eax = [ebp - 4 {arg3}].d
[ebp - 4 {arg3}].d = -2
[ebp - 8 {__return_addr}].d = eax
eax = ebp - 0x10 {var_8}
[fsbase].d = eax {var_8}
<return> jump(pop)

int32_t sub_2ef9(int32_t* arg1 @ ebp, int32_t arg2, int32_t arg3, int32_t arg4)
ecx = [ebp - 0x10].d
[fsbase].d = ecx
ecx = pop
edi = pop
edi = pop
esi = pop
ebx = pop
esp = ebp
ebp = pop
push(ecx)
<return> jump(pop)

int32_t sub_2f0d(int32_t arg1, int32_t arg2, int32_t arg3, int32_t arg4)
push([esp + 0x10 {arg4}].d)
push([esp + 0x10 {arg3}].d)
push([esp + 0x10 {arg2}].d)
push([esp + 0x10 {arg1}].d)
push(0x1000379c)
push(0x10008000)
call(sub_2fe2)
esp = esp + 0x18
<return> jump(pop)

int32_t sub_2f30()
push(ebp)
ebp = esp {__saved_ebp}
esp = esp - 0x10
eax = [0x10008000].d
[ebp - 8 {var_c}].d = 0
[ebp - 4 {var_8}].d = 0
push(ebx)
push(edi)
edi = 0xbb40e64e
cond:0 = eax == edi
ebx = 0xffff0000
if (cond:0) then 12 @ 0x2f60 else 31 @ 0x2f55

push(esi)
eax = ebp - 8 {var_c}
push(eax)
call([0x1000928c].d), esp += 4
esi = [ebp - 4 {var_8}].d
esi = esi ^ [ebp - 8 {var_c}].d
call([0x10009258].d)
esi = esi ^ eax
call([0x1000925c].d)
esi = esi ^ eax
call([0x10009260].d)
esi = esi ^ eax
eax = ebp - 0x10 {var_14}
push(eax)
call([0x10009264].d), esp += 4
eax = [ebp - 0xc {var_10}].d
eax = eax ^ [ebp - 0x10 {var_14}].d
esi = esi ^ eax
if (esi != edi) then 32 @ 0x2fa8 else 33 @ 0x2f9f

if ((ebx & eax) == 0) then 12 @ 0x2f60 else 35 @ 0x2f57

if ((ebx & esi) != 0) then 38 @ 0x2fb1 else 43 @ 0x2faa

esi = 0xbb40e64f
goto 38 @ 0x2fb1

eax = not.d(eax)
[0x10008004].d = eax
goto 47 @ 0x2fc0

[0x10008000].d = esi
esi = not.d(esi)
[0x10008004].d = esi
esi = pop
goto 47 @ 0x2fc0

eax = esi
eax = eax << 0x10
esi = esi | eax
goto 38 @ 0x2fb1

edi = pop
ebx = pop
esp = ebp
ebp = pop
<return> jump(pop)

int32_t sub_2fc4()
jump([0x100092dc].d)

int32_t sub_2fca()
jump([0x100092d8].d)

int32_t sub_2fd0()
jump([0x100092d4].d)

int32_t sub_2fd6()
jump([0x100092d0].d)

int32_t sub_2fdc()
jump([0x100092cc].d)

int32_t sub_2fe2()
jump([0x10009314].d)

int32_t __convention("regparm") sub_62c8(char* arg1) __noreturn
al = al
[eax].b = [eax].b + al
[eax].d = [eax].d + eax
[eax].d = [eax].d + eax
al = [0x20800000].b
temp0.b = [eax].b
[eax].b = [eax].b + al
flag:c = temp0.b + al u< temp0.b
[eax].b = sbb.b([eax].b, 0, flag:c)
[eax].b = [eax].b + al
[eax].b - al
[eax].b = [eax].b + al
[eax].b = [eax].b + al
[eax].b = [eax].b + al
al = al
[eax].b = [eax].b + al
[eax].d = [eax].d + eax
[eax].b = [eax].b + al
dh = 0
[eax - 0x7fffffb0].b = [eax - 0x7fffffb0].b + al
[eax].b = [eax].b + al
[eax].b = [eax].b + al
[eax].b = [eax].b + al
[eax].b = [eax].b + al
al = al
[eax].b = [eax].b + al
[eax].b = [eax].b + al
[eax].d = [eax].d + eax
al = al + [eax].b
[eax].b = [eax].b + al
push(0x800000)
[eax].b = [eax].b + al
[eax].b = [eax].b + al
[eax].b = [eax].b + al
[eax + eax].b = [eax + eax].b + al
[eax].b = [eax].b + al
[eax].b = [eax].b + al
[eax].d = [eax].d + eax
[eax].b = [eax].b + al
[eax].b = [eax].b + al
[eax].b = [eax].b
[eax].b = [eax].b + al
[eax].b = [eax].b + al
[eax].b = [eax].b + al
[eax].b = [eax].b + al
[eax + eax].b = [eax + eax].b + al
[eax].b = [eax].b + al
[eax].b = [eax].b + al
[eax].d = [eax].d + eax
[eax + eax].d = [eax + eax].d | eax
[eax - 0x38000000].b = [eax - 0x38000000].b + dl
al = [-0xffffffff97020000].b
[eax].d = [eax].d + eax
al = __in_al_immb(4, eflags)
[eax].b = [eax].b + al
[eax].b = [eax].b + al
[eax].b = [eax].b + al
breakpoint

int32_t __convention("regparm") sub_6597(char* arg1, void* arg2) __noreturn
push(zx.d(es))
[ebx + (eax << 3)].b = [ebx + (eax << 3)].b ^ ah
ebp = 0x41008b
[eax].b = [eax].b + dl
[edx + 0xb50006].b = [edx + 0xb50006].b + bh
trap(0xd)
{ Does not return }

int32_t __convention("regparm") sub_88a7(void* arg1, int32_t arg2, void* arg3)
push(eax)
push(ecx)
push(edx)
push(ebx)
push(esp)
push(ebp)
push(esi)
push(edi)
push(zx.d(es))
al = al & 0x50
al = al + ch
bh = bh + bh
eax = eax + 0x124c740
[eax - 1].b = [eax - 1].b + al
eax = pop
al = al + 0x24
[-0xffffffff90010144].b = [-0xffffffff90010144].b + al
eax = eax & 0x8b832b24
flag:d = 0
al = al & 0x5c
esp = pop
[ecx + 0x4246058].b = [ecx + 0x4246058].b + cl
<return> jump(pop)

int32_t __convention("regparm") sub_8b27(int32_t* arg1, int32_t arg2, char arg3, char* arg4 @ ebp, void** arg5 @ esi, char* arg6 @ edi, long double arg7 @ st0)
[ebp + 0x50010].d = [ebp + 0x50010].d & eax
[eax + 0x240100c1].d = int.d(st0)
eax = [eax].d
edx = edx + 1
temp1.b = [eax].b
[eax].b = [eax].b + al
flag:c = temp1.b + al u< temp1.b
flag:p = unimplemented
flag:a = unimplemented
flag:z = temp1.b == neg.b(al)
flag:s = temp1.b + al s< 0
flag:o = add_overflow(temp1.b, al)
push(flagbit.d(flag:o, 0xb) | flagbit.d(flag:d, 0xa) | flagbit.d(flag:s, 7) | flagbit.d(flag:z, 6) | flagbit.d(flag:a, 4) | flagbit.d(flag:p, 2) | flagbit.d(flag:c, 0))
[eax - 0x75].b = [eax - 0x75].b + al
[0x6c000024].b & al
al = al & 0x8b
temp2.b = [ebp].b
[ebp].b = [ebp].b + bl
flag:c = temp2.b + bl u< temp2.b
flag:s = temp2.b + bl s< 0
flag:o = add_overflow(temp2.b, bl)
if (flag:s != flag:o) then 22 @ 0x8ae5 else 35 @ 0x8b49

ecx = [eax].d
temp3.b = al
al = 0
flag:c = 0
flag:p = unimplemented
flag:a = undefined
flag:z = (temp3.b & 0) == 0
flag:s = (temp3.b & 0) s< 0
flag:o = 0
push(flagbit.d(flag:o, 0xb) | flagbit.d(flag:d, 0xa) | flagbit.d(flag:s, 7) | flagbit.d(flag:z, 6) | flagbit.d(flag:a, 4) | flagbit.d(flag:p, 2) | flagbit.d(flag:c, 0))
[ebx {&data_0}].b = [ebx {&data_0}].b + al
eax = [eax + 0x5d240520].d
goto 38 @ 0x8af2

[eax].b = adc.b([eax].b, cl, flag:c)
eax = [ebx + ebx + 0x6c003b24 {0x6c003b24}].d
goto 42 @ 0x8b52

eax = eax + 1
[esi].d = [esi].d + edi
al = 0
undefined

temp4.d = esp
temp5.d = [esp + edx].d
esp = esp + [esp + edx].d
flag:c = temp4.d + temp5.d u< temp4.d
flag:s = temp4.d + temp5.d s< 0
flag:o = add_overflow(temp4.d, temp5.d)
if (flag:s == flag:o) then 42 @ 0x8b52 else 49 @ 0x8b57

ecx = [eax].d
temp6.b = [eax].b
[eax].b = adc.b(temp6.b, cl, flag:c)
flag:z = adc.b(temp6.b, cl, flag:c) == 0
flag:s = adc.b(temp6.b, cl, flag:c) s< 0
flag:o = unimplemented
if (not(flag:z) && flag:s == flag:o) then 56 @ 0x8bda else 68 @ 0x8b5d

edi = edi + eax
eax = eax - 1
[eax + eax].d = [eax + eax].d + esp
[eax + (edx << 2) + 5].b = [eax + (edx << 2) + 5].b + al
[eax].b = [eax].b + al
[eax].b = [eax].b + al
temp7.d = [eax].d
[eax].d = [eax].d + eax
flag:c = temp7.d + eax u< temp7.d
al = sbb.b(al, 0, flag:c)
eax = eax + 1
undefined

temp0, edi = __insb(edi, dx, eflags)
[edi].b = temp0.b
goto 71 @ 0x8aeb

ecx = ecx + [ebx + 0x24052080 {0x24052080}].d
ebp = pop
goto 38 @ 0x8af2

int32_t sub_8c69(void* arg1 @ esi, int16_t arg2)
dh = 0x24
[ebx {&data_0}].b = [ebx {&data_0}].b & dl
[esi + 0xf6c28].b = [esi + 0xf6c28].b + dh
eax = 0x75022100
ebx = ebx + ebx
ebp = pop
[eax {0x75022100}].d = [eax {0x75022100}].d ^ eax
es = pop.w
[eax {0x75022100}].d = [eax {0x75022100}].d & eax
goto 10 @ 0x8c42

undefined

int32_t __convention("regparm") sub_8db9(void* arg1, int16_t arg2, void* arg3, char* arg4 @ esi, void* arg5 @ edi)
[ecx + 0x44050005].b = [ecx + 0x44050005].b & cl
esp = esp + 1
bh = bh + al
edi = edi + eax
eax = eax + 1
[esi].b = [esi].b + ah
eax = eax - 0x6fffdc00
[-0xffffffff8300001c].b = [-0xffffffff8300001c].b + al
ebp = pop
al = al & 0x4f
cond:0 = al == 0
eflags = __verw_memw([eax].w)
eax = edi
eflags = __sti(eflags)
dh = 1
temp0, edi = __insb(edi, dx, eflags)
[edi].b = temp0.b
if (cond:0) then 18 @ 0x8de7 else 23 @ 0x8de2

bh = bh + bh
[eax + eax].d = [eax + eax].d + esp
eax = eax + 1
eax = eax + 1
undefined

esp = esp + 1
eax = eax + 0x5001c
jump([edi + -0xffffffffffffff90].d)

int32_t __convention("regparm") sub_a4ef(int32_t arg1, char arg2) __noreturn
push(ecx)
cl = 0
0
eax = eax + 1
al = al | 0xff
eax = eax + 1
eax = eax & 0x9325ff93
[ebx - 0xc3ffdb {0xff3c0025}].b = [ebx - 0xc3ffdb {0xff3c0025}].b + dl
eax = eax + 1
esp = esp + 1
[eax + 0x40].d = [eax + 0x40].d + 1
[-0xffffffff93250040].b = [-0xffffffff93250040].b + ah
breakpoint

int32_t sub_a53a() __pure
temp0.d = pop
esp = esp + 0xcccc
<return> jump(temp0.d)

int32_t __convention("regparm") sub_a53f(char arg1) __noreturn
al = al - 0x34
breakpoint

int32_t sub_a65a() __pure
temp0.d = pop
esp = esp + 0xcccc
<return> jump(temp0.d)

int32_t __convention("regparm") sub_a65f(char arg1) __noreturn
al = al | 0xcc
breakpoint

int32_t __convention("regparm") sub_a749(int32_t* arg1, int32_t arg2, int16_t arg3) __noreturn
esp = pop
bl = bl | ch
[eax].d = edx
breakpoint

int32_t __convention("regparm") sub_a8b2(int32_t* arg1, int32_t arg2, int32_t arg3, void* arg4 @ ebp, char* arg5 @ esi, int32_t arg6 @ edi)
esp = esp - 1
[si.d].b = [si.d].b ^ ah
[eax].d = [eax].d + eax
edx = [eax].d
temp1.d = [ebp + 0x24].d
[ebp + 0x24].d = [ebp + 0x24].d ^ 0x75
flag:c = 0
flag:p = unimplemented
flag:a = undefined
flag:z = (temp1.d ^ 0x75) == 0
flag:s = (temp1.d ^ 0x75) s< 0
flag:o = 0
push(ebx)
if (flag:s != flag:o) then 14 @ 0xa8fb else 24 @ 0xa8c1

ah = flagbit.b(flag:s, 7) | flagbit.b(flag:z, 6) | flagbit.b(flag:a, 4) | flagbit.b(flag:p, 2) | flagbit.b(flag:c, 0)
ecx = ecx + [edi].d
temp2.b = [edx + (edx << 1)].b
[edx + (edx << 1)].b = [edx + (edx << 1)].b + ah
flag:c = temp2.b + ah u< temp2.b
[eax + esi + 0x2c].b = adc.b([eax + esi + 0x2c].b, dl, flag:c)
eax = __in_oeax_dx(dx, eflags)
temp0.d = pop
esp = esp + 0x8bf8
<return> jump(temp0.d)

push(zx.d(cs))
al = al | 0x83
bh = bh s>> 0x63
al = al & 0xc4
push(esp)
push(ecx)
[ebp + 0x74560144].d = [ebp + 0x74560144].d - 0x3a
ecx = ebx + 0x75038401
eax = -0x25af7276
[esi].b = [esi].b + al
goto 35 @ 0xa92b

[ebx + 0xc309dff {0xc309dff}].b = rol.b([ebx + 0xc309dff {0xc309dff}].b, 0x75)
temp0, edi = __insb(edi, dx, eflags)
[edi].b = temp0.b
edx:eax = sx.q(eax)
al - -0x7d
flag:d = 1
[ebx + 0x240103c5 {0x240103c5}].d = [ebx + 0x240103c5 {0x240103c5}].d + ecx
goto 43 @ 0xa9b3

esp, es = __les_gprz_memp([ebx + ebx {&data_0}].6)
[eax {0xda508d8a}].b = [eax {0xda508d8a}].b + al
al = al
call(-0xffffffff8b842633)
al = __in_al_immb(0x24, eflags)
temp3.d = eax
eax = eax | 0x34c41b00
flag:c = 0
edi = pop
call(0x5e4cfacc)
eax = adc.d(eax, 0x5b, flag:c)
al = al & 4
ebp = pop
temp4.b = al
al = al & 0x8b
flag:c = 0
push(ebx)
[esi + 0x18].b = sbb.b([esi + 0x18].b, dl, flag:c)
esp = esp + 1
temp0.d = pop
esp = esp + 0xff83
<return> jump(temp0.d)

int32_t __convention("fastcall") sub_a8e2(int32_t arg1, int32_t arg2, void* arg3 @ ebp, int32_t arg4 @ esi, int32_t* arg5 @ edi)
flag:c = 0
flag:z = (ecx & 0x140834c) == 0
if (not(flag:z)) then 3 @ 0xa8aa else 10 @ 0xa8ea

temp1.d = [ebp + 0x33008974].d
[ebp + 0x33008974].d = [ebp + 0x33008974].d - 1
flag:p = unimplemented
flag:a = unimplemented
flag:z = temp1.d == 1
flag:s = temp1.d - 1 s< 0
goto 15 @ 0xa8fb

ch = [ebx {&data_0}].b
eax = [ebx + (ecx << 2) + 0x51c22408].d
temp2.d = [edi].d
flag:c = eax u< temp2.d
if (flag:d) then 21 else 23

ah = flagbit.b(flag:s, 7) | flagbit.b(flag:z, 6) | flagbit.b(flag:a, 4) | flagbit.b(flag:p, 2) | flagbit.b(flag:c, 0)
ecx = ecx + [edi].d
temp3.b = [edx + (edx << 1)].b
[edx + (edx << 1)].b = [edx + (edx << 1)].b + ah
flag:c = temp3.b + ah u< temp3.b
goto 25 @ 0xa901

edi = edi - 4
goto 30 @ 0xa8f4

edi = edi + 4
goto 30 @ 0xa8f4

[eax + esi + 0x2c].b = adc.b([eax + esi + 0x2c].b, dl, flag:c)
eax = __in_oeax_dx(dx, eflags)
temp0.d = pop
esp = esp + 0x8bf8
<return> jump(temp0.d)

temp4.b = [eax + (ebp << 3)].b
cond:0 = flag:c
[eax + (ebp << 3)].b = rlc.b(temp4.b, 1, cond:0)
flag:c = unimplemented
ebp = rlc.d(ebp, cl, flag:c)
temp5.d = edx
temp6.d = [edi + (ebx << 2) + 3].d
edx = edx - [edi + (ebx << 2) + 3].d
flag:c = temp5.d u< temp6.d
eflags = __verr_memw([edx + (edx << 1)].w)
goto 25 @ 0xa901

int32_t __convention("regparm") sub_a909(int32_t* arg1, int32_t arg2, int32_t arg3, void* arg4 @ esi, int32_t arg5 @ edi)
eax = [eax].d
esp = esp - [(esi << 1) + -0xfffffffffa8b8590].d
flag:p = unimplemented
flag:z = (al & al) == 0
if (not(flag:z)) then 5 @ 0xa89e else 6 @ 0xa916

if (not(flag:p)) then 7 else 8 @ 0xa8a4

goto 20 @ 0xa91f

jump(0x74191cb3)

ebp = 0
eax = eax + eax
temp1.b = al
al = al & 0x84
flag:c = 0
temp2.d = [ebp + 0x33008974 {0x33008974}].d
[ebp + 0x33008974 {0x33008974}].d = [ebp + 0x33008974 {0x33008974}].d - 1
flag:p = unimplemented
flag:a = unimplemented
flag:z = temp2.d == 1
flag:s = temp2.d - 1 s< 0
goto 31 @ 0xa8fb

ah = ah | dh
eax = [esp + (edx << 1) - 0x3c].d
push(ebx)
[esi + 0x24].d & edx
push(edx)
al = al & 0xc0
edi - -0x63
[(esi << 1) + -0xffffffff833c996c].b = [(esi << 1) + -0xffffffff833c996c].b ^ cl
flag:d = 1
[ebx + 0x240103c5 {0x240103c5}].d = [ebx + 0x240103c5 {0x240103c5}].d + ecx
goto 41 @ 0xa9b3

ah = flagbit.b(flag:s, 7) | flagbit.b(flag:z, 6) | flagbit.b(flag:a, 4) | flagbit.b(flag:p, 2) | flagbit.b(flag:c, 0)
ecx = ecx + [edi].d
temp3.b = [edx + (edx << 1)].b
[edx + (edx << 1)].b = [edx + (edx << 1)].b + ah
flag:c = temp3.b + ah u< temp3.b
[eax + esi + 0x2c].b = adc.b([eax + esi + 0x2c].b, dl, flag:c)
eax = __in_oeax_dx(dx, eflags)
temp0.d = pop
esp = esp + 0x8bf8
<return> jump(temp0.d)

esp, es = __les_gprz_memp([ebx + ebx {&data_0}].6)
[eax].b = [eax].b + al
al = al
call(-0xffffffff8b842633)
al = __in_al_immb(0x24, eflags)
temp4.d = eax
eax = eax | 0x34c41b00
flag:c = 0
edi = pop
call(0x5e4cfacc)
eax = adc.d(eax, 0x5b, flag:c)
al = al & 4
ebp = pop
temp5.b = al
al = al & 0x8b
flag:c = 0
push(ebx)
[esi + 0x18].b = sbb.b([esi + 0x18].b, dl, flag:c)
esp = esp + 1
temp0.d = pop
esp = esp + 0xff83
<return> jump(temp0.d)

int32_t __convention("regparm") sub_a9dc(char* arg1, int32_t arg2, void* arg3 @ ebp, int32_t arg4 @ edi) __noreturn
[eax].b = [eax].b ^ al
al = al & 0xc4
push(eax)
push(esp)
esi = [ebp + 0x24].d
ecx, es = __les_gprz_memp([ebx + 0x440c9585 {0x440c9585}].6)
esp = esp - 1
temp0, edi = __insb(edi, dx, eflags)
[edi].b = temp0.b
[ebx + (eax << 2)].b = [ebx + (eax << 2)].b << 0x14
al = al & 0x83
[edi + (edx << 1)].b = [edi + (edx << 1)].b + cl
flag:d = 1
temp0.d = ebp
ebp = eax
eax = temp0.d
al = al + ch
push(ebp)
temp1.d = eax
eax = eax + esp
flag:c = temp1.d + esp u< temp1.d
ebp = sbb.d(ebp, ebx, flag:c)
push(ecx)
esi = esi + ebx
breakpoint

int32_t __convention("regparm") sub_aa12(char* arg1, int32_t arg2, int32_t arg3)
esp = [esp {__return_addr}].d
temp0.b = al
al = al & 0x50
flag:c = 0
edx = [eax].d
al = adc.b(al, -0x75, flag:c)
edx = [esp + (ecx << 1) + 0x24].d
esp = esp + 1
al = al | 0x44
push(edx)
al = al & 0x51
[eax].b = [eax].b + ah
edx = [eax].d
push(ecx)
al = al | 0xfd
push(eax)
esp = esp - 1
undefined

int32_t sub_aa31() __noreturn
esp = esp - 1
breakpoint

int32_t sub_aa7a() __pure
temp0.d = pop
esp = esp + 0xcccc
<return> jump(temp0.d)

int32_t __convention("regparm") sub_aa7f(int16_t arg1, int32_t, char arg3) __noreturn
ah = ah | cl
breakpoint

int32_t sub_aad5() __noreturn
esp = esp | 0x20
breakpoint

int32_t __convention("fastcall") sub_ab8a(char arg1, char arg2, void* arg3 @ ebp) __noreturn
push(esi)
[ebp + 0x24330074].b = [ebp + 0x24330074].b + cl
dl = dl + bh
goto 4 @ 0xab20

breakpoint

int32_t sub_ab95(void* arg1 @ esi)
[esi - 0x3f].w = [esi - 0x3f].w << 0x66
eax = 0x3f702e8
temp0.d = pop
esp = esp + 0xa1f
<return> jump(temp0.d)

int32_t sub_aba3() __pure
<return> jump(pop)

int32_t sub_aba4()
undefined

int32_t __convention("regparm") sub_abab(char* arg1, int32_t, int32_t arg3, void* arg4 @ ebp, int32_t arg5 @ esi, int32_t* arg6 @ edi) __noreturn
esi = esi ^ 0xffffff8a
[ebx + 0x4c10c62a {0x4c10c62a}].d = [ebx + 0x4c10c62a {0x4c10c62a}].d + ecx
al, ah, eflags = __aad_immb(0x30, al, ah)
bl = neg.b(bl)
al = al ^ 0x85
[esi + 0x75].b - -0x78
[ebp - 0x387cfeef].d = rol.d([ebp - 0x387cfeef].d, 0x34)
[eax - 0x975ef12].d & ecx
[edi].d = [edi].d - 0x10
esp = esp + 1
[edi - 0x1c].d = [edi - 0x1c].d + edi
push(ebp)
temp0.b = bh
bh = bh + ch
flag:c = temp0.b + ch u< temp0.b
ch = 0xe8
[esi + 7].d = sbb.d([esi + 7].d, 0xe, flag:c)
[edi + 0x2b].b = [edi + 0x2b].b & bl
[eax].b = [eax].b + al
breakpoint

int32_t sub_abe5() __noreturn
esp = esp | 0x10
breakpoint

int32_t __convention("regparm") sub_b087(int32_t arg1, int32_t arg2, int32_t arg3 @ edi)
push(edi)
eax = eax ^ 0x9715850e
push(esi)
temp0.d = ebx
ebx = eax
eax = temp0.d
[eax {&data_0}].d = [eax {&data_0}].d + 1
temp0, edi = __insb(edi, dx, eflags)
[edi].b = temp0.b
eax = [eax {&data_0}].d
al = al & 0x5f
eax = edx
push(ebx)
esi = pop
eax = eax + 1
<return> jump(pop)

int32_t __convention("regparm") sub_b09c(char* arg1, int32_t arg2, char arg3, char* arg4 @ esi, void* arg5 @ edi, void arg6 @ x87control, long double arg7 @ st0)
esp = pop
al = al - 0x20
[eax].b = [eax].b + cl
[ebx {&data_0}].d = [ebx {&data_0}].d - 4
temp2.d = edx
temp3.d = [edi - 0x7d].d
edx = edx + [edi - 0x7d].d
flag:c = temp2.d + temp3.d u< temp2.d
flag:z = temp2.d == neg.d(temp3.d)
es = pop.w
ecx = pop
if (flag:z) then 12 @ 0xb0ae else 17 @ 0xb0ab

temp0.d = edi
edi = eax
eax = temp0.d
push(esi)
goto 19 @ 0xb0b0

flag:c = eax u< 0x56976ac8
goto 19 @ 0xb0b0

temp0, x87status = __fnstcw_memmem16(x87control)
[eax + 0x239300].w = temp0.w
eax = adc.d(eax, 0x408b4035, flag:c)
cond:1 = eax == 0
if (eax s< 0) then 24 @ 0xb132 else 37 @ 0xb0bd

[ecx + (ecx << 2)].d = esp
ecx = pop
temp4.b = al
al = al - 0x75
flag:c = temp4.b u>= 0x75
[ecx - 0x7b].b = sbb.b([ecx - 0x7b].b, bl, flag:c)
[eax].d = edi
esp = esp - 1
temp5.b = dh
temp6.b = dh
dh = dh
flag:o = 0
goto 38 @ 0xb140

if (cond:1) then 39 @ 0xb0ff else 44 @ 0xb0bf

if (flag:o) then 78 @ 0xb18a else 84 @ 0xb142

eax = eax ^ 0x15930800
[edi + 0x406000d8].b = [edi + 0x406000d8].b + dl
eax = eax ^ 0x35ff4053
al = al | 0x8b
jump([ebx + (ecx << 2)].d)

bh = bh + bh
temp0.d = ebx
ebx = eax
eax = temp0.d
eax = eax + 1
al = al | 0xa3
push(zx.d(-0x69))
call([edi + 0x400008].d), esp += 4
eax = eax ^ 0xb053ff
al = 0xff
eax = eax + 1
temp0.d = ebx
ebx = eax
eax = temp0.d
[eax].d = [eax].d + 1
eax = eax ^ 0x97d61540
push(eax)
eax - 0x408b0064
eax = 0x1b840ff
temp0.d = edi
edi = eax
eax = temp0.d
[eax + 0x1d0097].b = [eax + 0x1d0097].b + bh
temp0.d = edi
edi = eax
eax = temp0.d
temp7.d = eax
eax = eax ^ 0x40ff7040
flag:c = 0
al = 0x50
eax = eax + 1
eax = adc.d(eax, -0x6c950069, flag:c)
bh = bh + bh
goto 39 @ 0xb0ff

[esi].b = [esi].b | cl
[ebx - 0x76ef74ef].d = [ebx - 0x76ef74ef].d + eax
temp8.b = al
al = al - 0x7d
flag:c = temp8.b u>= 0x7d
goto 98 @ 0xb11b

edx = esi
edi = pop
ebx = ebx + [ebx + 0x53].d
ecx = pop
temp0 = __fbst(st0)
[edx + (eax << 3) - 0x39].t = temp0.t
__free_slot(st0)
top = top + 1
[eax].d = [eax].d + 1
push(zx.d(es))
esi = pop
al = al | 0xc
[eax + 0x24].d = [eax + 0x24].d + 1
undefined

push(zx.d(es))
al = adc.b(al, -0x2a, flag:c)
if (al == 0) then 101 @ 0xb0b7 else 103 @ 0xb120

eax = eax ^ 0x78408b40
if (eax != 0) then 24 @ 0xb132 else 127 @ 0xb0be

temp0.b = divs.dp.b(ax, [ecx].b)
temp1.b = mods.dp.b(ax, [ecx].b)
al = temp0.b
ah = temp1.b
temp0.d = edi
edi = eax
eax = temp0.d
push(0x6a207400)
ah = 0x24
temp9.b = al
al = 0
flag:c = 0
eax = eax + 1
temp10.b = al
cond:2 = flag:c
al = adc.b(temp10.b, 0, cond:2)
flag:c = adc.b(temp10.b, 0, cond:2) u< temp10.b || (cond:2 && adc.b(temp10.b, 0, cond:2) == temp10.b)
al = sbb.b(al, ch, flag:c)
[ecx + 0x4598924].b = [ecx + 0x4598924].b + cl
ebx = [eax].d
ecx = pop
temp11.d = [ecx - 0x9f7b3c8].d
flag:o = 0
goto 38 @ 0xb140

eax = eax + 1
goto 44 @ 0xb0bf

int32_t __convention("regparm") sub_b1f2(char* arg1, int32_t arg2, void* arg3)
push(eax)
if (flag:z || flag:s != flag:o) then 2 @ 0xb215 else 10 @ 0xb1f5

ecx = [ebx + 0x567cff24 {0x567cff24}].d
esp = esp + 1
temp0.b = dl
temp1.b = [eax].b
dl = dl + [eax].b
flag:c = temp0.b + temp1.b u< temp0.b
al = adc.b(al, 0x57, flag:c)
jump([esp + (ecx << 1)].d)

al = al & 0x40
[edx].d & edx
al = al - 0x75
[ecx - 0x67bbf740].b = [ecx - 0x67bbf740].b + ah
push(zx.d(4))
temp2.b = [ebx {&data_0}].b
[ebx {&data_0}].b = [ebx {&data_0}].b + dh
flag:c = temp2.b + dh u< temp2.b
eax = adc.d(eax, 0x64c293c2, flag:c)
push(eax)
al = al
eax = eax + 1
breakpoint

int32_t sub_b74f() __pure
temp0.d = pop
esp = esp + 0xcccc
<return> jump(temp0.d)

int32_t __convention("fastcall") sub_b752(int32_t arg1, void* arg2, void* arg3 @ ebp)
edx, es = __les_gprz_memp([edx + 0x40].6)
al = __in_al_dx(dx, eflags)
push(eax)
al = __in_al_dx(dx, eflags)
eax = [-0xffffffff91ff5583].d
[eax - 0x75].b = [eax - 0x75].b | dh
[0x558bf8].b = [0x558bf8].b + dl
[ebp + 0x4d].d = eax
[ebx - 0x740774af {0x8bf88b51}].d = edx
eax = eax + 1
[eax].b = [eax].b | cl
edx = edx - 1
flag:c = 0
[ebx + 0x8038bfc {0x8038bfc}].d = ecx
ebp = ebp + 1
edx = pop
[ebp + 0x45].b = [ebp + 0x45].b | dl
flag:c = 0
ebp = ebp - 1
ecx = esp {__return_addr}
ah = ah + cl
eax = __in_oeax_immb(0xcc, eflags)
temp0.d = pop
esp = esp + 0x5dcc  {"_func"}
<return> jump(temp0.d)

int32_t sub_b78a() __noreturn
flag:d = 0
breakpoint

int32_t sub_b945() __noreturn
esp = esp | 1
ebp = pop
[ebp - 0x34].b = rol.b([ebp - 0x34].b, 8)
ecx = esp
flag:d = 0
breakpoint

int32_t __convention("regparm") sub_b9be(char arg1, int32_t, int32_t arg3, void* arg4 @ ebp) __noreturn
push(ecx)
[ebx + 0x3f4488b {0x3f4488b}].b = [ebx + 0x3f4488b {0x3f4488b}].b + cl
push(ebp)
[ebx - 0x76f7f375 {0x89080c8b}].b = [ebx - 0x76f7f375 {0x89080c8b}].b | cl
[ebp - 8].b = [ebp - 8].b | al
[ebp + 0x4d].d = ecx
al = al - 0x7d
ebp = ebp + 1
trap(0xd)
{ Does not return }

int32_t sub_ba65() __pure
temp0.d = pop
esp = esp + 0xcc
<return> jump(temp0.d)

int32_t __convention("regparm") sub_ba69(char arg1) __noreturn
al = al - 0x1b
breakpoint

int32_t sub_baed() __pure
temp0.d = pop
esp = esp + 0x8cc
<return> jump(temp0.d)

int32_t __convention("regparm") sub_baf2(void* arg1, char arg2, void* arg3) __noreturn
[ecx - 0x5e8f1301].b = [ecx - 0x5e8f1301].b + dl
eax = eax + 1
push(ecx)
push(ebp)
temp0.d = ebx
ebx = eax
eax = temp0.d
push(eax)
eax, es = __les_gprz_memp([eax {&data_0}].6)
edx = [0x88b0340].d
flag:d = 0
eax = __in_oeax_immb(0x4d, eflags)
[ebx - 0x3baa277].d = [ebx - 0x3baa277].d + ecx
al = al + 0x45
eax = edx
breakpoint

int32_t __convention("regparm") sub_be60(char* arg1, int32_t arg2, void* arg3, int32_t arg4 @ edi, int80_t arg5 @ st0)
push(esp)
[eax].b = [eax].b + al
[edi + (edx << 2) + 0x40000040].b = [edi + (edx << 2) + 0x40000040].b + bh
eax = eax + 0x15016800
st0 f- fconvert.t([edi - 0x3c68ff01].d)
eax = eax + 1
flag:c = 0
eax = [0x745c0040].d
edx - esp
temp0.d = [ebx + 0x334e8b {0x334e8b}].d
flag:c = temp0.d u< edx
temp1.d = eax
eax = eax + 1
if (temp1.d s> -1) then 14 else 15 @ 0xbe8b

jump(0x5d85bf10)

al = adc.b(al, -0x40, flag:c)
[eax].d = [eax].d + eax
flag:d = 0
eax = ecx
al = al - 0x7d
flag:c = 0
[ebx + ecx - 0x3f].d = [ebx + ecx - 0x3f].d ^ edi
goto 23 @ 0xbe9b

temp2.d = [eax + 0x1e].d
[eax + 0x1e].d = [eax + 0x1e].d + 0x3b
flag:c = temp2.d u>= 0xffffffc5
eax = eax + 1
goto 28 @ 0xbea3

bh = adc.b(bh, bh, flag:c)
al = al | 8
ah = 2
undefined

int32_t sub_d2cb()
push(eax)
eax & 0xfd00c300
undefined

int32_t sub_d2fc()
undefined

int32_t __convention("regparm") sub_d34b(char* arg1, char arg2, int32_t arg3, int32_t* arg4 @ ebp, int32_t arg5 @ esi)
esi = [esi + (ebx << 3) + 0x4b00dc00].d * -0x79
ecx = ecx - 1
if (flag:z || ecx != 0) then 3 @ 0xd388 else 9 @ 0xd355

[eax].b = [eax].b + al
ax = muls.dp.b(al, cl)
[0xe8005c].d = eax
al = __salc(eflags)
ecx = ecx - 1
if (ecx != 0) then 17 @ 0xd403 else 23 @ 0xd394

esp = ebp
ebp = pop
ch = 0xf5
temp1.b = [eax].b
[eax].b = [eax].b + al
cond:0 = temp1.b != neg.b(al)
ecx = ecx - 1
if (cond:0 && ecx != 0) then 29 @ 0xd2e9 else 31 @ 0xd35c

temp0.d = ecx
ecx = eax
eax = temp0.d
ecx = 0xe1f18d
al = al + ah
if (ecx == 0) then 57 @ 0xd3e6 else 58 @ 0xd40d

temp0.d = esp {__return_addr}
esp = eax
eax = temp0.d {__return_addr}
al = al - -0x1d
breakpoint

cl = cl + cl
undefined

eax = pop
ah = ah + dl
[ebx - 0x1c {0xffffffe4}].b = [ebx - 0x1c {0xffffffe4}].b + bl
temp0.d = pop
flag:c = test_bit(temp0.d, 0)
flag:p = test_bit(temp0.d, 2)
flag:a = test_bit(temp0.d, 4)
flag:z = test_bit(temp0.d, 6)
flag:s = test_bit(temp0.d, 7)
flag:d = test_bit(temp0.d, 0xa)
flag:o = test_bit(temp0.d, 0xb)
temp0.d = pop
flag:c = test_bit(temp0.d, 0)
flag:p = test_bit(temp0.d, 2)
flag:a = test_bit(temp0.d, 4)
flag:z = test_bit(temp0.d, 6)
flag:s = test_bit(temp0.d, 7)
flag:d = test_bit(temp0.d, 0xa)
flag:o = test_bit(temp0.d, 0xb)
temp0.d = esi
esi = eax
eax = temp0.d
eax = __in_oeax_immb(0xe7, eflags)
[eax].b = [eax].b + al
__out_immb_al(0xcd, al, eflags)
undefined

jump(-0xffffffffed00d4e1)

<return> jump(pop)

int32_t sub_1f982() __pure
temp0.d = pop
esp = esp + 0x3ed6
<return> jump(temp0.d)

int32_t __convention("regparm") sub_1fd61(int32_t arg1, int32_t arg2, char* arg3, int32_t arg4 @ ebp, char* arg5 @ edi, long double arg6 @ st0)
esp - [edx - 0x15c44fc5].d
esi - esp
eax - [edi].d
al - 0x15
al - 0x6d
al - 0x77
al - -0x76
al - -0x68
al - -8
al - 0x51
flag:c = eax u< 0x3e7f3e75
temp0.d = edx
edx = eax
eax = temp0.d
esi = 0xdb3ec83e
temp1.b = [edi].b
cond:5 = flag:c
[edi].b = adc.b(temp1.b, bh, cond:5)
flag:c = adc.b(temp1.b, bh, cond:5) u< temp1.b || (cond:5 && adc.b(temp1.b, bh, cond:5) == temp1.b)
bh = sbb.b(bh, [edi].b, flag:c)
eax = eax & 0x5e3f3f3f
cond:0 = eax u> 0
al, ah, eflags = __aas(al, ah, eflags)
if (cond:0) then 24 @ 0x1fdd1 else 29 @ 0x1fd92

temp2.d = eax
eax = eax ^ 0x35f935cf
flag:c = 0
eax = adc.d(eax, -0x67c9b0ca, flag:c)
goto 32 @ 0x1fddb

cond:1 = [edi].d != 0x3fa23f94
ecx = ecx - 1
if (cond:1 && ecx != 0) then 43 @ 0x1fdd9 else 45 @ 0x1fd9a

eflags = __sti(eflags)
esi = esi & [ss.d + edi].d
temp3.d = esi
esi = esi + 1
flag:o = add_overflow(temp3.d, 1)
al, ah, eflags = __aaa(al, ah, eflags)
push(eax)
al, ah, eflags = __aaa(al, ah, eflags)
temp0, eflags = __arpl_memw_gpr16([edi].w, si)
[edi].w = temp0.w
if (not(flag:o)) then 46 @ 0x1fe1f else 48 @ 0x1fde8

eax = sx.d(ax)
goto 32 @ 0x1fddb

undefined

eax - 0x3df83de5
goto 54 @ 0x1fe24  {";>B>"}

st0 = st0 f/ float.t([edi].d)
al = __in_al_dx(dx, eflags)
al, ah, eflags = __aaa(al, ah, eflags)
push(zx.d(ds))
[edx].b - bh
if ([ecx + 0x38].b u<= bl) then 59 @ 0x1fe2c else 63 @ 0x1fdf4

edi - [esi].d
edx = edx + 1
[eax].b = [eax].b + dh
[eax].b = [eax].b + al
goto 59 @ 0x1fe2c

[eax].w = [eax].w + ax
temp4.b = [esi + 0x36].b
[esi + 0x36].b = [esi + 0x36].b + dh
if (temp4.b s< neg.b(dh)) then 78 @ 0x1fe6a else 110 @ 0x1fe34  {"$7*70767<7B7H7N7T7Z7`7f7l7r7x7~7"}

[eax].b - -0x74
[esi - 0x48c754c8].b - dl
[ebx].b - cl
[edx + edi + 0x3aa13a96].d - ecx
esp = 0xb33ba93a
eax - esi
edi - eax
eax - [edx].d
al - 0x15
al - 0x57
al - 0x5e
al - -0x74
eax - 0x3da93d96
[0x3df83de5].t = x87.pop{x87c1z}
goto 54 @ 0x1fe24  {";>B>"}

al = al & 0x37
dh = dh - [edi].b
[edi].b = [edi].b ^ dh
al, ah, eflags = __aaa(al, ah, eflags)
cond:2 = al u< 0x37
edx = edx + 1
al, ah, eflags = __aaa(al, ah, eflags)
eax = eax - 1
al, ah, eflags = __aaa(al, ah, eflags)
temp5.d = esi
esi = esi - 1
cond:3 = temp5.d - 1 s< 0
cond:4 = temp5.d s<= 1
al, ah, eflags = __aaa(al, ah, eflags)
push(esp)
al, ah, eflags = __aaa(al, ah, eflags)
edx = pop
al, ah, eflags = __aaa(al, ah, eflags)
push(eax)
push(ecx)
push(edx)
push(ebx)
push(esp)
push(ebp)
push(esi)
push(edi)
al, ah, eflags = __aaa(al, ah, eflags)
al, ah, eflags = __aaa(al, ah, eflags)
temp0, edi = __insb(edi, dx, eflags)
[edi].b = temp0.b
al, ah, eflags = __aaa(al, ah, eflags)
if (cond:2) then 112 @ 0x1febd else 114 @ 0x1fe86

[esi].b = [esi].b ^ 0x88
undefined

bh - cl
goto 115 @ 0x1febf

if (cond:3) then 115 @ 0x1febf else 117 @ 0x1fe88

dh - bl
goto 118 @ 0x1fec1

if (cond:4) then 118 @ 0x1fec1 else 172 @ 0x1fe8a

0
bl - ch
[ecx + edi].b - al
temp6.b = bh
temp7.b = [ecx].b
bh = bh | [ecx].b
flag:c = 0
eax = sbb.d(eax, 0x2f392239, flag:c)
[esi].d - edi
[ebx + 0x39].d - edx
ecx = pop
[eax + 0x39].d - ebp
[ecx].b - -0x63
[ecx + edi + 0x39ae39a9].d - esp
bh = 0x39
[ecx].d = [ecx].d s>> 0xd2
edi - ebp
esp - edi
[edx + edi].d - edx
dl - [si.d - 0x23c6].b
cl - [edi].b
ebx - [ecx].d
ebx - [eax + 0x3b].d
edi = pop
esp - [edi + 0x3b].d
esi = __outsd(dx, [esi].d, esi, eflags)
esi - [edi + 0x3b].d
[ebx {&data_3900}].d - -0x74
edx - [ecx - 0x5ec468c5].d
ebp - [edx - 0x3ec44ac5].d
eax - esi
edx - esi
0
esp - ecx
esp - edi
edi - ebp
eax - [esp + edi].d
edi = edi | [ecx + ebx].d
al - 0x24
al - 0x2a
al - 0x3e
al - 0x53
al - 0x5e
al - 0x76
al - -0x74
al - -0x67
al - -0x30
al - -0x2b
al - -0xc
al - -7
al - 0x18
eax - 0x3d243d1e
bh = bh - [0x3dc63d30].b
undefined

[edi].b & dh
dh = [edi].b
temp0.d = edx
edx = eax
eax = temp0.d
al, ah, eflags = __aaa(al, ah, eflags)
eax = sx.d(ax)
al, ah, eflags = __aaa(al, ah, eflags)
flag:c = test_bit(ah, 0)
flag:p = test_bit(ah, 2)
flag:a = test_bit(ah, 4)
flag:z = test_bit(ah, 6)
flag:s = test_bit(ah, 7)
al, ah, eflags = __aaa(al, ah, eflags)
al - [edi].b
if (flag:d) then 188 else 190

edi = edi - 1
goto 192 @ 0x1fe95

edi = edi + 1
goto 192 @ 0x1fe95

al, ah, eflags = __aaa(al, ah, eflags)
ah = 0x37
undefined

int32_t sub_1fe39()
temp0.d = esp {__return_addr}
esp = eax
eax = temp0.d {__return_addr}
call(-0xffffffffa6389e79)
dl = 0x36
eax = 0xc436be36
undefined

int32_t __convention("regparm") sub_1fea3(int32_t* arg1, int32_t arg2, char* arg3, int32_t arg4 @ ebp, int32_t* arg5 @ esi, int32_t arg6 @ edi, int32_t arg7)
al, ah, eflags = __aaa(al, ah, eflags)
[eax].d = sbb.d([eax].d, edi, flag:c)
[eax].d = [eax].d & edi
bh = bh - [eax].b
eax = eax ^ 0x53384a38
[ebx + 0x38].b - ch
[eax].d - -0x68
[ebp - 0x41c75cc8].b - bl
bl - al
bh - cl
dh - bl
0
bl - ch
[ecx + edi].b - al
temp0.b = bh
temp1.b = [ecx].b
bh = bh | [ecx].b
flag:c = 0
eax = sbb.d(eax, 0x2f392239, flag:c)
[esi].d - edi
[ebx + 0x39].d - edx
ecx = pop
[eax + 0x39].d - ebp
[ecx].b - -0x63
[ecx + edi + 0x39ae39a9].d - esp
bh = 0x39
[ecx].d = [ecx].d s>> 0xd2
edi - ebp
esp - edi
[edx + edi].d - edx
dl - [si.d - 0x23c6].b
cl - [edi].b
ebx - [ecx].d
ebx - [eax + 0x3b].d
edi = pop
esp - [edi + 0x3b].d
esi = __outsd(dx, [esi].d, esi, eflags)
esi - [edi + 0x3b].d
[ebx {&data_3900}].d - -0x74
edx - [ecx - 0x5ec468c5].d
ebp - [edx - 0x3ec44ac5].d
eax - esi
edx - esi
0
esp - ecx
esp - edi
edi - ebp
eax - [esp + edi].d
edi = edi | [ecx + ebx].d
al - 0x24
al - 0x2a
al - 0x3e
al - 0x53
al - 0x5e
al - 0x76
al - -0x74
al - -0x67
al - -0x30
al - -0x2b
al - -0xc
al - -7
al - 0x18
eax - 0x3d243d1e
bh = bh - [0x3dc63d30].b
undefined

int32_t __convention("regparm") sub_1ff4f(int32_t arg1, char* arg2 @ esi, char* arg3 @ edi, long double arg4 @ st0)
eax = adc.d(eax, -0x7bc181c2, flag:c)
bh = [esi].b
temp0.d = pop
flag:c = test_bit(temp0.d, 0)
flag:p = test_bit(temp0.d, 2)
flag:a = test_bit(temp0.d, 4)
flag:z = test_bit(temp0.d, 6)
flag:s = test_bit(temp0.d, 7)
flag:d = test_bit(temp0.d, 0xa)
flag:o = test_bit(temp0.d, 0xb)
if (flag:d) then 11 else 14

[edi].b = al
edi = edi - 1
goto 17 @ 0x1ff5d

[edi].b = al
edi = edi + 1
goto 17 @ 0x1ff5d

ch = 0x3e
[esi].b = [esi].b s>> cl
push(zx.d(ds))
al, ah, eflags = __aas(al, ah, eflags)
temp1.d = edi
temp2.d = [edi].d
edi = edi & [edi].d
flag:c = 0
flag:p = unimplemented
al, ah, eflags = __aaa(al, ah, eflags)
al, ah, eflags = __aas(al, ah, eflags)
edx = pop
al, ah, eflags = __aas(al, ah, eflags)
al, ah, eflags = __aas(al, ah, eflags)
if (not(flag:c)) then 32 @ 0x1ffad else 38 @ 0x1ff6e

[eax + eax].b = [eax + eax].b + dl
[eax].b = [eax].b + al
temp3.b = al
al = al | 0x33
flag:o = 0
goto 39 @ 0x1ffb4

if (not(flag:p)) then 43 @ 0x1ffaf else 48 @ 0x1ff70

temp0, edi = __insb(edi, dx, eflags)
[edi].b = temp0.b
al, ah, eflags = __aas(al, ah, eflags)
if (flag:o) then 58 else 59 @ 0x1ffb8

[eax].b = [eax].b + al
temp4.b = [ebx + esi].b
[ebx + esi].b = [ebx + esi].b + cl
flag:o = add_overflow(temp4.b, cl)
goto 39 @ 0x1ffb4

[edi].d - -0x71
al, ah, eflags = __aas(al, ah, eflags)
bl = 0x3f
ebx = 0xcc3fc63f
al, ah, eflags = __aas(al, ah, eflags)
[edi].b = [edi].b s>> cl
st0 = fconvert.t([edi].d) f/ st0
st0 = float.t([edi].w) f/ st0
al = __in_al_immb(0x3f, eflags)
undefined

jump(&data_1fff7)

edi, es = __les_gprz_memp([edi].6)
push(ebp)
ebp = esp {__return_addr}
esp = esp - 0x3f
[eax].b = [eax].b + dh
[eax + eax].b = [eax + eax].b + dl
[eax].b = [eax].b + al
[edi].b = [edi].b << 0xc8
al, ah, eflags = __aaa(al, ah, eflags)
breakpoint

