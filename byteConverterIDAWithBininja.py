import os
import re
import sys
import gzip
from pathlib import Path
from binaryninja import *
from binaryninja import lineardisassembly
from binaryninja.function import DisassemblySettings
from binaryninja.enums import DisassemblyOption, LinearDisassemblyLineType, InstructionTextTokenType

import multiprocessing
from multiprocessing import Pool, Value, Lock
import tempfile
from functools import partial

import time
from datetime import datetime

from headless_ida import HeadlessIda

def process_file(smp_dir,out_dir, id):
    global counter
    global errorCounter
    global errorIDs
    global lock
    global binLock

    #print("Processing file: " + id)
# Read the .bytes file and convert it to a byte string
    with smp_dir.joinpath(id + ".bytes").open() as file:
        data = file.read()
        items = data.split()
        byte_list = [bytes.fromhex(item) for item in items if len(item) == 2 and item != "??"]
        byte_string = b"".join(byte_list)

    #print("File convert write: " + id)
    with tempfile.NamedTemporaryFile(delete=False) as temp:
    # Write the byte string to a file
        temp.write(byte_string)
        

    print(temp.name)



    bininjaBaseAddress = 0
    bininjaFunctions = []
    bininjaArchDetected = ""

    with binLock:
        print("File with active lock: " + id)
        #binaryninja.set_worker_thread_count(os.cpu_count()-6)
        # Set log level to 'error' to mute warnings
        #binaryninja.disable_default_log()


        # sometimes need to reduce the number of threads if the binary is causing a segmentation fault in binary ninja
        #binaryninja.set_worker_thread_count(1)


        #print(binaryninja.Settings().keys())
        #print(f"Memory limit set to: {binaryninja.Settings().get_integer('analysis.limits.cacheSize')} bytes")

        #sometimes need to reduce the max size of a function if the binary is causing a oom killed from os
        binaryninja.Settings().set_integer("analysis.limits.maxFunctionSize", 2048) #half limit
        #binaryninja.Settings().set_integer("analysis.limits.maxFunctionSize", 8192) #double limit
        #print(f"Memory limit set to: {binaryninja.Settings().get_integer('analysis.limits.maxFunctionSize')} bytes")

        #sometimes play with number of functions update to allow weird binaries to be analyzed
        binaryninja.Settings().set_integer("analysis.limits.maxFunctionUpdateCount", 1) #triple limit
        #print(f"Memory limit set to: {binaryninja.Settings().get_integer('analysis.limits.maxFunctionUpdateCount')} bytes")

        #try a empty
        binaryninja.Settings().set_bool('analysis.linearSweep.permissive', True)
        #binaryninja.log.set_log_level(binaryninja.log.LogLevel.DebugLog)
        # Open the file with the appropriate BinaryViewType
        try:
            bv = binaryninja.load(temp.name)
            
            if bv.arch is None:
                print("Raw")
                bv = binaryninja.load(temp.name, options={'loader.architecture': 'x86_64'})    
            print("Binary View load: " + id)
            # # Perform analysis on the binary view
            bv.update_analysis_and_wait()
            #print("number of functions: " + str(len(bv.functions)))

        
            if len(bv.functions) == 0:
                print("no functions")
                bv = binaryninja.load(temp.name, options={'loader.architecture': 'x86'})

            bv.update_analysis_and_wait()
            #print("number of functions: " + str(len(bv.functions)))
            if len(bv.functions) == 0:
                print("no functions")
                bv = binaryninja.load(temp.name, options={'loader.architecture': 'x86_16'})


            bininjaArchDetected = bv.arch.name
            print(bininjaArchDetected)
            bv.update_analysis_and_wait()

        except:
            print("Error loading binary view")
            with lock:
                errorCounter.value += 1
                errorIDs.append(id)
                print(errorCounter.value)
            return

        print("Binary View analysis: " + id)

        #bv.update_analysis_and_wait()
        try:
            settings = DisassemblySettings()
            settings.set_option(DisassemblyOption.ShowVariableTypesWhenAssigned)
            settings.set_option(DisassemblyOption.GroupLinearDisassemblyFunctions)
            settings.set_option(DisassemblyOption.WaitForIL)

            bininjaBaseAddress = bv.start
            
            for func in bv.functions:
                bininjaFunctions.append((func.start, func.highest_address))


        except:
            print("Error loading binary view")
            with lock:
                errorCounter.value += 1
                errorIDs.append(id)
                print(errorCounter.value)
            return


        emptyBV = False
        if bv.length == 0:
            emptyBV = True
            print("Empty BV")
        #binaryninja.shutdown()

        
        ############################################################################################################################
        #Marks beginning of IDA code after finding function ranges in binary ninja
        ############################################################################################################################
        headlessIda = HeadlessIda("/home/logan/idaedu-8.4/ida64",temp.name)
        import idautils
        import ida_name
        import ida_hexrays
        import ida_funcs
        import ida_nalt
        import ida_bytes
        # Have Fun
        # for func in idautils.Functions():
        #     print(f"{hex(func)} {ida_name.get_ea_name(func)}")
        ida_base_address = ida_nalt.get_imagebase()
        ida_normalized_function_tuples = [
                (start - bininjaBaseAddress + ida_base_address, end - bininjaBaseAddress + ida_base_address)
                for start, end in bininjaFunctions
                ]

        for each in ida_normalized_function_tuples:
            # Delete any existing function at this range if needed
            ida_start, ida_end = each
            ida_funcs.del_func(ida_start)
            
            # Create a new function at the normalized address
            if ida_bytes.is_code(ida_bytes.get_full_flags(ida_start)):
                print(f"Creating function at: {hex(ida_start)} - {hex(ida_end)}")
                ida_funcs.add_func(ida_start, ida_end)
            else:
                print(f"Skipping invalid code at {hex(ida_start)}")

        # Check if Hex-Rays decompiler is available
        if not ida_hexrays.init_hexrays_plugin():
            print("Hex-Rays decompiler is not available.")
        else:
            # Iterate over all functions
            for func in idautils.Functions():
                func = ida_funcs.get_func(func)
                mbr = ida_hexrays.mba_ranges_t(func)
                hf = ida_hexrays.hexrays_failure_t()
                ml = ida_hexrays.mlist_t()
                ida_hexrays.mark_cfunc_dirty(func.start_ea)
                mba = ida_hexrays.gen_microcode(mbr, hf, ml, ida_hexrays.DECOMP_NO_WAIT, ida_hexrays.MMAT_ZERO)
                if not mba:
                    print("0x%08X: %s" % (hf.errea, hf.desc()))
                    #return None
                #return mba
                if mba:
                    # String to hold microcode output
                    microcode_str = ""

                    # Iterate over the basic blocks in the microcode
                    for blk_idx in range(mba.qty):
                        blk = mba.get_mblock(blk_idx)
                        #microcode_str += f"Block {blk_idx}:\n"
                        
                        # Iterate over the instructions in the basic block
                        minsn = blk.head
                        while minsn:
                            insn_str = minsn.dstr()
                            microcode_str += f"  {insn_str}\n"
                            minsn = minsn.next  # Move to the next instruction

                    # Print or store the string representation of the microcode
                    print(f"Microcode for function at {hex(func.start_ea)}:")
                    print(microcode_str)
                else:
                    print(f"Failed to generate microcode for function at {hex(func.start_ea)}: {hf.code}")


        os.remove(temp.name)

    
#print(outputLines)
# Export the linear view of Binary Ninja in low level intermediate language representation

# Path to the samples
smp_dir = os.getcwd() + "/data/samples"
#out_dir = "/mnt/g/microcodeCompressed"
out_dir = os.getcwd() + "/data/pcode"
#smp_dir = '/home/logan/Dev/MicrosoftMalware/train'
#id = '0AnoOZDNbPXIr2MRBSCh'
smp_dir = Path(smp_dir)
out_dir = Path(out_dir)
counter = Value('i', 0)
errorCounter = Value('i', 0)
lock = Lock()
binLock = Lock()
errorIDs = []
now = time.time()

idList = []

timeList = []
# # Iterate over all files in the samples directory
for file in smp_dir.iterdir():
    # # Get the file name and extension
    name, ext = file.name.split(".")
    # # Skip files that don't have the .bytes extension
    if ext != "bytes":
        continue
    # # Get the file name and extension
    id = name
   
    if out_dir.joinpath(id + ".idaMicro").exists() == False:
        idList.append(id)
    elif os.stat(out_dir.joinpath(id + ".idaMicro")).st_size == 0:    
        idList.append(id)
    else:
        counter.value += 1
        #print(counter.value)
        continue

# idList.remove("aOwASN5yLgujBQ7hC8oi")
# idList.remove("JQbyODV7raAtZHldLfS0")
# idList.remove("hSvEjCqKdFGUgplHiX3s")
# idList.remove("6tfw0xSL2FNHOCJBdlaA")
# idList.remove("d0iHC6ANYGon7myPFzBe")
# idList.remove("JFlNr7Vo458dMxwQz6nh")

#need to multithread binary ninja to work
#idList.remove("h3EdyntkIm9wi0B7GH8g")
#idList.remove("dWy5HfqNGPs6vwMxB1m3")
#idList.remove("1eJx34l8pcAFvMuOwrjB")
        
print(counter.value)
print(len(idList)) 

#idList.append("0WQtf1pNPdRqUI7KJFAT")

for each in idList:
    print(each)
    process_file(smp_dir,out_dir, each)
    # if counter.value > 10:
    #     break



print("idlist length:")
print(len(idList))
print("errorCounter:")
print(len(errorIDs))
print(errorIDs)


