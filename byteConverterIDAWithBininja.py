import os
import re
import sys
import gzip
from pathlib import Path
from binaryninja import *
from binaryninja import lineardisassembly
from binaryninja.function import DisassemblySettings
from binaryninja.enums import DisassemblyOption, LinearDisassemblyLineType, InstructionTextTokenType

import multiprocessing
from multiprocessing import Pool, Value, Lock
import tempfile
from functools import partial

import time
from datetime import datetime

import threading

class AnalysisTimeout(Exception):
    pass



from headless_ida import HeadlessIda

def perform_analysis(bv):
    try:
        print("Performing analysis")
        bv.update_analysis_and_wait()
    except Exception as e:
        print(f"Error during analysis: {e}")

def perform_analysis_without_wait(bv):
    log.log_info("Starting analysis update without wait...")
    bv.update_analysis()
    time.sleep(60)  # Sleep for 60 seconds to simulate long analysis
    log.log_info("Analysis update without wait started.")


def run_analysis_with_timeout(bv, timeout=60):
    process = multiprocessing.Process(target=perform_analysis, args=(bv,))
    process.start()

    # Wait for the analysis process to complete or time out
    process.join(timeout)

    if process.is_alive():
        print(f"Analysis timed out after {timeout} seconds. Terminating process.")
        process.terminate()  # Forcefully kill the process if it's hanging
        process.join()  # Ensure the process has been fully terminated
        perform_analysis_without_wait(bv)
        #raise AnalysisTimeout(f"Analysis did not complete within {timeout} seconds.")

def process_file(smp_dir,out_dir, id):
    global counter
    global errorCounter
    global errorIDs
    global lock
    global binLock

    #print("Processing file: " + id)
# Read the .bytes file and convert it to a byte string
    with smp_dir.joinpath(id + ".bytes").open() as file:
        data = file.read()
        items = data.split()
        byte_list = [bytes.fromhex(item) for item in items if len(item) == 2 and item != "??"]
        byte_string = b"".join(byte_list)

    #print("File convert write: " + id)
    with tempfile.NamedTemporaryFile(delete=False) as temp:
    # Write the byte string to a file
        temp.write(byte_string)
        

    print(temp.name)



    bininjaBaseAddress = 0
    bininjaFunctions = []
    bininjaArchDetected = ""

    with binLock:
        print("File with active lock: " + id)
        #binaryninja.set_worker_thread_count(os.cpu_count()-6)
        # Set log level to 'error' to mute warnings
        #binaryninja.disable_default_log()
        log.log_to_stdout(LogLevel.DebugLog)


        # sometimes need to reduce the number of threads if the binary is causing a segmentation fault in binary ninja
        #binaryninja.set_worker_thread_count(1)


        #print(binaryninja.Settings().keys())
        #print(f"Memory limit set to: {binaryninja.Settings().get_integer('analysis.limits.cacheSize')} bytes")

        #sometimes need to reduce the max size of a function if the binary is causing a oom killed from os
        binaryninja.Settings().set_integer("analysis.limits.maxFunctionSize", 2048) #half limit
        #binaryninja.Settings().set_integer("analysis.limits.maxFunctionSize", 8192) #double limit
        #print(f"Memory limit set to: {binaryninja.Settings().get_integer('analysis.limits.maxFunctionSize')} bytes")

        #sometimes play with number of functions update to allow weird binaries to be analyzed
        binaryninja.Settings().set_integer("analysis.limits.maxFunctionUpdateCount", 1) #triple limit
        #print(f"Memory limit set to: {binaryninja.Settings().get_integer('analysis.limits.maxFunctionUpdateCount')} bytes")

        #try a empty
        binaryninja.Settings().set_bool('analysis.linearSweep.permissive', True)
        #binaryninja.log.set_log_level(binaryninja.log.LogLevel.DebugLog)
        # Open the file with the appropriate BinaryViewType
        try:
            
            #only id to hang in all setting tests, disabled auto analysis when loading to allow for timeout
            # if id =="dWy5HfqNGPs6vwMxB1m3":
            #     bv = binaryninja.BinaryViewType.get_view_of_file(temp.name, update_analysis=False)
            #     run_analysis_with_timeout(bv, timeout=60)  # Set timeout for analysis

            #else:
            bv = binaryninja.load(temp.name)
            print(len(bv.functions))
            
            if bv.arch is None:
                print("Raw")
                bv = binaryninja.load(temp.name, options={'loader.architecture': 'x86_64'})
                run_analysis_with_timeout(bv, timeout=60)  # Set timeout for analysis    
            
            # # Perform analysis on the binary view
            #bv.update_analysis_and_wait()
            #print("number of functions: " + str(len(bv.functions)))
            

        
            if len(bv.functions) == 0:
                print("no functions")
                bv = binaryninja.load(temp.name, options={'loader.architecture': 'x86'})
                run_analysis_with_timeout(bv, timeout=60)  # Set timeout for analysis

            #bv.update_analysis_and_wait()
            #print("number of functions: " + str(len(bv.functions)))
            if len(bv.functions) == 0:
                print("no functions")
                bv = binaryninja.load(temp.name, options={'loader.architecture': 'x86_16'})
                run_analysis_with_timeout(bv, timeout=60)  # Set timeout for analysis


            bininjaArchDetected = bv.arch.name
            print("Binary View load: " + id)
            print(bininjaArchDetected)
            #bv.update_analysis_and_wait()
            run_analysis_with_timeout(bv, timeout=60)  # Set timeout for analysis

        except:
            print("Error loading binary view")
            with lock:
                #errorCounter.value += 1
                errorIDs.append(id)
                print(errorCounter.value)
            return

        print("Binary View analysis: " + id)

        #bv.update_analysis_and_wait()
        try:
            # settings = DisassemblySettings()
            # settings.set_option(DisassemblyOption.ShowVariableTypesWhenAssigned)
            # settings.set_option(DisassemblyOption.GroupLinearDisassemblyFunctions)
            # settings.set_option(DisassemblyOption.WaitForIL)

            bininjaBaseAddress = bv.start
            
            for func in bv.functions:
                bininjaFunctions.append((func.start, func.highest_address))


        except:
            print("Error loading binary view")
            with lock:
                #errorCounter.value += 1
                errorIDs.append(id)
                print(errorCounter.value)
            return


        emptyBV = False
        if bv.length == 0:
            emptyBV = True
            print("Empty BV")
        #binaryninja.shutdown()

        
        ############################################################################################################################
        #Marks beginning of IDA code after finding function ranges in binary ninja
        ############################################################################################################################

        print("Loading IDA: " + id)
        try:
            headlessIda = HeadlessIda("/home/logan/idaedu-8.4/ida64",temp.name)
        except Exception as e:
            print(f"Error during analysis: {e}")
            #this error after testing only occured in the dataset when the binary auto analysis
            #required IDA to try and load with a locked processor choice for IDA Edu 8.4
            #writing a blank file since the IR could not be generated
            outputPath = out_dir.joinpath(id + ".idaMicro")
            with open(outputPath, 'w') as f:
                pass
            print("Error loading IDA")
            with lock:
                errorCounter.value += 1
                errorIDs.append(id)
                print(errorCounter.value)
            if errorCounter.value > 50:
                sys.exit(1)
            return
        
        import idautils
        import ida_name
        import ida_hexrays
        import ida_funcs
        import ida_nalt
        import ida_bytes
        import ida_ua
        # Have Fun
        # for func in idautils.Functions():
        #     print(f"{hex(func)} {ida_name.get_ea_name(func)}")
        ida_base_address = ida_nalt.get_imagebase()
        ida_normalized_function_tuples = [
                (start - bininjaBaseAddress + ida_base_address, end - bininjaBaseAddress + ida_base_address)
                for start, end in bininjaFunctions
                ]

        for each in ida_normalized_function_tuples:
            # Delete any existing function at this range if needed
            ida_start, ida_end = each
            ida_funcs.del_func(ida_start)
            # Force IDA to interpret the current address as an instruction
            

            # Create a new function at the normalized address
            if ida_bytes.is_code(ida_bytes.get_full_flags(ida_start)):
                #print(f"Creating function at: {hex(ida_start)} - {hex(ida_end)}")
                ida_funcs.add_func(ida_start, ida_end)
            #else:
                #print(f"Skipping invalid code at {hex(ida_start)}")
                #wanted to correct for the fact that the binary ninja functions are not always
                #considered code in IDA, but took too long to run, 40 samples in 12 hours


                # current_addr = ida_start
                # try:
        
                #     while current_addr < ida_end:
                #         # Force IDA to interpret the current address as an instruction
                #         if not ida_ua.create_insn(current_addr):
                #             print(f"Failed to convert at {hex(current_addr)}")
                #             # Optionally, you can choose to handle the failure or continue
                #             current_addr += 1  # Skip to next byte to avoid infinite loops
                #         else:
                #             # Move to the next instruction
                #             if ida_ua.insn_t().size == 0:
                #                 current_addr += 1
                #             current_addr = ida_ua.insn_t().size + current_addr
                #             print(f"Instruction convert at {hex(current_addr)}")
                # except:
                #     print("Error in force_area_as_code")

                # if ida_bytes.is_code(ida_bytes.get_full_flags(ida_start)):
                #     print(f"Creating function at: {hex(ida_start)} - {hex(ida_end)}")
                #     ida_funcs.add_func(ida_start, ida_end)
                # else:
                #     print(f"Skipping invalid code at {hex(ida_start)}")



        outputPath = out_dir.joinpath(id + ".idaMicro")
        with open(outputPath, 'w') as f:
            try:
            
                # Check if Hex-Rays decompiler is available
                if not ida_hexrays.init_hexrays_plugin():
                    print("Hex-Rays decompiler is not available.")
                else:
                    # Iterate over all functions
                    for func in idautils.Functions():
                        func = ida_funcs.get_func(func)
                        mbr = ida_hexrays.mba_ranges_t(func)
                        hf = ida_hexrays.hexrays_failure_t()
                        ml = ida_hexrays.mlist_t()
                        ida_hexrays.mark_cfunc_dirty(func.start_ea)
                        mba = ida_hexrays.gen_microcode(mbr, hf, ml, ida_hexrays.DECOMP_NO_WAIT, ida_hexrays.MMAT_ZERO)
                        if not mba:
                            #seems to be last malformed function that is causing the error
                            #might be able to break out of the loop and continue
                            print("0x%08X: %s" % (hf.errea, hf.desc()))
                            break
                            #return None
                        #return mba
                        if mba:
                            # String to hold microcode output
                            microcode_str = ""

                            # Iterate over the basic blocks in the microcode
                            for blk_idx in range(mba.qty):
                                blk = mba.get_mblock(blk_idx)
                                #microcode_str += f"Block {blk_idx}:\n"
                                
                                # Iterate over the instructions in the basic block
                                minsn = blk.head
                                while minsn:
                                    insn_str = minsn.dstr()
                                    microcode_str += f"  {insn_str}\n"
                                    minsn = minsn.next  # Move to the next instruction

                            # Print or store the string representation of the microcode
                            #print(f"Microcode for function at {hex(func.start_ea)}:")
                            # print(microcode_str)
                            f.write(f"Microcode for function at {hex(func.start_ea)}:\n")
                            f.write(microcode_str)
                        else:
                            print(f"Failed to generate microcode for function at {hex(func.start_ea)}: {hf.code}")
                            continue
            except:
                print("Error writing to file")
                with lock:
                    #errorCounter.value += 1
                    errorIDs.append(id)
                    print(errorCounter.value)
                #os.remove(outputPath)
                return

        os.remove(temp.name)

    
#print(outputLines)
# Export the linear view of Binary Ninja in low level intermediate language representation

# Path to the samples
#smp_dir = os.getcwd() + "/data/samples"
out_dir = "/mnt/g/microcodeCompressed"
#out_dir = '/home/logan/Dev/Microsoft-Malware-Classification/data/pcode'
smp_dir = '/home/logan/Dev/MicrosoftMalware/train'
#id = '0AnoOZDNbPXIr2MRBSCh'
smp_dir = Path(smp_dir)
out_dir = Path(out_dir)
counter = Value('i', 0)
errorCounter = Value('i', 0)
lock = Lock()
binLock = Lock()
errorIDs = []
now = time.time()

idList = []

timeList = []
# # Iterate over all files in the samples directory
for file in smp_dir.iterdir():
    # # Get the file name and extension
    name, ext = file.name.split(".")
    # # Skip files that don't have the .bytes extension
    if ext != "bytes":
        continue
    # # Get the file name and extension
    id = name
   
    if out_dir.joinpath(id + ".idaMicro").exists() == False:
        idList.append(id)
    elif os.stat(out_dir.joinpath(id + ".idaMicro")).st_size == 0:    
        #idList.append(id)
        counter.value += 1
    else:
        counter.value += 1
        #print(counter.value)
        continue


#idList.remove("cnizHQLPYVmwXT2b3jRE")
#idList.remove("dWy5HfqNGPs6vwMxB1m3")
#idList.remove("8w2sWctxOpoIH7VbFREX")
#need to multithread binary ninja to work
#idList.remove("h3EdyntkIm9wi0B7GH8g")
#idList.remove("goVvB4mFfTO9HKbtp3C6")
#idList.remove("8KNqArVDfusEobR4Y0lO")
        
print(counter.value)
print(len(idList)) 

#idList.append("0WQtf1pNPdRqUI7KJFAT")

for each in idList:
    print(each)
    process_file(smp_dir,out_dir, each)
    # counter.value += 1
    # if counter.value > 10:
    #     break



print("idlist length:")
print(len(idList))
print("errorCounter:")
print(len(errorIDs))
print(errorIDs)


