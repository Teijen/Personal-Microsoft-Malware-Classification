import os
import re
import sys
from pathlib import Path


import multiprocessing
from multiprocessing import Pool, Value, Lock
import tempfile
from functools import partial

import time
from datetime import datetime


import pyhidra
pyhidra.start()

import ghidra
from ghidra.app.util.headless import HeadlessAnalyzer
from ghidra.program.flatapi import FlatProgramAPI
from ghidra.base.project import GhidraProject
from java.lang import String
from ghidra.app.decompiler.flatapi import FlatDecompilerAPI


from ghidra.program.model.listing import CodeUnit
from ghidra.program.model.pcode import PcodeOp
from ghidra.app.decompiler import DecompInterface
from ghidra.util.task import ConsoleTaskMonitor
from ghidra.program.model.listing import Function

def process_file(smp_dir, id):
    global counter
    global errorCounter
    global errorIDs
    global lock
    global binLock

    #print("Processing file: " + id)
# Read the .bytes file and convert it to a byte string
    with smp_dir.joinpath(id + ".bytes").open() as file:
        data = file.read()
        items = data.split()
        byte_list = [bytes.fromhex(item) for item in items if len(item) == 2 and item != "??"]
        byte_string = b"".join(byte_list)

    # Write the PE file to a temporary file
    temp_file_path = os.path.join(tempfile.gettempdir(), "temp_pe_" + id + ".bin")
    


    with open(temp_file_path, "wb") as temp_file:
        # Write your PE header to the file
        temp_file.write(b"MZ")

        # Write the DOS header
        temp_file.write(b"\x4D\x5A")  # e_magic
        temp_file.write(b"\x80\x00\x00\x00")  # e_lfanew

        # Write padding bytes to reach the offset of the NT headers
        temp_file.write(b"\x00" * (0x80 - temp_file.tell()))

        # Write the NT headers
        temp_file.write(b"\x50\x45\x00\x00")  # Signature
        temp_file.write(b"\x4C\x01")  # Machine
        temp_file.write(b"\xE0\x00")  # SizeOfOptionalHeader
        temp_file.write(b"\x03\x01")  # Characteristics
        temp_file.write(b"\x0B\x01")  # Magic
        temp_file.write(len(byte_string).to_bytes(4, byteorder='little'))  # SizeOfCode

        # Calculate the size of the headers
        dos_header_size = 0x40  # Size of the DOS header
        pe_signature_size = 0x4  # Size of the PE signature
        coff_header_size = 0x18  # Size of the COFF header
        optional_header_size = 0xE0  # Size of the optional header

        # Calculate the data offset
        data_offset = dos_header_size + pe_signature_size + coff_header_size + optional_header_size

        # Write padding bytes to reach the offset of the data
        temp_file.write(b"\x00" * (data_offset - temp_file.tell()))


        # Write the .bytes file data
        temp_file.write(byte_string)

    print(temp_file.name)

    with binLock:

        with pyhidra.open_program(temp_file.name, language= 'x86:LE:64:default', compiler = 'gcc' ) as flat_api:
            print("File with active lock: " + id)
            currentProgram = flat_api.getCurrentProgram()
            decompInterface = FlatDecompilerAPI(flat_api)

            listing = currentProgram.getListing()
            print(listing.getCodeUnitAt(flat_api.toAddr(0x1234)))

            for codeUnit in listing.getCodeUnits(True):
                print(codeUnit)



            
            #decompInterface = DecompInterface()
            #decompInterface.openProgram(temp.name)
            # Open the file with the appropriate BinaryViewType
                
            print("Binary View analysis: " + id)
            
            outputPath = smp_dir.joinpath(id + ".pcode")
            try:
                with open(outputPath, 'w') as f:
                # Get all functions and instructions in the program
                    functions = list(currentProgram.getFunctionManager().getFunctions(True))
                    instructions = list(currentProgram.getListing().getInstructions(True))
                    print(functions)

                    # Combine and sort the functions and instructions by their address
                    funcs_and_instrs = sorted(functions + instructions, key=lambda x: x.getEntryPoint() if isinstance(x, Function) else x.getAddress())

                    # Keep track of the functions that have been processed
                    processed_functions = set()

                    # Loop through all functions and instructions in the program
                    for item in funcs_and_instrs:
                        if isinstance(item, Function):
                            # Skip if the function has already been processed
                            if item in processed_functions:
                                continue

                            # Decompile the function
                            decompResult = decompInterface.decompileFunction(item, decompInterface.options.defaultTimeout, ConsoleTaskMonitor())
                            processed_functions.add(item)
                        else:
                            # Decompile the instruction
                            decompResult = decompInterface.decompileFunction(item.getFunction(), decompInterface.options.defaultTimeout, ConsoleTaskMonitor())
                        
                        if decompResult.decompileCompleted():
                            # Get the high function (the decompiled function)
                            highFunction = decompResult.getHighFunction()
                            # Loop through all p-code operations in the function
                            for pcodeOp in highFunction.getPcodeOps():
                                # Write the p-code operation to the file
                                f.write(str(pcodeOp) + "\n")

                with lock:
                    counter.value += 1
                    print(counter.value)

            except:

                print(multiprocessing.current_process())
                print(time.time())
                with lock:
                    errorCounter.value += 1
                    errorIDs.append(id)
                    print(errorCounter.value)
                if f is not None:
                    os.remove(f.name)

            decompInterface.dispose()
        os.remove(temp.name)
#print(outputLines)
# Export the linear view of Binary Ninja in low level intermediate language representation
# # Write the LLIL to a file







# Path to the samples
#smp_dir = '/home/logan/Dev/MicrosoftMalware/train'#os.getcwd() + "/data/samples"
smp_dir = os.getcwd() + "/data/samples"
#id = '0AnoOZDNbPXIr2MRBSCh'
smp_dir = Path(smp_dir)
counter = Value('i', 0)
errorCounter = Value('i', 0)
lock = Lock()
binLock = Lock()
errorIDs = []
now = time.time()

idList = []

timeList = []
# # Iterate over all files in the samples directory
for file in smp_dir.iterdir():
    # # Get the file name and extension
    name, ext = file.name.split(".")
    # # Skip files that don't have the .bytes extension
    if ext != "bytes":
        continue
    # # Get the file name and extension
    id = name
    
    if smp_dir.joinpath(id + ".pcode").exists() == False:
        idList.append(id)
    elif os.stat(smp_dir.joinpath(id + ".pcode")).st_size == 0:
        idList.append(id)
    else:
        counter.value += 1
        #print(counter.value)
        continue
        
print(counter.value)
print(len(idList))

# Create a pool of workers
# with Pool(4) as p:
#     p.map(partial(process_file, smp_dir), idList)

for each in idList:
    print(each)
    process_file(smp_dir, each)




print(errorIDs)


